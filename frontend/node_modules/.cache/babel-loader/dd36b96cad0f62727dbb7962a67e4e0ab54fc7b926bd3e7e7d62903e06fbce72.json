{"ast":null,"code":"import { __asyncValues, __awaiter, __extends, __generator, __values } from \"tslib\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport AsyncStorageDatabase from './AsyncStorageDatabase';\nimport { OpType, QueryOne } from '../../types';\nimport { DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR, traverseModel, validatePredicate, inMemoryPagination, keysEqual, getStorename, getIndexKeys } from '../../util';\nimport { StorageAdapterBase } from './StorageAdapterBase';\nvar AsyncStorageAdapter = /** @class */function (_super) {\n  __extends(AsyncStorageAdapter, _super);\n  function AsyncStorageAdapter() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  // no-ops for this adapter\n  AsyncStorageAdapter.prototype.preSetUpChecks = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/];\n      });\n    });\n  };\n\n  AsyncStorageAdapter.prototype.preOpCheck = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/];\n      });\n    });\n  };\n  /**\n   * Open AsyncStorage database\n   * Create new DB if one doesn't exist\n   *\n   * Called by `StorageAdapterBase.setUp()`\n   *\n   * @returns AsyncStorageDatabase instance\n   */\n  AsyncStorageAdapter.prototype.initDb = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var db;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            db = new AsyncStorageDatabase();\n            return [4 /*yield*/, db.init()];\n          case 1:\n            _a.sent();\n            return [2 /*return*/, db];\n        }\n      });\n    });\n  };\n  AsyncStorageAdapter.prototype.clear = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.db.clear()];\n          case 1:\n            _a.sent();\n            this.db = undefined;\n            this.initPromise = undefined;\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  AsyncStorageAdapter.prototype.batchSave = function (modelConstructor, items) {\n    return __awaiter(this, void 0, void 0, function () {\n      var modelName, namespaceName, storeName, keys, batch, _loop_1, this_1, items_1, items_1_1, item;\n      var e_1, _a;\n      var _this = this;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (items.length === 0) {\n              return [2 /*return*/, []];\n            }\n            modelName = modelConstructor.name;\n            namespaceName = this.namespaceResolver(modelConstructor);\n            storeName = getStorename(namespaceName, modelName);\n            keys = getIndexKeys(this.schema.namespaces[namespaceName], modelName);\n            batch = [];\n            _loop_1 = function (item) {\n              var model = this_1.modelInstanceCreator(modelConstructor, item);\n              var connectedModels = traverseModel(modelName, model, this_1.schema.namespaces[namespaceName], this_1.modelInstanceCreator, this_1.getModelConstructorByModelName);\n              var keyValuesPath = this_1.getIndexKeyValuesPath(model);\n              var instance = connectedModels.find(function (_a) {\n                var instance = _a.instance;\n                var instanceKeyValuesPath = _this.getIndexKeyValuesPath(instance);\n                return keysEqual([instanceKeyValuesPath], [keyValuesPath]);\n              }).instance;\n              batch.push(instance);\n            };\n            this_1 = this;\n            try {\n              for (items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {\n                item = items_1_1.value;\n                _loop_1(item);\n              }\n            } catch (e_1_1) {\n              e_1 = {\n                error: e_1_1\n              };\n            } finally {\n              try {\n                if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);\n              } finally {\n                if (e_1) throw e_1.error;\n              }\n            }\n            return [4 /*yield*/, this.db.batchSave(storeName, batch, keys)];\n          case 1:\n            return [2 /*return*/, _b.sent()];\n        }\n      });\n    });\n  };\n  AsyncStorageAdapter.prototype._get = function (storeName, keyArr) {\n    return __awaiter(this, void 0, void 0, function () {\n      var itemKeyValuesPath;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            itemKeyValuesPath = keyArr.join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR);\n            return [4 /*yield*/, this.db.get(itemKeyValuesPath, storeName)];\n          case 1:\n            return [2 /*return*/, _a.sent()];\n        }\n      });\n    });\n  };\n  AsyncStorageAdapter.prototype.save = function (model, condition) {\n    var e_2, _a;\n    return __awaiter(this, void 0, void 0, function () {\n      var _b, storeName, connectionStoreNames, modelKeyValues, fromDB, result, connectionStoreNames_1, connectionStoreNames_1_1, resItem, storeName_1, item, instance, keys, itemKeyValues, fromDB_1, opType, e_2_1;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            _b = this.saveMetadata(model), storeName = _b.storeName, connectionStoreNames = _b.connectionStoreNames, modelKeyValues = _b.modelKeyValues;\n            return [4 /*yield*/, this._get(storeName, modelKeyValues)];\n          case 1:\n            fromDB = _c.sent();\n            this.validateSaveCondition(condition, fromDB);\n            result = [];\n            _c.label = 2;\n          case 2:\n            _c.trys.push([2, 9, 10, 15]);\n            connectionStoreNames_1 = __asyncValues(connectionStoreNames);\n            _c.label = 3;\n          case 3:\n            return [4 /*yield*/, connectionStoreNames_1.next()];\n          case 4:\n            if (!(connectionStoreNames_1_1 = _c.sent(), !connectionStoreNames_1_1.done)) return [3 /*break*/, 8];\n            resItem = connectionStoreNames_1_1.value;\n            storeName_1 = resItem.storeName, item = resItem.item, instance = resItem.instance, keys = resItem.keys;\n            itemKeyValues = keys.map(function (key) {\n              return item[key];\n            });\n            return [4 /*yield*/, this._get(storeName_1, itemKeyValues)];\n          case 5:\n            fromDB_1 = _c.sent();\n            opType = fromDB_1 ? OpType.UPDATE : OpType.INSERT;\n            if (!(keysEqual(itemKeyValues, modelKeyValues) || opType === OpType.INSERT)) return [3 /*break*/, 7];\n            return [4 /*yield*/, this.db.save(item, storeName_1, keys, itemKeyValues.join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR))];\n          case 6:\n            _c.sent();\n            result.push([instance, opType]);\n            _c.label = 7;\n          case 7:\n            return [3 /*break*/, 3];\n          case 8:\n            return [3 /*break*/, 15];\n          case 9:\n            e_2_1 = _c.sent();\n            e_2 = {\n              error: e_2_1\n            };\n            return [3 /*break*/, 15];\n          case 10:\n            _c.trys.push([10,, 13, 14]);\n            if (!(connectionStoreNames_1_1 && !connectionStoreNames_1_1.done && (_a = connectionStoreNames_1.return))) return [3 /*break*/, 12];\n            return [4 /*yield*/, _a.call(connectionStoreNames_1)];\n          case 11:\n            _c.sent();\n            _c.label = 12;\n          case 12:\n            return [3 /*break*/, 14];\n          case 13:\n            if (e_2) throw e_2.error;\n            return [7 /*endfinally*/];\n          case 14:\n            return [7 /*endfinally*/];\n          case 15:\n            return [2 /*return*/, result];\n        }\n      });\n    });\n  };\n  AsyncStorageAdapter.prototype.query = function (modelConstructor, predicate, pagination) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, storeName, namespaceName, queryByKey, predicates, hasSort, hasPagination, records;\n      var _this = this;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = this.queryMetadata(modelConstructor, predicate, pagination), storeName = _a.storeName, namespaceName = _a.namespaceName, queryByKey = _a.queryByKey, predicates = _a.predicates, hasSort = _a.hasSort, hasPagination = _a.hasPagination;\n            return [4 /*yield*/, function () {\n              return __awaiter(_this, void 0, void 0, function () {\n                var keyValues, record, filtered, all;\n                return __generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      if (!queryByKey) return [3 /*break*/, 2];\n                      keyValues = queryByKey.join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR);\n                      return [4 /*yield*/, this.getByKey(storeName, keyValues)];\n                    case 1:\n                      record = _a.sent();\n                      return [2 /*return*/, record ? [record] : []];\n                    case 2:\n                      if (!predicates) return [3 /*break*/, 4];\n                      return [4 /*yield*/, this.filterOnPredicate(storeName, predicates)];\n                    case 3:\n                      filtered = _a.sent();\n                      return [2 /*return*/, this.inMemoryPagination(filtered, pagination)];\n                    case 4:\n                      if (!(hasSort || hasPagination)) return [3 /*break*/, 6];\n                      return [4 /*yield*/, this.getAll(storeName)];\n                    case 5:\n                      all = _a.sent();\n                      return [2 /*return*/, this.inMemoryPagination(all, pagination)];\n                    case 6:\n                      return [2 /*return*/, this.getAll(storeName)];\n                  }\n                });\n              });\n            }()];\n          case 1:\n            records = _b.sent();\n            return [4 /*yield*/, this.load(namespaceName, modelConstructor.name, records)];\n          case 2:\n            return [2 /*return*/, _b.sent()];\n        }\n      });\n    });\n  };\n  AsyncStorageAdapter.prototype.getByKey = function (storeName, keyValuePath) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.db.get(keyValuePath, storeName)];\n          case 1:\n            return [2 /*return*/, _a.sent()];\n        }\n      });\n    });\n  };\n  AsyncStorageAdapter.prototype.getAll = function (storeName) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.db.getAll(storeName)];\n          case 1:\n            return [2 /*return*/, _a.sent()];\n        }\n      });\n    });\n  };\n  AsyncStorageAdapter.prototype.filterOnPredicate = function (storeName, predicates) {\n    return __awaiter(this, void 0, void 0, function () {\n      var predicateObjs, type, all, filtered;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            predicateObjs = predicates.predicates, type = predicates.type;\n            return [4 /*yield*/, this.getAll(storeName)];\n          case 1:\n            all = _a.sent();\n            filtered = predicateObjs ? all.filter(function (m) {\n              return validatePredicate(m, type, predicateObjs);\n            }) : all;\n            return [2 /*return*/, filtered];\n        }\n      });\n    });\n  };\n  AsyncStorageAdapter.prototype.inMemoryPagination = function (records, pagination) {\n    return inMemoryPagination(records, pagination);\n  };\n  AsyncStorageAdapter.prototype.queryOne = function (modelConstructor, firstOrLast) {\n    if (firstOrLast === void 0) {\n      firstOrLast = QueryOne.FIRST;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var storeName, result;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            storeName = this.getStorenameForModel(modelConstructor);\n            return [4 /*yield*/, this.db.getOne(firstOrLast, storeName)];\n          case 1:\n            result = _a.sent();\n            return [2 /*return*/, result && this.modelInstanceCreator(modelConstructor, result)];\n        }\n      });\n    });\n  };\n  AsyncStorageAdapter.prototype.deleteItem = function (deleteQueue) {\n    var e_3, _a, e_4, _b;\n    return __awaiter(this, void 0, void 0, function () {\n      var _c, _d, deleteItem, storeName, items, items_2, items_2_1, item, keyValuesPath, e_4_1, e_3_1;\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            _e.trys.push([0, 17, 18, 23]);\n            _c = __asyncValues(deleteQueue);\n            _e.label = 1;\n          case 1:\n            return [4 /*yield*/, _c.next()];\n          case 2:\n            if (!(_d = _e.sent(), !_d.done)) return [3 /*break*/, 16];\n            deleteItem = _d.value;\n            storeName = deleteItem.storeName, items = deleteItem.items;\n            _e.label = 3;\n          case 3:\n            _e.trys.push([3, 9, 10, 15]);\n            items_2 = __asyncValues(items);\n            _e.label = 4;\n          case 4:\n            return [4 /*yield*/, items_2.next()];\n          case 5:\n            if (!(items_2_1 = _e.sent(), !items_2_1.done)) return [3 /*break*/, 8];\n            item = items_2_1.value;\n            if (!item) return [3 /*break*/, 7];\n            if (!(typeof item === 'object')) return [3 /*break*/, 7];\n            keyValuesPath = this.getIndexKeyValuesPath(item);\n            return [4 /*yield*/, this.db.delete(keyValuesPath, storeName)];\n          case 6:\n            _e.sent();\n            _e.label = 7;\n          case 7:\n            return [3 /*break*/, 4];\n          case 8:\n            return [3 /*break*/, 15];\n          case 9:\n            e_4_1 = _e.sent();\n            e_4 = {\n              error: e_4_1\n            };\n            return [3 /*break*/, 15];\n          case 10:\n            _e.trys.push([10,, 13, 14]);\n            if (!(items_2_1 && !items_2_1.done && (_b = items_2.return))) return [3 /*break*/, 12];\n            return [4 /*yield*/, _b.call(items_2)];\n          case 11:\n            _e.sent();\n            _e.label = 12;\n          case 12:\n            return [3 /*break*/, 14];\n          case 13:\n            if (e_4) throw e_4.error;\n            return [7 /*endfinally*/];\n          case 14:\n            return [7 /*endfinally*/];\n          case 15:\n            return [3 /*break*/, 1];\n          case 16:\n            return [3 /*break*/, 23];\n          case 17:\n            e_3_1 = _e.sent();\n            e_3 = {\n              error: e_3_1\n            };\n            return [3 /*break*/, 23];\n          case 18:\n            _e.trys.push([18,, 21, 22]);\n            if (!(_d && !_d.done && (_a = _c.return))) return [3 /*break*/, 20];\n            return [4 /*yield*/, _a.call(_c)];\n          case 19:\n            _e.sent();\n            _e.label = 20;\n          case 20:\n            return [3 /*break*/, 22];\n          case 21:\n            if (e_3) throw e_3.error;\n            return [7 /*endfinally*/];\n          case 22:\n            return [7 /*endfinally*/];\n          case 23:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  //#region platform-specific helper methods\n  /**\n   * Retrieves concatenated primary key values from a model\n   *\n   * @param model\n   * @returns\n   */\n  AsyncStorageAdapter.prototype.getIndexKeyValuesPath = function (model) {\n    return this.getIndexKeyValuesFromModel(model).join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR);\n  };\n  return AsyncStorageAdapter;\n}(StorageAdapterBase);\nexport { AsyncStorageAdapter };\nexport default new AsyncStorageAdapter();","map":{"version":3,"names":["AsyncStorageDatabase","OpType","QueryOne","DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR","traverseModel","validatePredicate","inMemoryPagination","keysEqual","getStorename","getIndexKeys","StorageAdapterBase","AsyncStorageAdapter","_super","__extends","prototype","preSetUpChecks","preOpCheck","initDb","db","init","_a","sent","clear","undefined","initPromise","batchSave","modelConstructor","items","length","modelName","name","namespaceName","namespaceResolver","storeName","keys","schema","namespaces","batch","item","model","this_1","modelInstanceCreator","connectedModels","getModelConstructorByModelName","keyValuesPath","getIndexKeyValuesPath","instance","find","push","items_1","__values","items_1_1","next","done","value","_b","_get","keyArr","itemKeyValuesPath","join","get","save","condition","saveMetadata","connectionStoreNames","modelKeyValues","fromDB","_c","validateSaveCondition","result","connectionStoreNames_1","__asyncValues","resItem","connectionStoreNames_1_1","storeName_1","itemKeyValues","map","key","fromDB_1","opType","UPDATE","INSERT","query","predicate","pagination","queryMetadata","queryByKey","predicates","hasSort","hasPagination","__awaiter","_this","keyValues","getByKey","record","filterOnPredicate","filtered","getAll","all","records","load","keyValuePath","predicateObjs","type","filter","m","queryOne","firstOrLast","FIRST","getStorenameForModel","getOne","deleteItem","deleteQueue","_d","items_2","items_2_1","delete","_e","getIndexKeyValuesFromModel"],"sources":["/Users/yannellym/Desktop/iwantapet/node_modules/@aws-amplify/datastore/src/storage/adapter/AsyncStorageAdapter.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport AsyncStorageDatabase from './AsyncStorageDatabase';\nimport {\n\tModelInstanceMetadata,\n\tModelPredicate,\n\tOpType,\n\tPaginationInput,\n\tPersistentModel,\n\tPersistentModelConstructor,\n\tPredicatesGroup,\n\tQueryOne,\n} from '../../types';\nimport {\n\tDEFAULT_PRIMARY_KEY_VALUE_SEPARATOR,\n\ttraverseModel,\n\tvalidatePredicate,\n\tinMemoryPagination,\n\tkeysEqual,\n\tgetStorename,\n\tgetIndexKeys,\n} from '../../util';\nimport { StorageAdapterBase } from './StorageAdapterBase';\n\nexport class AsyncStorageAdapter extends StorageAdapterBase {\n\tprotected db!: AsyncStorageDatabase;\n\n\t// no-ops for this adapter\n\tprotected async preSetUpChecks() {}\n\tprotected async preOpCheck() {}\n\n\t/**\n\t * Open AsyncStorage database\n\t * Create new DB if one doesn't exist\n\t *\n\t * Called by `StorageAdapterBase.setUp()`\n\t *\n\t * @returns AsyncStorageDatabase instance\n\t */\n\tprotected async initDb(): Promise<AsyncStorageDatabase> {\n\t\tconst db = new AsyncStorageDatabase();\n\t\tawait db.init();\n\t\treturn db;\n\t}\n\n\tasync clear(): Promise<void> {\n\t\tawait this.db.clear();\n\n\t\tthis.db = undefined!;\n\t\tthis.initPromise = undefined!;\n\t}\n\n\tasync batchSave<T extends PersistentModel>(\n\t\tmodelConstructor: PersistentModelConstructor<any>,\n\t\titems: ModelInstanceMetadata[]\n\t): Promise<[T, OpType][]> {\n\t\tif (items.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst modelName = modelConstructor.name;\n\t\tconst namespaceName = this.namespaceResolver(modelConstructor);\n\t\tconst storeName = getStorename(namespaceName, modelName);\n\t\tconst keys = getIndexKeys(this.schema.namespaces[namespaceName], modelName);\n\t\tconst batch: ModelInstanceMetadata[] = [];\n\n\t\tfor (const item of items) {\n\t\t\tconst model = this.modelInstanceCreator(modelConstructor, item);\n\n\t\t\tconst connectedModels = traverseModel(\n\t\t\t\tmodelName,\n\t\t\t\tmodel,\n\t\t\t\tthis.schema.namespaces[namespaceName],\n\t\t\t\tthis.modelInstanceCreator,\n\t\t\t\tthis.getModelConstructorByModelName\n\t\t\t);\n\n\t\t\tconst keyValuesPath = this.getIndexKeyValuesPath(model);\n\n\t\t\tconst { instance } = connectedModels.find(({ instance }) => {\n\t\t\t\tconst instanceKeyValuesPath = this.getIndexKeyValuesPath(instance);\n\t\t\t\treturn keysEqual([instanceKeyValuesPath], [keyValuesPath]);\n\t\t\t})!;\n\n\t\t\tbatch.push(instance);\n\t\t}\n\n\t\treturn await this.db.batchSave(storeName, batch, keys);\n\t}\n\n\tprotected async _get<T>(storeName: string, keyArr: string[]): Promise<T> {\n\t\tconst itemKeyValuesPath: string = keyArr.join(\n\t\t\tDEFAULT_PRIMARY_KEY_VALUE_SEPARATOR\n\t\t);\n\n\t\treturn <T>await this.db.get(itemKeyValuesPath, storeName);\n\t}\n\n\tasync save<T extends PersistentModel>(\n\t\tmodel: T,\n\t\tcondition?: ModelPredicate<T>\n\t): Promise<[T, OpType.INSERT | OpType.UPDATE][]> {\n\t\tconst { storeName, connectionStoreNames, modelKeyValues } =\n\t\t\tthis.saveMetadata(model);\n\n\t\tconst fromDB = await this._get(storeName, modelKeyValues);\n\n\t\tthis.validateSaveCondition(condition, fromDB);\n\n\t\tconst result: [T, OpType.INSERT | OpType.UPDATE][] = [];\n\t\tfor await (const resItem of connectionStoreNames) {\n\t\t\tconst { storeName, item, instance, keys } = resItem;\n\n\t\t\tconst itemKeyValues: string[] = keys.map(key => item[key]);\n\n\t\t\tconst fromDB = <T>await this._get(storeName, itemKeyValues);\n\t\t\tconst opType: OpType = fromDB ? OpType.UPDATE : OpType.INSERT;\n\n\t\t\tif (\n\t\t\t\tkeysEqual(itemKeyValues, modelKeyValues) ||\n\t\t\t\topType === OpType.INSERT\n\t\t\t) {\n\t\t\t\tawait this.db.save(\n\t\t\t\t\titem,\n\t\t\t\t\tstoreName,\n\t\t\t\t\tkeys,\n\t\t\t\t\titemKeyValues.join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR)\n\t\t\t\t);\n\n\t\t\t\tresult.push([instance, opType]);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tasync query<T extends PersistentModel>(\n\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\tpredicate?: ModelPredicate<T>,\n\t\tpagination?: PaginationInput<T>\n\t): Promise<T[]> {\n\t\tconst {\n\t\t\tstoreName,\n\t\t\tnamespaceName,\n\t\t\tqueryByKey,\n\t\t\tpredicates,\n\t\t\thasSort,\n\t\t\thasPagination,\n\t\t} = this.queryMetadata(modelConstructor, predicate, pagination);\n\n\t\tconst records: T[] = (await (async () => {\n\t\t\tif (queryByKey) {\n\t\t\t\tconst keyValues = queryByKey.join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR);\n\t\t\t\tconst record = await this.getByKey(storeName, keyValues);\n\t\t\t\treturn record ? [record] : [];\n\t\t\t}\n\n\t\t\tif (predicates) {\n\t\t\t\tconst filtered = await this.filterOnPredicate(storeName, predicates);\n\t\t\t\treturn this.inMemoryPagination(filtered, pagination);\n\t\t\t}\n\n\t\t\tif (hasSort || hasPagination) {\n\t\t\t\tconst all = await this.getAll(storeName);\n\t\t\t\treturn this.inMemoryPagination(all, pagination);\n\t\t\t}\n\n\t\t\treturn this.getAll(storeName);\n\t\t})()) as T[];\n\n\t\treturn await this.load(namespaceName, modelConstructor.name, records);\n\t}\n\n\tprivate async getByKey<T extends PersistentModel>(\n\t\tstoreName: string,\n\t\tkeyValuePath: string\n\t): Promise<T> {\n\t\treturn <T>await this.db.get(keyValuePath, storeName);\n\t}\n\n\tprivate async getAll<T extends PersistentModel>(\n\t\tstoreName: string\n\t): Promise<T[]> {\n\t\treturn await this.db.getAll(storeName);\n\t}\n\n\tprivate async filterOnPredicate<T extends PersistentModel>(\n\t\tstoreName: string,\n\t\tpredicates: PredicatesGroup<T>\n\t) {\n\t\tconst { predicates: predicateObjs, type } = predicates;\n\n\t\tconst all = <T[]>await this.getAll(storeName);\n\n\t\tconst filtered = predicateObjs\n\t\t\t? all.filter(m => validatePredicate(m, type, predicateObjs))\n\t\t\t: all;\n\n\t\treturn filtered;\n\t}\n\n\tprivate inMemoryPagination<T extends PersistentModel>(\n\t\trecords: T[],\n\t\tpagination?: PaginationInput<T>\n\t): T[] {\n\t\treturn inMemoryPagination(records, pagination);\n\t}\n\n\tasync queryOne<T extends PersistentModel>(\n\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\tfirstOrLast: QueryOne = QueryOne.FIRST\n\t): Promise<T | undefined> {\n\t\tconst storeName = this.getStorenameForModel(modelConstructor);\n\t\tconst result = <T>await this.db.getOne(firstOrLast, storeName);\n\n\t\treturn result && this.modelInstanceCreator(modelConstructor, result);\n\t}\n\n\tprotected async deleteItem<T extends PersistentModel>(\n\t\tdeleteQueue?: { storeName: string; items: T[] | IDBValidKey[] }[]\n\t) {\n\t\tfor await (const deleteItem of deleteQueue!) {\n\t\t\tconst { storeName, items } = deleteItem;\n\n\t\t\tfor await (const item of items) {\n\t\t\t\tif (item) {\n\t\t\t\t\tif (typeof item === 'object') {\n\t\t\t\t\t\tconst keyValuesPath: string = this.getIndexKeyValuesPath(item as T);\n\t\t\t\t\t\tawait this.db.delete(keyValuesPath, storeName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//#region platform-specific helper methods\n\n\t/**\n\t * Retrieves concatenated primary key values from a model\n\t *\n\t * @param model\n\t * @returns\n\t */\n\tprivate getIndexKeyValuesPath<T extends PersistentModel>(model: T): string {\n\t\treturn this.getIndexKeyValuesFromModel(model).join(\n\t\t\tDEFAULT_PRIMARY_KEY_VALUE_SEPARATOR\n\t\t);\n\t}\n\n\t//#endregion\n}\n\nexport default new AsyncStorageAdapter();\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}