{"ast":null,"code":"var alphabetByEncoding = {};\nvar alphabetByValue = new Array(64);\nfor (var i = 0, start = \"A\".charCodeAt(0), limit = \"Z\".charCodeAt(0); i + start <= limit; i++) {\n  var char = String.fromCharCode(i + start);\n  alphabetByEncoding[char] = i;\n  alphabetByValue[i] = char;\n}\nfor (var i = 0, start = \"a\".charCodeAt(0), limit = \"z\".charCodeAt(0); i + start <= limit; i++) {\n  var char = String.fromCharCode(i + start);\n  var index = i + 26;\n  alphabetByEncoding[char] = index;\n  alphabetByValue[index] = char;\n}\nfor (var i = 0; i < 10; i++) {\n  alphabetByEncoding[i.toString(10)] = i + 52;\n  var char = i.toString(10);\n  var index = i + 52;\n  alphabetByEncoding[char] = index;\n  alphabetByValue[index] = char;\n}\nalphabetByEncoding[\"+\"] = 62;\nalphabetByValue[62] = \"+\";\nalphabetByEncoding[\"/\"] = 63;\nalphabetByValue[63] = \"/\";\nvar bitsPerLetter = 6;\nvar bitsPerByte = 8;\nvar maxLetterValue = 63;\n/**\n * Converts a base-64 encoded string to a Uint8Array of bytes.\n *\n * @param input The base-64 encoded string\n *\n * @see https://tools.ietf.org/html/rfc4648#section-4\n */\nexport function fromBase64(input) {\n  var totalByteLength = input.length / 4 * 3;\n  if (input.substr(-2) === \"==\") {\n    totalByteLength -= 2;\n  } else if (input.substr(-1) === \"=\") {\n    totalByteLength--;\n  }\n  var out = new ArrayBuffer(totalByteLength);\n  var dataView = new DataView(out);\n  for (var i = 0; i < input.length; i += 4) {\n    var bits = 0;\n    var bitLength = 0;\n    for (var j = i, limit = i + 3; j <= limit; j++) {\n      if (input[j] !== \"=\") {\n        bits |= alphabetByEncoding[input[j]] << (limit - j) * bitsPerLetter;\n        bitLength += bitsPerLetter;\n      } else {\n        bits >>= bitsPerLetter;\n      }\n    }\n    var chunkOffset = i / 4 * 3;\n    bits >>= bitLength % bitsPerByte;\n    var byteLength = Math.floor(bitLength / bitsPerByte);\n    for (var k = 0; k < byteLength; k++) {\n      var offset = (byteLength - k - 1) * bitsPerByte;\n      dataView.setUint8(chunkOffset + k, (bits & 255 << offset) >> offset);\n    }\n  }\n  return new Uint8Array(out);\n}\n/**\n * Converts a Uint8Array of binary data to a base-64 encoded string.\n *\n * @param input The binary data to encode\n *\n * @see https://tools.ietf.org/html/rfc4648#section-4\n */\nexport function toBase64(input) {\n  var str = \"\";\n  for (var i = 0; i < input.length; i += 3) {\n    var bits = 0;\n    var bitLength = 0;\n    for (var j = i, limit = Math.min(i + 3, input.length); j < limit; j++) {\n      bits |= input[j] << (limit - j - 1) * bitsPerByte;\n      bitLength += bitsPerByte;\n    }\n    var bitClusterCount = Math.ceil(bitLength / bitsPerLetter);\n    bits <<= bitClusterCount * bitsPerLetter - bitLength;\n    for (var k = 1; k <= bitClusterCount; k++) {\n      var offset = (bitClusterCount - k) * bitsPerLetter;\n      str += alphabetByValue[(bits & maxLetterValue << offset) >> offset];\n    }\n    str += \"==\".slice(0, 4 - bitClusterCount);\n  }\n  return str;\n}","map":{"version":3,"names":["alphabetByEncoding","alphabetByValue","Array","i","start","charCodeAt","limit","char","String","fromCharCode","index","toString","bitsPerLetter","bitsPerByte","maxLetterValue","fromBase64","input","totalByteLength","length","substr","out","ArrayBuffer","dataView","DataView","bits","bitLength","j","chunkOffset","byteLength","Math","floor","k","offset","setUint8","Uint8Array","toBase64","str","min","bitClusterCount","ceil","slice"],"sources":["/Users/yannellym/Desktop/iwantapet/node_modules/@aws-sdk/util-base64-browser/src/index.ts"],"sourcesContent":["const alphabetByEncoding: { [key: string]: number } = {};\nconst alphabetByValue: Array<string> = new Array(64);\n\nfor (let i = 0, start = \"A\".charCodeAt(0), limit = \"Z\".charCodeAt(0); i + start <= limit; i++) {\n  const char = String.fromCharCode(i + start);\n  alphabetByEncoding[char] = i;\n  alphabetByValue[i] = char;\n}\n\nfor (let i = 0, start = \"a\".charCodeAt(0), limit = \"z\".charCodeAt(0); i + start <= limit; i++) {\n  const char = String.fromCharCode(i + start);\n  const index = i + 26;\n  alphabetByEncoding[char] = index;\n  alphabetByValue[index] = char;\n}\n\nfor (let i = 0; i < 10; i++) {\n  alphabetByEncoding[i.toString(10)] = i + 52;\n  const char = i.toString(10);\n  const index = i + 52;\n  alphabetByEncoding[char] = index;\n  alphabetByValue[index] = char;\n}\n\nalphabetByEncoding[\"+\"] = 62;\nalphabetByValue[62] = \"+\";\nalphabetByEncoding[\"/\"] = 63;\nalphabetByValue[63] = \"/\";\n\nconst bitsPerLetter = 6;\nconst bitsPerByte = 8;\nconst maxLetterValue = 0b111111;\n\n/**\n * Converts a base-64 encoded string to a Uint8Array of bytes.\n *\n * @param input The base-64 encoded string\n *\n * @see https://tools.ietf.org/html/rfc4648#section-4\n */\nexport function fromBase64(input: string): Uint8Array {\n  let totalByteLength = (input.length / 4) * 3;\n  if (input.substr(-2) === \"==\") {\n    totalByteLength -= 2;\n  } else if (input.substr(-1) === \"=\") {\n    totalByteLength--;\n  }\n  const out = new ArrayBuffer(totalByteLength);\n  const dataView = new DataView(out);\n  for (let i = 0; i < input.length; i += 4) {\n    let bits = 0;\n    let bitLength = 0;\n    for (let j = i, limit = i + 3; j <= limit; j++) {\n      if (input[j] !== \"=\") {\n        bits |= alphabetByEncoding[input[j]] << ((limit - j) * bitsPerLetter);\n        bitLength += bitsPerLetter;\n      } else {\n        bits >>= bitsPerLetter;\n      }\n    }\n\n    const chunkOffset = (i / 4) * 3;\n    bits >>= bitLength % bitsPerByte;\n    const byteLength = Math.floor(bitLength / bitsPerByte);\n    for (let k = 0; k < byteLength; k++) {\n      const offset = (byteLength - k - 1) * bitsPerByte;\n      dataView.setUint8(chunkOffset + k, (bits & (255 << offset)) >> offset);\n    }\n  }\n\n  return new Uint8Array(out);\n}\n\n/**\n * Converts a Uint8Array of binary data to a base-64 encoded string.\n *\n * @param input The binary data to encode\n *\n * @see https://tools.ietf.org/html/rfc4648#section-4\n */\nexport function toBase64(input: Uint8Array): string {\n  let str = \"\";\n  for (let i = 0; i < input.length; i += 3) {\n    let bits = 0;\n    let bitLength = 0;\n    for (let j = i, limit = Math.min(i + 3, input.length); j < limit; j++) {\n      bits |= input[j] << ((limit - j - 1) * bitsPerByte);\n      bitLength += bitsPerByte;\n    }\n\n    const bitClusterCount = Math.ceil(bitLength / bitsPerLetter);\n    bits <<= bitClusterCount * bitsPerLetter - bitLength;\n    for (let k = 1; k <= bitClusterCount; k++) {\n      const offset = (bitClusterCount - k) * bitsPerLetter;\n      str += alphabetByValue[(bits & (maxLetterValue << offset)) >> offset];\n    }\n\n    str += \"==\".slice(0, 4 - bitClusterCount);\n  }\n\n  return str;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}