{"ast":null,"code":"import { __read, __spread, __values } from \"tslib\";\nvar connectionTimeout = function (error) {\n  return /^Connection failed: Connection Timeout/.test(error.message);\n};\nvar serverError = function (error) {\n  return /^Error: Request failed with status code 5\\d\\d/.test(error.message);\n};\nexport var mutationErrorMap = {\n  BadModel: function () {\n    return false;\n  },\n  BadRecord: function (error) {\n    var message = error.message;\n    return /^Cannot return \\w+ for [\\w-_]+ type/.test(message) || /^Variable '.+' has coerced Null value for NonNull type/.test(message); // newly required field, out of date client\n  },\n\n  ConfigError: function () {\n    return false;\n  },\n  Transient: function (error) {\n    return connectionTimeout(error) || serverError(error);\n  },\n  Unauthorized: function (error) {\n    return error.message === 'Unauthorized' || /^Request failed with status code 401/.test(error.message);\n  }\n};\nexport var subscriptionErrorMap = {\n  BadModel: function () {\n    return false;\n  },\n  BadRecord: function () {\n    return false;\n  },\n  ConfigError: function () {\n    return false;\n  },\n  Transient: function (observableError) {\n    var error = unwrapObservableError(observableError);\n    return connectionTimeout(error) || serverError(error);\n  },\n  Unauthorized: function (observableError) {\n    var error = unwrapObservableError(observableError);\n    return /Connection failed.+Unauthorized/.test(error.message);\n  }\n};\nexport var syncErrorMap = {\n  BadModel: function () {\n    return false;\n  },\n  BadRecord: function (error) {\n    return /^Cannot return \\w+ for [\\w-_]+ type/.test(error.message);\n  },\n  ConfigError: function () {\n    return false;\n  },\n  Transient: function (error) {\n    return connectionTimeout(error) || serverError(error);\n  },\n  Unauthorized: function (error) {\n    return error.errorType === 'Unauthorized';\n  }\n};\n/**\n * Get the first error reason of an observable.\n * Allows for error maps to be easily applied to observable errors\n *\n * @param observableError an error from ZenObservable subscribe error callback\n */\nfunction unwrapObservableError(observableError) {\n  var _a = observableError.error,\n    _b = __read((_a === void 0 ? {\n      errors: []\n    } : _a).errors, 1),\n    error = _b[0];\n  return error;\n}\nexport function getMutationErrorType(error) {\n  return mapErrorToType(mutationErrorMap, error);\n}\nexport function getSubscriptionErrorType(error) {\n  return mapErrorToType(subscriptionErrorMap, error);\n}\nexport function getSyncErrorType(error) {\n  return mapErrorToType(syncErrorMap, error);\n}\n/**\n * Categorizes an error with a broad error type, intended to make\n * customer error handling code simpler.\n * @param errorMap Error names and a list of patterns that indicate them (each pattern as a regex or function)\n * @param error The underying error to categorize.\n */\nexport function mapErrorToType(errorMap, error) {\n  var e_1, _a;\n  var errorTypes = __spread(Object.keys(errorMap));\n  try {\n    for (var errorTypes_1 = __values(errorTypes), errorTypes_1_1 = errorTypes_1.next(); !errorTypes_1_1.done; errorTypes_1_1 = errorTypes_1.next()) {\n      var errorType = errorTypes_1_1.value;\n      var matcher = errorMap[errorType];\n      if (matcher === null || matcher === void 0 ? void 0 : matcher(error)) {\n        return errorType;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (errorTypes_1_1 && !errorTypes_1_1.done && (_a = errorTypes_1.return)) _a.call(errorTypes_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n  return 'Unknown';\n}","map":{"version":3,"names":["connectionTimeout","error","test","message","serverError","mutationErrorMap","BadModel","BadRecord","ConfigError","Transient","Unauthorized","subscriptionErrorMap","observableError","unwrapObservableError","syncErrorMap","errorType","_a","_b","__read","getMutationErrorType","mapErrorToType","getSubscriptionErrorType","getSyncErrorType","errorMap","errorTypes","__spread","Object","keys","errorTypes_1","__values","errorTypes_1_1","next","done","value","matcher"],"sources":["/Users/yannellym/Desktop/iwantapet/node_modules/@aws-amplify/datastore/src/sync/processors/errorMaps.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ErrorType } from '../../types';\n\nexport type ErrorMap = Partial<{\n\t[key in ErrorType]: (error: Error) => boolean;\n}>;\n\nconst connectionTimeout = error =>\n\t/^Connection failed: Connection Timeout/.test(error.message);\n\nconst serverError = error =>\n\t/^Error: Request failed with status code 5\\d\\d/.test(error.message);\n\nexport const mutationErrorMap: ErrorMap = {\n\tBadModel: () => false,\n\tBadRecord: error => {\n\t\tconst { message } = error;\n\t\treturn (\n\t\t\t/^Cannot return \\w+ for [\\w-_]+ type/.test(message) ||\n\t\t\t/^Variable '.+' has coerced Null value for NonNull type/.test(message)\n\t\t); // newly required field, out of date client\n\t},\n\tConfigError: () => false,\n\tTransient: error => connectionTimeout(error) || serverError(error),\n\tUnauthorized: error =>\n\t\terror.message === 'Unauthorized' ||\n\t\t/^Request failed with status code 401/.test(error.message),\n};\n\nexport const subscriptionErrorMap: ErrorMap = {\n\tBadModel: () => false,\n\tBadRecord: () => false,\n\tConfigError: () => false,\n\tTransient: observableError => {\n\t\tconst error = unwrapObservableError(observableError);\n\t\treturn connectionTimeout(error) || serverError(error);\n\t},\n\tUnauthorized: observableError => {\n\t\tconst error = unwrapObservableError(observableError);\n\t\treturn /Connection failed.+Unauthorized/.test(error.message);\n\t},\n};\n\nexport const syncErrorMap: ErrorMap = {\n\tBadModel: () => false,\n\tBadRecord: error => /^Cannot return \\w+ for [\\w-_]+ type/.test(error.message),\n\tConfigError: () => false,\n\tTransient: error => connectionTimeout(error) || serverError(error),\n\tUnauthorized: error => (error as any).errorType === 'Unauthorized',\n};\n\n/**\n * Get the first error reason of an observable.\n * Allows for error maps to be easily applied to observable errors\n *\n * @param observableError an error from ZenObservable subscribe error callback\n */\nfunction unwrapObservableError(observableError: any) {\n\tconst {\n\t\terror: { errors: [error] } = {\n\t\t\terrors: [],\n\t\t},\n\t} = observableError;\n\n\treturn error;\n}\n\nexport function getMutationErrorType(error: Error): ErrorType {\n\treturn mapErrorToType(mutationErrorMap, error);\n}\n\nexport function getSubscriptionErrorType(error: Error): ErrorType {\n\treturn mapErrorToType(subscriptionErrorMap, error);\n}\n\nexport function getSyncErrorType(error: Error): ErrorType {\n\treturn mapErrorToType(syncErrorMap, error);\n}\n\n/**\n * Categorizes an error with a broad error type, intended to make\n * customer error handling code simpler.\n * @param errorMap Error names and a list of patterns that indicate them (each pattern as a regex or function)\n * @param error The underying error to categorize.\n */\nexport function mapErrorToType(errorMap: ErrorMap, error: Error): ErrorType {\n\tconst errorTypes = [...Object.keys(errorMap)] as ErrorType[];\n\tfor (const errorType of errorTypes) {\n\t\tconst matcher = errorMap[errorType];\n\t\tif (matcher?.(error)) {\n\t\t\treturn errorType;\n\t\t}\n\t}\n\treturn 'Unknown';\n}\n"],"mappings":";AAQA,IAAMA,iBAAiB,GAAG,SAAAA,CAAAC,KAAK;EAC9B,+CAAwC,CAACC,IAAI,CAACD,KAAK,CAACE,OAAO,CAAC;AAA5D,CAA4D;AAE7D,IAAMC,WAAW,GAAG,SAAAA,CAAAH,KAAK;EACxB,sDAA+C,CAACC,IAAI,CAACD,KAAK,CAACE,OAAO,CAAC;AAAnE,CAAmE;AAEpE,OAAO,IAAME,gBAAgB,GAAa;EACzCC,QAAQ,EAAE,SAAAA,CAAA;IAAM,YAAK;EAAL,CAAK;EACrBC,SAAS,EAAE,SAAAA,CAAAN,KAAK;IACP,IAAAE,OAAA,GAAAF,KAAA,CAAAE,OAAO;IACf,OACC,qCAAqC,CAACD,IAAI,CAACC,OAAO,CAAC,IACnD,wDAAwD,CAACD,IAAI,CAACC,OAAO,CAAC,CACrE,CAAC;EACJ,CAAC;;EACDK,WAAW,EAAE,SAAAA,CAAA;IAAM,YAAK;EAAL,CAAK;EACxBC,SAAS,EAAE,SAAAA,CAAAR,KAAK;IAAI,OAAAD,iBAAiB,CAACC,KAAK,CAAC,IAAIG,WAAW,CAACH,KAAK,CAAC;EAA9C,CAA8C;EAClES,YAAY,EAAE,SAAAA,CAAAT,KAAK;IAClB,OAAAA,KAAK,CAACE,OAAO,KAAK,cAAc,IAChC,sCAAsC,CAACD,IAAI,CAACD,KAAK,CAACE,OAAO,CAAC;EAD1D;CAED;AAED,OAAO,IAAMQ,oBAAoB,GAAa;EAC7CL,QAAQ,EAAE,SAAAA,CAAA;IAAM,YAAK;EAAL,CAAK;EACrBC,SAAS,EAAE,SAAAA,CAAA;IAAM,YAAK;EAAL,CAAK;EACtBC,WAAW,EAAE,SAAAA,CAAA;IAAM,YAAK;EAAL,CAAK;EACxBC,SAAS,EAAE,SAAAA,CAAAG,eAAe;IACzB,IAAMX,KAAK,GAAGY,qBAAqB,CAACD,eAAe,CAAC;IACpD,OAAOZ,iBAAiB,CAACC,KAAK,CAAC,IAAIG,WAAW,CAACH,KAAK,CAAC;EACtD,CAAC;EACDS,YAAY,EAAE,SAAAA,CAAAE,eAAe;IAC5B,IAAMX,KAAK,GAAGY,qBAAqB,CAACD,eAAe,CAAC;IACpD,OAAO,iCAAiC,CAACV,IAAI,CAACD,KAAK,CAACE,OAAO,CAAC;EAC7D;CACA;AAED,OAAO,IAAMW,YAAY,GAAa;EACrCR,QAAQ,EAAE,SAAAA,CAAA;IAAM,YAAK;EAAL,CAAK;EACrBC,SAAS,EAAE,SAAAA,CAAAN,KAAK;IAAI,4CAAqC,CAACC,IAAI,CAACD,KAAK,CAACE,OAAO,CAAC;EAAzD,CAAyD;EAC7EK,WAAW,EAAE,SAAAA,CAAA;IAAM,YAAK;EAAL,CAAK;EACxBC,SAAS,EAAE,SAAAA,CAAAR,KAAK;IAAI,OAAAD,iBAAiB,CAACC,KAAK,CAAC,IAAIG,WAAW,CAACH,KAAK,CAAC;EAA9C,CAA8C;EAClES,YAAY,EAAE,SAAAA,CAAAT,KAAK;IAAI,OAACA,KAAa,CAACc,SAAS,KAAK,cAAc;EAA3C;CACvB;AAED;;;;;;AAMA,SAASF,qBAAqBA,CAACD,eAAoB;EAEjD,IAAAI,EAAA,GAAAJ,eAAA,CAAAX,KAEC;IAFQgB,EAAA,GAAAC,MAAA,EAAAF,EAAA;;sBAAe;IAANf,KAAA,GAAAgB,EAAA,GAEjB;EAGF,OAAOhB,KAAK;AACb;AAEA,OAAM,SAAUkB,oBAAoBA,CAAClB,KAAY;EAChD,OAAOmB,cAAc,CAACf,gBAAgB,EAAEJ,KAAK,CAAC;AAC/C;AAEA,OAAM,SAAUoB,wBAAwBA,CAACpB,KAAY;EACpD,OAAOmB,cAAc,CAACT,oBAAoB,EAAEV,KAAK,CAAC;AACnD;AAEA,OAAM,SAAUqB,gBAAgBA,CAACrB,KAAY;EAC5C,OAAOmB,cAAc,CAACN,YAAY,EAAEb,KAAK,CAAC;AAC3C;AAEA;;;;;;AAMA,OAAM,SAAUmB,cAAcA,CAACG,QAAkB,EAAEtB,KAAY;;EAC9D,IAAMuB,UAAU,GAAGC,QAAA,CAAIC,MAAM,CAACC,IAAI,CAACJ,QAAQ,CAAC,CAAgB;;IAC5D,KAAwB,IAAAK,YAAA,GAAAC,QAAA,CAAAL,UAAU,GAAAM,cAAA,GAAAF,YAAA,CAAAG,IAAA,KAAAD,cAAA,CAAAE,IAAA,EAAAF,cAAA,GAAAF,YAAA,CAAAG,IAAA,IAAE;MAA/B,IAAMhB,SAAS,GAAAe,cAAA,CAAAG,KAAA;MACnB,IAAMC,OAAO,GAAGX,QAAQ,CAACR,SAAS,CAAC;MACnC,IAAImB,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAGjC,KAAK,GAAG;QACrB,OAAOc,SAAS;;;;;;;;;;;;;;EAGlB,OAAO,SAAS;AACjB"},"metadata":{},"sourceType":"module","externalDependencies":[]}