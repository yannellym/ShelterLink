{"ast":null,"code":"function createError(message) {\n  var err = new Error(message);\n  err.source = \"ulid\";\n  return err;\n}\n// These values should NEVER change. If\n// they do, we're no longer making ulids!\nvar ENCODING = \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"; // Crockford's Base32\nvar ENCODING_LEN = ENCODING.length;\nvar TIME_MAX = Math.pow(2, 48) - 1;\nvar TIME_LEN = 10;\nvar RANDOM_LEN = 16;\nfunction replaceCharAt(str, index, char) {\n  if (index > str.length - 1) {\n    return str;\n  }\n  return str.substr(0, index) + char + str.substr(index + 1);\n}\nfunction incrementBase32(str) {\n  var done = undefined;\n  var index = str.length;\n  var char = void 0;\n  var charIndex = void 0;\n  var maxCharIndex = ENCODING_LEN - 1;\n  while (!done && index-- >= 0) {\n    char = str[index];\n    charIndex = ENCODING.indexOf(char);\n    if (charIndex === -1) {\n      throw createError(\"incorrectly encoded string\");\n    }\n    if (charIndex === maxCharIndex) {\n      str = replaceCharAt(str, index, ENCODING[0]);\n      continue;\n    }\n    done = replaceCharAt(str, index, ENCODING[charIndex + 1]);\n  }\n  if (typeof done === \"string\") {\n    return done;\n  }\n  throw createError(\"cannot increment this string\");\n}\nfunction randomChar(prng) {\n  var rand = Math.floor(prng() * ENCODING_LEN);\n  if (rand === ENCODING_LEN) {\n    rand = ENCODING_LEN - 1;\n  }\n  return ENCODING.charAt(rand);\n}\nfunction encodeTime(now, len) {\n  if (isNaN(now)) {\n    throw new Error(now + \" must be a number\");\n  }\n  if (now > TIME_MAX) {\n    throw createError(\"cannot encode time greater than \" + TIME_MAX);\n  }\n  if (now < 0) {\n    throw createError(\"time must be positive\");\n  }\n  if (Number.isInteger(now) === false) {\n    throw createError(\"time must be an integer\");\n  }\n  var mod = void 0;\n  var str = \"\";\n  for (; len > 0; len--) {\n    mod = now % ENCODING_LEN;\n    str = ENCODING.charAt(mod) + str;\n    now = (now - mod) / ENCODING_LEN;\n  }\n  return str;\n}\nfunction encodeRandom(len, prng) {\n  var str = \"\";\n  for (; len > 0; len--) {\n    str = randomChar(prng) + str;\n  }\n  return str;\n}\nfunction decodeTime(id) {\n  if (id.length !== TIME_LEN + RANDOM_LEN) {\n    throw createError(\"malformed ulid\");\n  }\n  var time = id.substr(0, TIME_LEN).split(\"\").reverse().reduce(function (carry, char, index) {\n    var encodingIndex = ENCODING.indexOf(char);\n    if (encodingIndex === -1) {\n      throw createError(\"invalid character found: \" + char);\n    }\n    return carry += encodingIndex * Math.pow(ENCODING_LEN, index);\n  }, 0);\n  if (time > TIME_MAX) {\n    throw createError(\"malformed ulid, timestamp too large\");\n  }\n  return time;\n}\nfunction detectPrng() {\n  var allowInsecure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  var root = arguments[1];\n  if (!root) {\n    root = typeof window !== \"undefined\" ? window : null;\n  }\n  var browserCrypto = root && (root.crypto || root.msCrypto);\n  if (browserCrypto) {\n    return function () {\n      var buffer = new Uint8Array(1);\n      browserCrypto.getRandomValues(buffer);\n      return buffer[0] / 0xff;\n    };\n  } else {\n    try {\n      var nodeCrypto = require(\"crypto\");\n      return function () {\n        return nodeCrypto.randomBytes(1).readUInt8() / 0xff;\n      };\n    } catch (e) {}\n  }\n  if (allowInsecure) {\n    try {\n      console.error(\"secure crypto unusable, falling back to insecure Math.random()!\");\n    } catch (e) {}\n    return function () {\n      return Math.random();\n    };\n  }\n  throw createError(\"secure crypto unusable, insecure Math.random not allowed\");\n}\nfunction factory(currPrng) {\n  if (!currPrng) {\n    currPrng = detectPrng();\n  }\n  return function ulid(seedTime) {\n    if (isNaN(seedTime)) {\n      seedTime = Date.now();\n    }\n    return encodeTime(seedTime, TIME_LEN) + encodeRandom(RANDOM_LEN, currPrng);\n  };\n}\nfunction monotonicFactory(currPrng) {\n  if (!currPrng) {\n    currPrng = detectPrng();\n  }\n  var lastTime = 0;\n  var lastRandom = void 0;\n  return function ulid(seedTime) {\n    if (isNaN(seedTime)) {\n      seedTime = Date.now();\n    }\n    if (seedTime <= lastTime) {\n      var incrementedRandom = lastRandom = incrementBase32(lastRandom);\n      return encodeTime(lastTime, TIME_LEN) + incrementedRandom;\n    }\n    lastTime = seedTime;\n    var newRandom = lastRandom = encodeRandom(RANDOM_LEN, currPrng);\n    return encodeTime(seedTime, TIME_LEN) + newRandom;\n  };\n}\nvar ulid = factory();\nexport { replaceCharAt, incrementBase32, randomChar, encodeTime, encodeRandom, decodeTime, detectPrng, factory, monotonicFactory, ulid };","map":{"version":3,"names":["createError","message","err","Error","source","ENCODING","ENCODING_LEN","length","TIME_MAX","Math","pow","TIME_LEN","RANDOM_LEN","replaceCharAt","str","index","char","substr","incrementBase32","done","undefined","charIndex","maxCharIndex","indexOf","randomChar","prng","rand","floor","charAt","encodeTime","now","len","isNaN","Number","isInteger","mod","encodeRandom","decodeTime","id","time","split","reverse","reduce","carry","encodingIndex","detectPrng","allowInsecure","arguments","root","window","browserCrypto","crypto","msCrypto","buffer","Uint8Array","getRandomValues","nodeCrypto","require","randomBytes","readUInt8","e","console","error","random","factory","currPrng","ulid","seedTime","Date","monotonicFactory","lastTime","lastRandom","incrementedRandom","newRandom"],"sources":["/Users/yannellym/Desktop/iwantapet/node_modules/ulid/dist/index.esm.js"],"sourcesContent":["function createError(message) {\n    var err = new Error(message);\n    err.source = \"ulid\";\n    return err;\n}\n// These values should NEVER change. If\n// they do, we're no longer making ulids!\nvar ENCODING = \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"; // Crockford's Base32\nvar ENCODING_LEN = ENCODING.length;\nvar TIME_MAX = Math.pow(2, 48) - 1;\nvar TIME_LEN = 10;\nvar RANDOM_LEN = 16;\nfunction replaceCharAt(str, index, char) {\n    if (index > str.length - 1) {\n        return str;\n    }\n    return str.substr(0, index) + char + str.substr(index + 1);\n}\nfunction incrementBase32(str) {\n    var done = undefined;\n    var index = str.length;\n    var char = void 0;\n    var charIndex = void 0;\n    var maxCharIndex = ENCODING_LEN - 1;\n    while (!done && index-- >= 0) {\n        char = str[index];\n        charIndex = ENCODING.indexOf(char);\n        if (charIndex === -1) {\n            throw createError(\"incorrectly encoded string\");\n        }\n        if (charIndex === maxCharIndex) {\n            str = replaceCharAt(str, index, ENCODING[0]);\n            continue;\n        }\n        done = replaceCharAt(str, index, ENCODING[charIndex + 1]);\n    }\n    if (typeof done === \"string\") {\n        return done;\n    }\n    throw createError(\"cannot increment this string\");\n}\nfunction randomChar(prng) {\n    var rand = Math.floor(prng() * ENCODING_LEN);\n    if (rand === ENCODING_LEN) {\n        rand = ENCODING_LEN - 1;\n    }\n    return ENCODING.charAt(rand);\n}\nfunction encodeTime(now, len) {\n    if (isNaN(now)) {\n        throw new Error(now + \" must be a number\");\n    }\n    if (now > TIME_MAX) {\n        throw createError(\"cannot encode time greater than \" + TIME_MAX);\n    }\n    if (now < 0) {\n        throw createError(\"time must be positive\");\n    }\n    if (Number.isInteger(now) === false) {\n        throw createError(\"time must be an integer\");\n    }\n    var mod = void 0;\n    var str = \"\";\n    for (; len > 0; len--) {\n        mod = now % ENCODING_LEN;\n        str = ENCODING.charAt(mod) + str;\n        now = (now - mod) / ENCODING_LEN;\n    }\n    return str;\n}\nfunction encodeRandom(len, prng) {\n    var str = \"\";\n    for (; len > 0; len--) {\n        str = randomChar(prng) + str;\n    }\n    return str;\n}\nfunction decodeTime(id) {\n    if (id.length !== TIME_LEN + RANDOM_LEN) {\n        throw createError(\"malformed ulid\");\n    }\n    var time = id.substr(0, TIME_LEN).split(\"\").reverse().reduce(function (carry, char, index) {\n        var encodingIndex = ENCODING.indexOf(char);\n        if (encodingIndex === -1) {\n            throw createError(\"invalid character found: \" + char);\n        }\n        return carry += encodingIndex * Math.pow(ENCODING_LEN, index);\n    }, 0);\n    if (time > TIME_MAX) {\n        throw createError(\"malformed ulid, timestamp too large\");\n    }\n    return time;\n}\nfunction detectPrng() {\n    var allowInsecure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var root = arguments[1];\n\n    if (!root) {\n        root = typeof window !== \"undefined\" ? window : null;\n    }\n    var browserCrypto = root && (root.crypto || root.msCrypto);\n    if (browserCrypto) {\n        return function () {\n            var buffer = new Uint8Array(1);\n            browserCrypto.getRandomValues(buffer);\n            return buffer[0] / 0xff;\n        };\n    } else {\n        try {\n            var nodeCrypto = require(\"crypto\");\n            return function () {\n                return nodeCrypto.randomBytes(1).readUInt8() / 0xff;\n            };\n        } catch (e) {}\n    }\n    if (allowInsecure) {\n        try {\n            console.error(\"secure crypto unusable, falling back to insecure Math.random()!\");\n        } catch (e) {}\n        return function () {\n            return Math.random();\n        };\n    }\n    throw createError(\"secure crypto unusable, insecure Math.random not allowed\");\n}\nfunction factory(currPrng) {\n    if (!currPrng) {\n        currPrng = detectPrng();\n    }\n    return function ulid(seedTime) {\n        if (isNaN(seedTime)) {\n            seedTime = Date.now();\n        }\n        return encodeTime(seedTime, TIME_LEN) + encodeRandom(RANDOM_LEN, currPrng);\n    };\n}\nfunction monotonicFactory(currPrng) {\n    if (!currPrng) {\n        currPrng = detectPrng();\n    }\n    var lastTime = 0;\n    var lastRandom = void 0;\n    return function ulid(seedTime) {\n        if (isNaN(seedTime)) {\n            seedTime = Date.now();\n        }\n        if (seedTime <= lastTime) {\n            var incrementedRandom = lastRandom = incrementBase32(lastRandom);\n            return encodeTime(lastTime, TIME_LEN) + incrementedRandom;\n        }\n        lastTime = seedTime;\n        var newRandom = lastRandom = encodeRandom(RANDOM_LEN, currPrng);\n        return encodeTime(seedTime, TIME_LEN) + newRandom;\n    };\n}\nvar ulid = factory();\n\nexport { replaceCharAt, incrementBase32, randomChar, encodeTime, encodeRandom, decodeTime, detectPrng, factory, monotonicFactory, ulid };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}