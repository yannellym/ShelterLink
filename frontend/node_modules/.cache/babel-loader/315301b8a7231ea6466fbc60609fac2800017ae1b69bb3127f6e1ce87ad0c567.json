{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { __assign } from \"tslib\";\nimport Observable from 'zen-observable-ts';\nimport { ConnectionState } from '../types/PubSub';\nimport { ReachabilityMonitor } from './ReachabilityMonitor';\nexport var CONNECTION_CHANGE = {\n  KEEP_ALIVE_MISSED: {\n    keepAliveState: 'unhealthy'\n  },\n  KEEP_ALIVE: {\n    keepAliveState: 'healthy'\n  },\n  CONNECTION_ESTABLISHED: {\n    connectionState: 'connected'\n  },\n  CONNECTION_FAILED: {\n    intendedConnectionState: 'disconnected',\n    connectionState: 'disconnected'\n  },\n  CLOSING_CONNECTION: {\n    intendedConnectionState: 'disconnected'\n  },\n  OPENING_CONNECTION: {\n    intendedConnectionState: 'connected',\n    connectionState: 'connecting'\n  },\n  CLOSED: {\n    connectionState: 'disconnected'\n  },\n  ONLINE: {\n    networkState: 'connected'\n  },\n  OFFLINE: {\n    networkState: 'disconnected'\n  }\n};\nvar ConnectionStateMonitor = /** @class */function () {\n  function ConnectionStateMonitor() {\n    var _this = this;\n    this._networkMonitoringSubscription = undefined;\n    this._linkedConnectionState = {\n      networkState: 'connected',\n      connectionState: 'disconnected',\n      intendedConnectionState: 'disconnected',\n      keepAliveState: 'healthy'\n    };\n    // Attempt to update the state with the current actual network state\n    this._initialNetworkStateSubscription = ReachabilityMonitor().subscribe(function (_a) {\n      var online = _a.online;\n      var _b;\n      _this.record(online ? CONNECTION_CHANGE.ONLINE : CONNECTION_CHANGE.OFFLINE);\n      (_b = _this._initialNetworkStateSubscription) === null || _b === void 0 ? void 0 : _b.unsubscribe();\n    });\n    this._linkedConnectionStateObservable = new Observable(function (connectionStateObserver) {\n      connectionStateObserver.next(_this._linkedConnectionState);\n      _this._linkedConnectionStateObserver = connectionStateObserver;\n    });\n  }\n  /**\n   * Turn network state monitoring on if it isn't on already\n   */\n  ConnectionStateMonitor.prototype.enableNetworkMonitoring = function () {\n    var _this = this;\n    var _a;\n    // If no initial network state was discovered, stop trying\n    (_a = this._initialNetworkStateSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n    // Maintain the network state based on the reachability monitor\n    if (this._networkMonitoringSubscription === undefined) {\n      this._networkMonitoringSubscription = ReachabilityMonitor().subscribe(function (_a) {\n        var online = _a.online;\n        _this.record(online ? CONNECTION_CHANGE.ONLINE : CONNECTION_CHANGE.OFFLINE);\n      });\n    }\n  };\n  /**\n   * Turn network state monitoring off if it isn't off already\n   */\n  ConnectionStateMonitor.prototype.disableNetworkMonitoring = function () {\n    var _a;\n    (_a = this._networkMonitoringSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n    this._networkMonitoringSubscription = undefined;\n  };\n  Object.defineProperty(ConnectionStateMonitor.prototype, \"connectionStateObservable\", {\n    /**\n     * Get the observable that allows us to monitor the connection state\n     *\n     * @returns {Observable<ConnectionState>} - The observable that emits ConnectionState updates\n     */\n    get: function () {\n      var _this = this;\n      var previous;\n      // The linked state aggregates state changes to any of the network, connection,\n      // intendedConnection and keepAliveHealth. Some states will change these independent\n      // states without changing the overall connection state.\n      // After translating from linked states to ConnectionState, then remove any duplicates\n      return this._linkedConnectionStateObservable.map(function (value) {\n        return _this.connectionStatesTranslator(value);\n      }).filter(function (current) {\n        var toInclude = current !== previous;\n        previous = current;\n        return toInclude;\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /*\n   * Updates local connection state and emits the full state to the observer.\n   */\n  ConnectionStateMonitor.prototype.record = function (statusUpdates) {\n    // Maintain the network monitor\n    if (statusUpdates.intendedConnectionState === 'connected') {\n      this.enableNetworkMonitoring();\n    } else if (statusUpdates.intendedConnectionState === 'disconnected') {\n      this.disableNetworkMonitoring();\n    }\n    // Maintain the socket state\n    var newSocketStatus = __assign(__assign({}, this._linkedConnectionState), statusUpdates);\n    this._linkedConnectionState = __assign({}, newSocketStatus);\n    this._linkedConnectionStateObserver.next(this._linkedConnectionState);\n  };\n  /*\n   * Translate the ConnectionState structure into a specific ConnectionState string literal union\n   */\n  ConnectionStateMonitor.prototype.connectionStatesTranslator = function (_a) {\n    var connectionState = _a.connectionState,\n      networkState = _a.networkState,\n      intendedConnectionState = _a.intendedConnectionState,\n      keepAliveState = _a.keepAliveState;\n    if (connectionState === 'connected' && networkState === 'disconnected') return ConnectionState.ConnectedPendingNetwork;\n    if (connectionState === 'connected' && intendedConnectionState === 'disconnected') return ConnectionState.ConnectedPendingDisconnect;\n    if (connectionState === 'disconnected' && intendedConnectionState === 'connected' && networkState === 'disconnected') return ConnectionState.ConnectionDisruptedPendingNetwork;\n    if (connectionState === 'disconnected' && intendedConnectionState === 'connected') return ConnectionState.ConnectionDisrupted;\n    if (connectionState === 'connected' && keepAliveState === 'unhealthy') return ConnectionState.ConnectedPendingKeepAlive;\n    // All remaining states directly correspond to the connection state\n    if (connectionState === 'connecting') return ConnectionState.Connecting;\n    if (connectionState === 'disconnected') return ConnectionState.Disconnected;\n    return ConnectionState.Connected;\n  };\n  return ConnectionStateMonitor;\n}();\nexport { ConnectionStateMonitor };","map":{"version":3,"names":["Observable","ConnectionState","ReachabilityMonitor","CONNECTION_CHANGE","KEEP_ALIVE_MISSED","keepAliveState","KEEP_ALIVE","CONNECTION_ESTABLISHED","connectionState","CONNECTION_FAILED","intendedConnectionState","CLOSING_CONNECTION","OPENING_CONNECTION","CLOSED","ONLINE","networkState","OFFLINE","ConnectionStateMonitor","_this","_networkMonitoringSubscription","undefined","_linkedConnectionState","_initialNetworkStateSubscription","subscribe","_a","online","record","_b","unsubscribe","_linkedConnectionStateObservable","connectionStateObserver","next","_linkedConnectionStateObserver","prototype","enableNetworkMonitoring","disableNetworkMonitoring","Object","defineProperty","get","previous","map","value","connectionStatesTranslator","filter","current","toInclude","statusUpdates","newSocketStatus","__assign","ConnectedPendingNetwork","ConnectedPendingDisconnect","ConnectionDisruptedPendingNetwork","ConnectionDisrupted","ConnectedPendingKeepAlive","Connecting","Disconnected","Connected"],"sources":["/Users/yannellym/Desktop/iwantapet/node_modules/@aws-amplify/pubsub/src/utils/ConnectionStateMonitor.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport Observable, { ZenObservable } from 'zen-observable-ts';\nimport { ConnectionState } from '../types/PubSub';\nimport { ReachabilityMonitor } from './ReachabilityMonitor';\n\n// Internal types for tracking different connection states\ntype LinkedConnectionState = 'connected' | 'disconnected';\ntype LinkedHealthState = 'healthy' | 'unhealthy';\ntype LinkedConnectionStates = {\n\tnetworkState: LinkedConnectionState;\n\tconnectionState: LinkedConnectionState | 'connecting';\n\tintendedConnectionState: LinkedConnectionState;\n\tkeepAliveState: LinkedHealthState;\n};\n\nexport const CONNECTION_CHANGE: {\n\t[key in\n\t\t| 'KEEP_ALIVE_MISSED'\n\t\t| 'KEEP_ALIVE'\n\t\t| 'CONNECTION_ESTABLISHED'\n\t\t| 'CONNECTION_FAILED'\n\t\t| 'CLOSING_CONNECTION'\n\t\t| 'OPENING_CONNECTION'\n\t\t| 'CLOSED'\n\t\t| 'ONLINE'\n\t\t| 'OFFLINE']: Partial<LinkedConnectionStates>;\n} = {\n\tKEEP_ALIVE_MISSED: { keepAliveState: 'unhealthy' },\n\tKEEP_ALIVE: { keepAliveState: 'healthy' },\n\tCONNECTION_ESTABLISHED: { connectionState: 'connected' },\n\tCONNECTION_FAILED: {\n\t\tintendedConnectionState: 'disconnected',\n\t\tconnectionState: 'disconnected',\n\t},\n\tCLOSING_CONNECTION: { intendedConnectionState: 'disconnected' },\n\tOPENING_CONNECTION: {\n\t\tintendedConnectionState: 'connected',\n\t\tconnectionState: 'connecting',\n\t},\n\tCLOSED: { connectionState: 'disconnected' },\n\tONLINE: { networkState: 'connected' },\n\tOFFLINE: { networkState: 'disconnected' },\n};\n\nexport class ConnectionStateMonitor {\n\t/**\n\t * @private\n\t */\n\tprivate _linkedConnectionState: LinkedConnectionStates;\n\tprivate _linkedConnectionStateObservable: Observable<LinkedConnectionStates>;\n\tprivate _linkedConnectionStateObserver: ZenObservable.SubscriptionObserver<LinkedConnectionStates>;\n\tprivate _networkMonitoringSubscription?: ZenObservable.Subscription;\n\tprivate _initialNetworkStateSubscription?: ZenObservable.Subscription;\n\n\tconstructor() {\n\t\tthis._networkMonitoringSubscription = undefined;\n\t\tthis._linkedConnectionState = {\n\t\t\tnetworkState: 'connected',\n\t\t\tconnectionState: 'disconnected',\n\t\t\tintendedConnectionState: 'disconnected',\n\t\t\tkeepAliveState: 'healthy',\n\t\t};\n\n\t\t// Attempt to update the state with the current actual network state\n\t\tthis._initialNetworkStateSubscription = ReachabilityMonitor().subscribe(\n\t\t\t({ online }) => {\n\t\t\t\tthis.record(\n\t\t\t\t\tonline ? CONNECTION_CHANGE.ONLINE : CONNECTION_CHANGE.OFFLINE\n\t\t\t\t);\n\t\t\t\tthis._initialNetworkStateSubscription?.unsubscribe();\n\t\t\t}\n\t\t);\n\n\t\tthis._linkedConnectionStateObservable =\n\t\t\tnew Observable<LinkedConnectionStates>(connectionStateObserver => {\n\t\t\t\tconnectionStateObserver.next(this._linkedConnectionState);\n\t\t\t\tthis._linkedConnectionStateObserver = connectionStateObserver;\n\t\t\t});\n\t}\n\n\t/**\n\t * Turn network state monitoring on if it isn't on already\n\t */\n\tprivate enableNetworkMonitoring() {\n\t\t// If no initial network state was discovered, stop trying\n\t\tthis._initialNetworkStateSubscription?.unsubscribe();\n\n\t\t// Maintain the network state based on the reachability monitor\n\t\tif (this._networkMonitoringSubscription === undefined) {\n\t\t\tthis._networkMonitoringSubscription = ReachabilityMonitor().subscribe(\n\t\t\t\t({ online }) => {\n\t\t\t\t\tthis.record(\n\t\t\t\t\t\tonline ? CONNECTION_CHANGE.ONLINE : CONNECTION_CHANGE.OFFLINE\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Turn network state monitoring off if it isn't off already\n\t */\n\tprivate disableNetworkMonitoring() {\n\t\tthis._networkMonitoringSubscription?.unsubscribe();\n\t\tthis._networkMonitoringSubscription = undefined;\n\t}\n\n\t/**\n\t * Get the observable that allows us to monitor the connection state\n\t *\n\t * @returns {Observable<ConnectionState>} - The observable that emits ConnectionState updates\n\t */\n\tpublic get connectionStateObservable(): Observable<ConnectionState> {\n\t\tlet previous: ConnectionState;\n\n\t\t// The linked state aggregates state changes to any of the network, connection,\n\t\t// intendedConnection and keepAliveHealth. Some states will change these independent\n\t\t// states without changing the overall connection state.\n\n\t\t// After translating from linked states to ConnectionState, then remove any duplicates\n\t\treturn this._linkedConnectionStateObservable\n\t\t\t.map(value => {\n\t\t\t\treturn this.connectionStatesTranslator(value);\n\t\t\t})\n\t\t\t.filter(current => {\n\t\t\t\tconst toInclude = current !== previous;\n\t\t\t\tprevious = current;\n\t\t\t\treturn toInclude;\n\t\t\t});\n\t}\n\n\t/*\n\t * Updates local connection state and emits the full state to the observer.\n\t */\n\trecord(statusUpdates: Partial<LinkedConnectionStates>) {\n\t\t// Maintain the network monitor\n\t\tif (statusUpdates.intendedConnectionState === 'connected') {\n\t\t\tthis.enableNetworkMonitoring();\n\t\t} else if (statusUpdates.intendedConnectionState === 'disconnected') {\n\t\t\tthis.disableNetworkMonitoring();\n\t\t}\n\n\t\t// Maintain the socket state\n\t\tconst newSocketStatus = {\n\t\t\t...this._linkedConnectionState,\n\t\t\t...statusUpdates,\n\t\t};\n\n\t\tthis._linkedConnectionState = { ...newSocketStatus };\n\n\t\tthis._linkedConnectionStateObserver.next(this._linkedConnectionState);\n\t}\n\n\t/*\n\t * Translate the ConnectionState structure into a specific ConnectionState string literal union\n\t */\n\tprivate connectionStatesTranslator({\n\t\tconnectionState,\n\t\tnetworkState,\n\t\tintendedConnectionState,\n\t\tkeepAliveState,\n\t}: LinkedConnectionStates): ConnectionState {\n\t\tif (connectionState === 'connected' && networkState === 'disconnected')\n\t\t\treturn ConnectionState.ConnectedPendingNetwork;\n\n\t\tif (\n\t\t\tconnectionState === 'connected' &&\n\t\t\tintendedConnectionState === 'disconnected'\n\t\t)\n\t\t\treturn ConnectionState.ConnectedPendingDisconnect;\n\n\t\tif (\n\t\t\tconnectionState === 'disconnected' &&\n\t\t\tintendedConnectionState === 'connected' &&\n\t\t\tnetworkState === 'disconnected'\n\t\t)\n\t\t\treturn ConnectionState.ConnectionDisruptedPendingNetwork;\n\n\t\tif (\n\t\t\tconnectionState === 'disconnected' &&\n\t\t\tintendedConnectionState === 'connected'\n\t\t)\n\t\t\treturn ConnectionState.ConnectionDisrupted;\n\n\t\tif (connectionState === 'connected' && keepAliveState === 'unhealthy')\n\t\t\treturn ConnectionState.ConnectedPendingKeepAlive;\n\n\t\t// All remaining states directly correspond to the connection state\n\t\tif (connectionState === 'connecting') return ConnectionState.Connecting;\n\t\tif (connectionState === 'disconnected') return ConnectionState.Disconnected;\n\t\treturn ConnectionState.Connected;\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}