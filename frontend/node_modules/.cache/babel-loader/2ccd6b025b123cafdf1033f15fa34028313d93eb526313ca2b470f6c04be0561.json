{"ast":null,"code":"import { __assign, __asyncValues, __awaiter, __generator, __read, __spread, __values } from \"tslib\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { PredicateInternalsKey } from '../types';\nimport { ModelPredicateCreator as FlatModelPredicateCreator, comparisonKeys } from './index';\nimport { ModelRelationship } from '../storage/relationship';\nimport { asyncSome, asyncEvery } from '../util';\nvar ops = __spread(comparisonKeys);\n/**\n * A map from keys (exposed to customers) to the internal predicate data\n * structures invoking code should not muck with.\n */\nvar predicateInternalsMap = new Map();\n/**\n * Creates a link between a key (and generates a key if needed) and an internal\n * `GroupCondition`, which allows us to return a key object instead of the gory\n * conditions details to customers/invoking code.\n *\n * @param condition The internal condition to keep hidden.\n * @param key The object DataStore will use to find the internal condition.\n * If no key is given, an empty one is created.\n */\nvar registerPredicateInternals = function (condition, key) {\n  var finalKey = key || new PredicateInternalsKey();\n  predicateInternalsMap.set(finalKey, condition);\n  return finalKey;\n};\n/**\n * Takes a key object from `registerPredicateInternals()` to fetch an internal\n * `GroupCondition` object, which can then be used to query storage or\n * test/match objects.\n *\n * This indirection exists to hide `GroupCondition` from public interfaces, since\n * `GroupCondition` contains extra methods and properties that public callers\n * should not use.\n *\n * @param key A key object previously returned by `registerPredicateInternals()`\n */\nexport var internals = function (key) {\n  if (!predicateInternalsMap.has(key)) {\n    throw new Error(\"Invalid predicate. Terminate your predicate with a valid condition (e.g., `p => p.field.eq('value')`) or pass `Predicates.ALL`.\");\n  }\n  return predicateInternalsMap.get(key);\n};\n/**\n * Maps operators to negated operators.\n * Used to facilitate propagation of negation down a tree of conditions.\n */\nvar negations = {\n  and: 'or',\n  or: 'and',\n  not: 'and',\n  eq: 'ne',\n  ne: 'eq',\n  gt: 'le',\n  ge: 'lt',\n  lt: 'ge',\n  le: 'gt',\n  contains: 'notContains',\n  notContains: 'contains'\n};\n/**\n * A condition that can operate against a single \"primitive\" field of a model or item.\n * @member field The field of *some record* to test against.\n * @member operator The equality or comparison operator to use.\n * @member operands The operands for the equality/comparison check.\n */\nvar FieldCondition = /** @class */function () {\n  function FieldCondition(field, operator, operands) {\n    this.field = field;\n    this.operator = operator;\n    this.operands = operands;\n    this.validate();\n  }\n  /**\n   * Creates a copy of self.\n   * @param extract Not used. Present only to fulfill the `UntypedCondition` interface.\n   * @returns A new, identitical `FieldCondition`.\n   */\n  FieldCondition.prototype.copy = function (extract) {\n    return [new FieldCondition(this.field, this.operator, __spread(this.operands)), undefined];\n  };\n  /**\n   * Produces a tree structure similar to a graphql condition. The returned\n   * structure is \"dumb\" and is intended for another query/condition\n   * generation mechanism to interpret, such as the cloud or storage query\n   * builders.\n   *\n   * E.g.,\n   *\n   * ```json\n   * {\n   * \t\"name\": {\n   * \t\t\"eq\": \"robert\"\n   * \t}\n   * }\n   * ```\n   */\n  FieldCondition.prototype.toAST = function () {\n    var _a, _b;\n    return _a = {}, _a[this.field] = (_b = {}, _b[this.operator] = this.operator === 'between' ? [this.operands[0], this.operands[1]] : this.operands[0], _b), _a;\n  };\n  /**\n   * Produces a new condition (`FieldCondition` or `GroupCondition`) that\n   * matches the opposite of this condition.\n   *\n   * Intended to be used when applying De Morgan's Law, which can be done to\n   * produce more efficient queries against the storage layer if a negation\n   * appears in the query tree.\n   *\n   * For example:\n   *\n   * 1. `name.eq('robert')` becomes `name.ne('robert')`\n   * 2. `price.between(100, 200)` becomes `m => m.or(m => [m.price.lt(100), m.price.gt(200)])`\n   *\n   * @param model The model meta to use when construction a new `GroupCondition`\n   * for cases where the negation requires multiple `FieldCondition`'s.\n   */\n  FieldCondition.prototype.negated = function (model) {\n    if (this.operator === 'between') {\n      return new GroupCondition(model, undefined, undefined, 'or', [new FieldCondition(this.field, 'lt', [this.operands[0]]), new FieldCondition(this.field, 'gt', [this.operands[1]])]);\n    } else if (this.operator === 'beginsWith') {\n      // beginsWith negation doesn't have a good, safe optimation right now.\n      // just re-wrap it in negation. The adapter will have to scan-and-filter,\n      // as is likely optimal for negated beginsWith conditions *anyway*.\n      return new GroupCondition(model, undefined, undefined, 'not', [new FieldCondition(this.field, 'beginsWith', [this.operands[0]])]);\n    } else {\n      return new FieldCondition(this.field, negations[this.operator], this.operands);\n    }\n  };\n  /**\n   * Not implemented. Not needed. GroupCondition instead consumes FieldConditions and\n   * transforms them into legacy predicates. (*For now.*)\n   * @param storage N/A. If ever implemented, the storage adapter to query.\n   * @returns N/A. If ever implemented, return items from `storage` that match.\n   */\n  FieldCondition.prototype.fetch = function (storage) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, Promise.reject('No implementation needed [yet].')];\n      });\n    });\n  };\n  /**\n   * Determins whether a given item matches the expressed condition.\n   * @param item The item to test.\n   * @returns `Promise<boolean>`, `true` if matches; `false` otherwise.\n   */\n  FieldCondition.prototype.matches = function (item) {\n    return __awaiter(this, void 0, void 0, function () {\n      var v, operations, operation, result;\n      var _this = this;\n      return __generator(this, function (_a) {\n        v = item[this.field];\n        operations = {\n          eq: function () {\n            return v === _this.operands[0];\n          },\n          ne: function () {\n            return v !== _this.operands[0];\n          },\n          gt: function () {\n            return v > _this.operands[0];\n          },\n          ge: function () {\n            return v >= _this.operands[0];\n          },\n          lt: function () {\n            return v < _this.operands[0];\n          },\n          le: function () {\n            return v <= _this.operands[0];\n          },\n          contains: function () {\n            return (v === null || v === void 0 ? void 0 : v.indexOf(_this.operands[0])) > -1;\n          },\n          notContains: function () {\n            return !v ? true : v.indexOf(_this.operands[0]) === -1;\n          },\n          beginsWith: function () {\n            return v === null || v === void 0 ? void 0 : v.startsWith(_this.operands[0]);\n          },\n          between: function () {\n            return v >= _this.operands[0] && v <= _this.operands[1];\n          }\n        };\n        operation = operations[this.operator];\n        if (operation) {\n          result = operation();\n          return [2 /*return*/, result];\n        } else {\n          throw new Error(\"Invalid operator given: \" + this.operator);\n        }\n        return [2 /*return*/];\n      });\n    });\n  };\n  /**\n   * Checks `this.operands` for compatibility with `this.operator`.\n   */\n  FieldCondition.prototype.validate = function () {\n    var _this = this;\n    /**\n     * Creates a validator that checks for a particular `operands` count.\n     * Throws an exception if the `count` disagrees with `operands.length`.\n     * @param count The number of `operands` expected.\n     */\n    var argumentCount = function (count) {\n      var argsClause = count === 1 ? 'argument is' : 'arguments are';\n      return function () {\n        if (_this.operands.length !== count) {\n          return \"Exactly \" + count + \" \" + argsClause + \" required.\";\n        }\n      };\n    };\n    // NOTE: validations should return a message on failure.\n    // hence, they should be \"joined\" together with logical OR's\n    // as seen in the `between:` entry.\n    var validations = {\n      eq: argumentCount(1),\n      ne: argumentCount(1),\n      gt: argumentCount(1),\n      ge: argumentCount(1),\n      lt: argumentCount(1),\n      le: argumentCount(1),\n      contains: argumentCount(1),\n      notContains: argumentCount(1),\n      beginsWith: argumentCount(1),\n      between: function () {\n        return argumentCount(2)() || (_this.operands[0] > _this.operands[1] ? 'The first argument must be less than or equal to the second argument.' : null);\n      }\n    };\n    var validate = validations[this.operator];\n    if (validate) {\n      var e = validate();\n      if (typeof e === 'string') throw new Error(\"Incorrect usage of `\" + this.operator + \"()`: \" + e);\n    } else {\n      throw new Error(\"Non-existent operator: `\" + this.operator + \"()`\");\n    }\n  };\n  return FieldCondition;\n}();\nexport { FieldCondition };\n/**\n * Small utility function to generate a monotonically increasing ID.\n * Used by GroupCondition to help keep track of which group is doing what,\n * when, and where during troubleshooting.\n */\nvar getGroupId = function () {\n  var seed = 1;\n  return function () {\n    return \"group_\" + seed++;\n  };\n}();\n/**\n * A set of sub-conditions to operate against a model, optionally scoped to\n * a specific field, combined with the given operator (one of `and`, `or`, or `not`).\n * @member groupId Used to distinguish between GroupCondition instances for\n * debugging and troublehsooting.\n * @member model A metadata object that tells GroupCondition what to query and how.\n * @member field The field on the model that the sub-conditions apply to.\n * @member operator How to group child conditions together.\n * @member operands The child conditions.\n */\nvar GroupCondition = /** @class */function () {\n  function GroupCondition(\n  /**\n   * The `ModelMeta` of the model to query and/or filter against.\n   * Expected to contain:\n   *\n   * ```js\n   * {\n   * \tbuilder: ModelConstructor,\n   * \tschema: SchemaModel,\n   * \tpkField: string[]\n   * }\n   * ```\n   */\n  model,\n  /**\n   * If populated, this group specifices a condition on a relationship.\n   *\n   * If `field` does *not* point to a related model, that's an error. It\n   * could indicate that the `GroupCondition` was instantiated with bad\n   * data, or that the model metadata is incorrect.\n   */\n  field,\n  /**\n   * If a `field` is given, whether the relationship is a `HAS_ONE`,\n   * 'HAS_MANY`, or `BELONGS_TO`.\n   *\n   * TODO: Remove this and replace with derivation using\n   * `ModelRelationship.from(this.model, this.field).relationship`;\n   */\n  relationshipType,\n  /**\n   *\n   */\n  operator,\n  /**\n   *\n   */\n  operands,\n  /**\n   * Whether this GroupCondition is the result of an optimize call.\n   *\n   * This is used to guard against infinitely fetch -> optimize -> fetch\n   * recursion.\n   */\n  isOptimized) {\n    if (isOptimized === void 0) {\n      isOptimized = false;\n    }\n    this.model = model;\n    this.field = field;\n    this.relationshipType = relationshipType;\n    this.operator = operator;\n    this.operands = operands;\n    this.isOptimized = isOptimized;\n    // `groupId` was used for development/debugging.\n    // Should we leave this in for future troubleshooting?\n    this.groupId = getGroupId();\n  }\n  /**\n   * Returns a copy of a GroupCondition, which also returns the copy of a\n   * given reference node to \"extract\".\n   * @param extract A node of interest. Its copy will *also* be returned if the node exists.\n   * @returns [The full copy, the copy of `extract` | undefined]\n   */\n  GroupCondition.prototype.copy = function (extract) {\n    var copied = new GroupCondition(this.model, this.field, this.relationshipType, this.operator, []);\n    var extractedCopy = extract === this ? copied : undefined;\n    this.operands.forEach(function (o) {\n      var _a = __read(o.copy(extract), 2),\n        operandCopy = _a[0],\n        extractedFromOperand = _a[1];\n      copied.operands.push(operandCopy);\n      extractedCopy = extractedCopy || extractedFromOperand;\n    });\n    return [copied, extractedCopy];\n  };\n  /**\n   * Creates a new `GroupCondition` that contains only the local field conditions,\n   * omitting related model conditions. That resulting `GroupCondition` can be\n   * used to produce predicates that are compatible with the storage adapters and\n   * Cloud storage.\n   *\n   * @param negate Whether the condition tree should be negated according\n   * to De Morgan's law.\n   */\n  GroupCondition.prototype.withFieldConditionsOnly = function (negate) {\n    var _this = this;\n    var negateChildren = negate !== (this.operator === 'not');\n    return new GroupCondition(this.model, undefined, undefined, negate ? negations[this.operator] : this.operator, this.operands.filter(function (o) {\n      return o instanceof FieldCondition;\n    }).map(function (o) {\n      return negateChildren ? o.negated(_this.model) : o;\n    }));\n  };\n  /**\n   * Returns a version of the predicate tree with unnecessary logical groups\n   * condensed and merged together. This is intended to create a dense tree\n   * with leaf nodes (`FieldCondition`'s) aggregated under as few group conditions\n   * as possible for the most efficient fetching possible -- it allows `fetch()`.\n   *\n   * E.g. a grouping like this:\n   *\n   * ```yaml\n   * and:\n   * \tand:\n   * \t\tid:\n   * \t\t\teq: \"abc\"\n   * \tand:\n   * \t\tname:\n   * \t\t\teq: \"xyz\"\n   * ```\n   *\n   * Will become this:\n   *\n   * ```yaml\n   * and:\n   * \tid:\n   * \t\teq: \"abc\"\n   * \tname:\n   * \t\teq: \"xyz\"\n   * ```\n   *\n   * This allows `fetch()` to pass both the `id` and `name` conditions to the adapter\n   * together, which can then decide what index to use based on both fields together.\n   *\n   * @param preserveNode Whether to preserve the current node and to explicitly not eliminate\n   * it during optimization. Used internally to preserve the root node and children of\n   * `not` groups. `not` groups will always have a single child, so there's nothing to\n   * optimize below a `not` (for now), and it makes the query logic simpler later.\n   */\n  GroupCondition.prototype.optimized = function (preserveNode) {\n    var _this = this;\n    if (preserveNode === void 0) {\n      preserveNode = true;\n    }\n    var operands = this.operands.map(function (o) {\n      return o instanceof GroupCondition ? o.optimized(_this.operator === 'not') : o;\n    });\n    // we're only collapsing and/or groups that contains a single child for now,\n    // because they're much more common and much more trivial to collapse. basically,\n    // an `and`/`or` that contains a single child doesn't require the layer of\n    // logical grouping.\n    if (!preserveNode && ['and', 'or'].includes(this.operator) && !this.field && operands.length === 1) {\n      var operand = operands[0];\n      if (operand instanceof FieldCondition) {\n        // between conditions should NOT be passed up the chain. if they\n        // need to be *negated* later, it is important that they be properly\n        // contained in an AND group. when de morgan's law is applied, the\n        // conditions are reversed and the AND group flips to an OR. this\n        // doesn't work right if the a `between` doesn't live in an AND group.\n        if (operand.operator !== 'between') {\n          return operand;\n        }\n      } else {\n        return operand;\n      }\n    }\n    return new GroupCondition(this.model, this.field, this.relationshipType, this.operator, operands, true);\n  };\n  /**\n   * Fetches matching records from a given storage adapter using legacy predicates (for now).\n   * @param storage The storage adapter this predicate will query against.\n   * @param breadcrumb For debugging/troubleshooting. A list of the `groupId`'s this\n   * GroupdCondition.fetch is nested within.\n   * @param negate Whether to match on the `NOT` of `this`.\n   * @returns An `Promise` of `any[]` from `storage` matching the child conditions.\n   */\n  GroupCondition.prototype.fetch = function (storage, breadcrumb, negate) {\n    if (breadcrumb === void 0) {\n      breadcrumb = [];\n    }\n    if (negate === void 0) {\n      negate = false;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var resultGroups, operator, negateChildren, groups, conditions, groups_1, groups_1_1, g, relatives, relationship, allJoinConditions, relatives_1, relatives_1_1, relative, relativeConditions, i, predicate, _a, _b, e_1_1, predicate, _c, _d, _e, _f, getPKValue, resultIndex, resultGroups_1, resultGroups_1_1, group, intersectWith, _g, _h, k, resultGroups_2, resultGroups_2_1, group, group_1, group_1_1, item;\n      var e_1, _j, e_2, _k, _l, e_3, _m, e_4, _o, e_5, _p, e_6, _q;\n      var _this = this;\n      return __generator(this, function (_r) {\n        switch (_r.label) {\n          case 0:\n            if (!this.isOptimized) {\n              return [2 /*return*/, this.optimized().fetch(storage)];\n            }\n            resultGroups = [];\n            operator = negate ? negations[this.operator] : this.operator;\n            negateChildren = negate !== (this.operator === 'not');\n            groups = this.operands.filter(function (op) {\n              return op instanceof GroupCondition;\n            });\n            conditions = this.operands.filter(function (op) {\n              return op instanceof FieldCondition;\n            });\n            _r.label = 1;\n          case 1:\n            _r.trys.push([1, 10, 11, 12]);\n            groups_1 = __values(groups), groups_1_1 = groups_1.next();\n            _r.label = 2;\n          case 2:\n            if (!!groups_1_1.done) return [3 /*break*/, 9];\n            g = groups_1_1.value;\n            return [4 /*yield*/, g.fetch(storage, __spread(breadcrumb, [this.groupId]), negateChildren)];\n          case 3:\n            relatives = _r.sent();\n            // no relatives -> no need to attempt to perform a \"join\" query for\n            // candidate results:\n            //\n            // select a.* from a,b where b.id in EMPTY_SET ==> EMPTY_SET\n            //\n            // Additionally, the entire (sub)-query can be short-circuited if\n            // the operator is `AND`. Illustrated in SQL:\n            //\n            // select a.* from a where\n            //   id in [a,b,c]\n            //     AND                        <\n            //   id in EMTPY_SET            <<< Look!\n            //     AND                        <\n            //   id in [x,y,z]\n            //\n            // YIELDS: EMPTY_SET           // <-- Easy peasy. Lemon squeezy.\n            //\n            if (relatives.length === 0) {\n              // aggressively short-circuit as soon as we know the group condition will fail\n              if (operator === 'and') {\n                return [2 /*return*/, []];\n              }\n              // less aggressive short-circuit if we know the relatives will produce no\n              // candidate results; but aren't sure yet how this affects the group condition.\n              resultGroups.push([]);\n              return [3 /*break*/, 8];\n            }\n            if (!g.field) return [3 /*break*/, 7];\n            relationship = ModelRelationship.from(this.model, g.field);\n            if (!relationship) return [3 /*break*/, 5];\n            allJoinConditions = [];\n            try {\n              for (relatives_1 = (e_2 = void 0, __values(relatives)), relatives_1_1 = relatives_1.next(); !relatives_1_1.done; relatives_1_1 = relatives_1.next()) {\n                relative = relatives_1_1.value;\n                relativeConditions = [];\n                for (i = 0; i < relationship.localJoinFields.length; i++) {\n                  relativeConditions.push((_l = {}, _l[relationship.localJoinFields[i]] = {\n                    eq: relative[relationship.remoteJoinFields[i]]\n                  }, _l));\n                }\n                allJoinConditions.push({\n                  and: relativeConditions\n                });\n              }\n            } catch (e_2_1) {\n              e_2 = {\n                error: e_2_1\n              };\n            } finally {\n              try {\n                if (relatives_1_1 && !relatives_1_1.done && (_k = relatives_1.return)) _k.call(relatives_1);\n              } finally {\n                if (e_2) throw e_2.error;\n              }\n            }\n            predicate = FlatModelPredicateCreator.createFromAST(this.model.schema, {\n              or: allJoinConditions\n            });\n            _b = (_a = resultGroups).push;\n            return [4 /*yield*/, storage.query(this.model.builder, predicate)];\n          case 4:\n            _b.apply(_a, [_r.sent()]);\n            return [3 /*break*/, 6];\n          case 5:\n            throw new Error('Missing field metadata.');\n          case 6:\n            return [3 /*break*/, 8];\n          case 7:\n            // relatives are not actually relatives. they're candidate results.\n            resultGroups.push(relatives);\n            _r.label = 8;\n          case 8:\n            groups_1_1 = groups_1.next();\n            return [3 /*break*/, 2];\n          case 9:\n            return [3 /*break*/, 12];\n          case 10:\n            e_1_1 = _r.sent();\n            e_1 = {\n              error: e_1_1\n            };\n            return [3 /*break*/, 12];\n          case 11:\n            try {\n              if (groups_1_1 && !groups_1_1.done && (_j = groups_1.return)) _j.call(groups_1);\n            } finally {\n              if (e_1) throw e_1.error;\n            }\n            return [7 /*endfinally*/];\n          case 12:\n            if (!(conditions.length > 0)) return [3 /*break*/, 14];\n            predicate = this.withFieldConditionsOnly(negateChildren).toStoragePredicate();\n            _d = (_c = resultGroups).push;\n            return [4 /*yield*/, storage.query(this.model.builder, predicate)];\n          case 13:\n            _d.apply(_c, [_r.sent()]);\n            return [3 /*break*/, 16];\n          case 14:\n            if (!(conditions.length === 0 && resultGroups.length === 0)) return [3 /*break*/, 16];\n            _f = (_e = resultGroups).push;\n            return [4 /*yield*/, storage.query(this.model.builder)];\n          case 15:\n            _f.apply(_e, [_r.sent()]);\n            _r.label = 16;\n          case 16:\n            getPKValue = function (item) {\n              return JSON.stringify(_this.model.pkField.map(function (name) {\n                return item[name];\n              }));\n            };\n            if (operator === 'and') {\n              if (resultGroups.length === 0) {\n                return [2 /*return*/, []];\n              }\n              try {\n                // for each group, we intersect, removing items from the result index\n                // that aren't present in each subsequent group.\n                for (resultGroups_1 = __values(resultGroups), resultGroups_1_1 = resultGroups_1.next(); !resultGroups_1_1.done; resultGroups_1_1 = resultGroups_1.next()) {\n                  group = resultGroups_1_1.value;\n                  if (resultIndex === undefined) {\n                    resultIndex = new Map(group.map(function (item) {\n                      return [getPKValue(item), item];\n                    }));\n                  } else {\n                    intersectWith = new Map(group.map(function (item) {\n                      return [getPKValue(item), item];\n                    }));\n                    try {\n                      for (_g = (e_4 = void 0, __values(resultIndex.keys())), _h = _g.next(); !_h.done; _h = _g.next()) {\n                        k = _h.value;\n                        if (!intersectWith.has(k)) {\n                          resultIndex.delete(k);\n                        }\n                      }\n                    } catch (e_4_1) {\n                      e_4 = {\n                        error: e_4_1\n                      };\n                    } finally {\n                      try {\n                        if (_h && !_h.done && (_o = _g.return)) _o.call(_g);\n                      } finally {\n                        if (e_4) throw e_4.error;\n                      }\n                    }\n                  }\n                }\n              } catch (e_3_1) {\n                e_3 = {\n                  error: e_3_1\n                };\n              } finally {\n                try {\n                  if (resultGroups_1_1 && !resultGroups_1_1.done && (_m = resultGroups_1.return)) _m.call(resultGroups_1);\n                } finally {\n                  if (e_3) throw e_3.error;\n                }\n              }\n            } else if (operator === 'or' || operator === 'not') {\n              // it's OK to handle NOT here, because NOT must always only negate\n              // a single child predicate. NOT logic will have been distributed down\n              // to the leaf conditions already.\n              resultIndex = new Map();\n              try {\n                // just merge the groups, performing DISTINCT-ification by ID.\n                for (resultGroups_2 = __values(resultGroups), resultGroups_2_1 = resultGroups_2.next(); !resultGroups_2_1.done; resultGroups_2_1 = resultGroups_2.next()) {\n                  group = resultGroups_2_1.value;\n                  try {\n                    for (group_1 = (e_6 = void 0, __values(group)), group_1_1 = group_1.next(); !group_1_1.done; group_1_1 = group_1.next()) {\n                      item = group_1_1.value;\n                      resultIndex.set(getPKValue(item), item);\n                    }\n                  } catch (e_6_1) {\n                    e_6 = {\n                      error: e_6_1\n                    };\n                  } finally {\n                    try {\n                      if (group_1_1 && !group_1_1.done && (_q = group_1.return)) _q.call(group_1);\n                    } finally {\n                      if (e_6) throw e_6.error;\n                    }\n                  }\n                }\n              } catch (e_5_1) {\n                e_5 = {\n                  error: e_5_1\n                };\n              } finally {\n                try {\n                  if (resultGroups_2_1 && !resultGroups_2_1.done && (_p = resultGroups_2.return)) _p.call(resultGroups_2);\n                } finally {\n                  if (e_5) throw e_5.error;\n                }\n              }\n            }\n            return [2 /*return*/, Array.from((resultIndex === null || resultIndex === void 0 ? void 0 : resultIndex.values()) || [])];\n        }\n      });\n    });\n  };\n  /**\n   * Determines whether a single item matches the conditions of `this`.\n   * When checking the target `item`'s properties, each property will be `await`'d\n   * to ensure lazy-loading is respected where applicable.\n   * @param item The item to match against.\n   * @param ignoreFieldName Tells `match()` that the field name has already been dereferenced.\n   * (Used for iterating over children on HAS_MANY checks.)\n   * @returns A boolean (promise): `true` if matched, `false` otherwise.\n   */\n  GroupCondition.prototype.matches = function (item, ignoreFieldName) {\n    if (ignoreFieldName === void 0) {\n      ignoreFieldName = false;\n    }\n    var e_7, _a;\n    return __awaiter(this, void 0, void 0, function () {\n      var itemToCheck, _b, itemToCheck_1, itemToCheck_1_1, singleItem, e_7_1;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            if (!(this.field && !ignoreFieldName)) return [3 /*break*/, 2];\n            return [4 /*yield*/, item[this.field]];\n          case 1:\n            _b = _c.sent();\n            return [3 /*break*/, 3];\n          case 2:\n            _b = item;\n            _c.label = 3;\n          case 3:\n            itemToCheck = _b;\n            // if there is no item to check, we can stop recursing immediately.\n            // a condition cannot match against an item that does not exist. this\n            // can occur when `item.field` is optional in the schema.\n            if (!itemToCheck) {\n              return [2 /*return*/, false];\n            }\n            if (!(this.relationshipType === 'HAS_MANY' && typeof itemToCheck[Symbol.asyncIterator] === 'function')) return [3 /*break*/, 17];\n            _c.label = 4;\n          case 4:\n            _c.trys.push([4, 10, 11, 16]);\n            itemToCheck_1 = __asyncValues(itemToCheck);\n            _c.label = 5;\n          case 5:\n            return [4 /*yield*/, itemToCheck_1.next()];\n          case 6:\n            if (!(itemToCheck_1_1 = _c.sent(), !itemToCheck_1_1.done)) return [3 /*break*/, 9];\n            singleItem = itemToCheck_1_1.value;\n            return [4 /*yield*/, this.matches(singleItem, true)];\n          case 7:\n            if (_c.sent()) {\n              return [2 /*return*/, true];\n            }\n            _c.label = 8;\n          case 8:\n            return [3 /*break*/, 5];\n          case 9:\n            return [3 /*break*/, 16];\n          case 10:\n            e_7_1 = _c.sent();\n            e_7 = {\n              error: e_7_1\n            };\n            return [3 /*break*/, 16];\n          case 11:\n            _c.trys.push([11,, 14, 15]);\n            if (!(itemToCheck_1_1 && !itemToCheck_1_1.done && (_a = itemToCheck_1.return))) return [3 /*break*/, 13];\n            return [4 /*yield*/, _a.call(itemToCheck_1)];\n          case 12:\n            _c.sent();\n            _c.label = 13;\n          case 13:\n            return [3 /*break*/, 15];\n          case 14:\n            if (e_7) throw e_7.error;\n            return [7 /*endfinally*/];\n          case 15:\n            return [7 /*endfinally*/];\n          case 16:\n            return [2 /*return*/, false];\n          case 17:\n            if (!(this.operator === 'or')) return [3 /*break*/, 18];\n            return [2 /*return*/, asyncSome(this.operands, function (c) {\n              return c.matches(itemToCheck);\n            })];\n          case 18:\n            if (!(this.operator === 'and')) return [3 /*break*/, 19];\n            return [2 /*return*/, asyncEvery(this.operands, function (c) {\n              return c.matches(itemToCheck);\n            })];\n          case 19:\n            if (!(this.operator === 'not')) return [3 /*break*/, 21];\n            if (this.operands.length !== 1) {\n              throw new Error('Invalid arguments! `not()` accepts exactly one predicate expression.');\n            }\n            return [4 /*yield*/, this.operands[0].matches(itemToCheck)];\n          case 20:\n            return [2 /*return*/, !_c.sent()];\n          case 21:\n            throw new Error('Invalid group operator!');\n        }\n      });\n    });\n  };\n  /**\n   * Tranfsorm to a AppSync GraphQL compatible AST.\n   * (Does not support filtering in nested types.)\n   */\n  GroupCondition.prototype.toAST = function () {\n    var _a;\n    if (this.field) throw new Error('Nested type conditions are not supported!');\n    return _a = {}, _a[this.operator] = this.operands.map(function (operand) {\n      return operand.toAST();\n    }), _a;\n  };\n  /**\n   * Turn this predicate group into something a storage adapter\n   * understands how to use.\n   */\n  GroupCondition.prototype.toStoragePredicate = function () {\n    return FlatModelPredicateCreator.createFromAST(this.model.schema, this.toAST());\n  };\n  /**\n   * A JSON representation that's good for debugging.\n   */\n  GroupCondition.prototype.toJSON = function () {\n    return __assign(__assign({}, this), {\n      model: this.model.schema.name\n    });\n  };\n  return GroupCondition;\n}();\nexport { GroupCondition };\n/**\n * Creates a \"seed\" predicate that can be used to build an executable condition.\n * This is used in `query()`, for example, to seed customer- E.g.,\n *\n * ```\n * const p = predicateFor({builder: modelConstructor, schema: modelSchema, pkField: string[]});\n * p.and(child => [\n *   child.field.eq('whatever'),\n *   child.childModel.childField.eq('whatever else'),\n *   child.childModel.or(child => [\n *     child.otherField.contains('x'),\n *     child.otherField.contains('y'),\n *     child.otherField.contains('z'),\n *   ])\n * ])\n * ```\n *\n * `predicateFor()` returns objecst with recursive getters. To facilitate this,\n * a `query` and `tail` can be provided to \"accumulate\" nested conditions.\n *\n * @param ModelType The ModelMeta used to build child properties.\n * @param field Scopes the query branch to a field.\n * @param query A base query to build on. Omit to start a new query.\n * @param tail The point in an existing `query` to attach new conditions to.\n * @returns A ModelPredicate (builder) that customers can create queries with.\n * (As shown in function description.)\n */\nexport function recursivePredicateFor(ModelType, allowRecursion, field, query, tail) {\n  if (allowRecursion === void 0) {\n    allowRecursion = true;\n  }\n  // to be used if we don't have a base query or tail to build onto\n  var starter = new GroupCondition(ModelType, field, undefined, 'and', []);\n  var baseCondition = query && tail ? query : starter;\n  var tailCondition = query && tail ? tail : starter;\n  // our eventual return object, which can be built upon.\n  // next steps will be to add or(), and(), not(), and field.op() methods.\n  var link = {};\n  // so it can be looked up later with in the internals when processing conditions.\n  registerPredicateInternals(baseCondition, link);\n  var copyLink = function () {\n    var _a = __read(baseCondition.copy(tailCondition), 2),\n      query = _a[0],\n      newTail = _a[1];\n    var newLink = recursivePredicateFor(ModelType, allowRecursion, undefined, query, newTail);\n    return {\n      query: query,\n      newTail: newTail,\n      newLink: newLink\n    };\n  };\n  // Adds .or() and .and() methods to the link.\n  // TODO: If revisiting this code, consider writing a Proxy instead.\n  ['and', 'or'].forEach(function (op) {\n    link[op] = function (builder) {\n      // or() and and() will return a copy of the original link\n      // to head off mutability concerns.\n      var _a = copyLink(),\n        query = _a.query,\n        newTail = _a.newTail;\n      var childConditions = builder(recursivePredicateFor(ModelType, allowRecursion));\n      if (!Array.isArray(childConditions)) {\n        throw new Error(\"Invalid predicate. `\" + op + \"` groups must return an array of child conditions.\");\n      }\n      // the customer will supply a child predicate, which apply to the `model.field`\n      // of the tail GroupCondition.\n      newTail === null || newTail === void 0 ? void 0 : newTail.operands.push(new GroupCondition(ModelType, field, undefined, op, childConditions.map(function (c) {\n        return internals(c);\n      })));\n      // FinalPredicate\n      return registerPredicateInternals(query);\n    };\n  });\n  // TODO: If revisiting this code, consider proxy.\n  link.not = function (builder) {\n    // not() will return a copy of the original link\n    // to head off mutability concerns.\n    var _a = copyLink(),\n      query = _a.query,\n      newTail = _a.newTail;\n    // unlike and() and or(), the customer will supply a \"singular\" child predicate.\n    // the difference being: not() does not accept an array of predicate-like objects.\n    // it negates only a *single* predicate subtree.\n    newTail === null || newTail === void 0 ? void 0 : newTail.operands.push(new GroupCondition(ModelType, field, undefined, 'not', [internals(builder(recursivePredicateFor(ModelType, allowRecursion)))]));\n    // A `FinalModelPredicate`.\n    // Return a thing that can no longer be extended, but instead used to `async filter(items)`\n    // or query storage: `.__query.fetch(storage)`.\n    return registerPredicateInternals(query);\n  };\n  var _loop_1 = function (fieldName) {\n    Object.defineProperty(link, fieldName, {\n      enumerable: true,\n      get: function () {\n        var def = ModelType.schema.allFields[fieldName];\n        if (!def.association) {\n          // we're looking at a value field. we need to return a\n          // \"field matcher object\", which contains all of the comparison\n          // functions ('eq', 'ne', 'gt', etc.), scoped to operate\n          // against the target field (fieldName).\n          return ops.reduce(function (fieldMatcher, operator) {\n            var _a;\n            return __assign(__assign({}, fieldMatcher), (_a = {}, _a[operator] = function () {\n              var operands = [];\n              for (var _i = 0; _i < arguments.length; _i++) {\n                operands[_i] = arguments[_i];\n              }\n              // build off a fresh copy of the existing `link`, just in case\n              // the same link is being used elsewhere by the customer.\n              var _a = copyLink(),\n                query = _a.query,\n                newTail = _a.newTail;\n              // normalize operands. if any of the values are `undefiend`, use\n              // `null` instead, because that's what will be stored cross-platform.\n              var normalizedOperands = operands.map(function (o) {\n                return o === undefined ? null : o;\n              });\n              // add the given condition to the link's TAIL node.\n              // remember: the base link might go N nodes deep! e.g.,\n              newTail === null || newTail === void 0 ? void 0 : newTail.operands.push(new FieldCondition(fieldName, operator, normalizedOperands));\n              // A `FinalModelPredicate`.\n              // Return a thing that can no longer be extended, but instead used to `async filter(items)`\n              // or query storage: `.__query.fetch(storage)`.\n              return registerPredicateInternals(query);\n            }, _a));\n          }, {});\n        } else {\n          if (!allowRecursion) {\n            throw new Error('Predication on releated models is not supported in this context.');\n          } else if (def.association.connectionType === 'BELONGS_TO' || def.association.connectionType === 'HAS_ONE' || def.association.connectionType === 'HAS_MANY') {\n            // the use has just typed '.someRelatedModel'. we need to given them\n            // back a predicate chain.\n            var relatedMeta = def.type.modelConstructor;\n            if (!relatedMeta) {\n              throw new Error('Related model metadata is missing. This is a bug! Please report it.');\n            }\n            // `Model.reletedModelField` returns a copy of the original link,\n            // and will contains copies of internal GroupConditions\n            // to head off mutability concerns.\n            var _a = __read(baseCondition.copy(tailCondition), 2),\n              newquery = _a[0],\n              oldtail = _a[1];\n            var newtail = new GroupCondition(relatedMeta, fieldName, def.association.connectionType, 'and', []);\n            // `oldtail` here refers to the *copy* of the old tail.\n            // so, it's safe to modify at this point. and we need to modify\n            // it to push the *new* tail onto the end of it.\n            oldtail.operands.push(newtail);\n            var newlink = recursivePredicateFor(relatedMeta, allowRecursion, undefined, newquery, newtail);\n            return newlink;\n          } else {\n            throw new Error(\"Related model definition doesn't have a typedef. This is a bug! Please report it.\");\n          }\n        }\n      }\n    });\n  };\n  // For each field on the model schema, we want to add a getter\n  // that creates the appropriate new `link` in the query chain.\n  // TODO: If revisiting, consider a proxy.\n  for (var fieldName in ModelType.schema.allFields) {\n    _loop_1(fieldName);\n  }\n  return link;\n}\nexport function predicateFor(ModelType) {\n  // the cast here is just a cheap way to reduce the surface area from\n  // the recursive type.\n  return recursivePredicateFor(ModelType, false);\n}","map":{"version":3,"names":["PredicateInternalsKey","ModelPredicateCreator","FlatModelPredicateCreator","comparisonKeys","ModelRelationship","asyncSome","asyncEvery","ops","__spread","predicateInternalsMap","Map","registerPredicateInternals","condition","key","finalKey","set","internals","has","Error","get","negations","and","or","not","eq","ne","gt","ge","lt","le","contains","notContains","FieldCondition","field","operator","operands","validate","prototype","copy","extract","undefined","toAST","_a","_b","negated","model","GroupCondition","fetch","storage","Promise","reject","matches","item","v","operations","_this","indexOf","beginsWith","startsWith","between","operation","result","argumentCount","count","argsClause","length","validations","e","getGroupId","seed","relationshipType","isOptimized","groupId","copied","extractedCopy","forEach","o","__read","operandCopy","extractedFromOperand","push","withFieldConditionsOnly","negate","negateChildren","filter","map","optimized","preserveNode","includes","operand","breadcrumb","resultGroups","groups","op","conditions","groups_1","__values","groups_1_1","next","g","value","relatives","_r","sent","relationship","from","allJoinConditions","relatives_1","e_2","relatives_1_1","done","relative","relativeConditions","i","localJoinFields","_l","remoteJoinFields","predicate","createFromAST","schema","query","builder","apply","toStoragePredicate","_d","_c","_f","_e","getPKValue","JSON","stringify","pkField","name","resultGroups_1","resultGroups_1_1","group","resultIndex","intersectWith","_g","e_4","keys","_h","k","delete","resultGroups_2","resultGroups_2_1","group_1","e_6","group_1_1","Array","values","ignoreFieldName","itemToCheck","Symbol","asyncIterator","itemToCheck_1","__asyncValues","singleItem","itemToCheck_1_1","c","toJSON","__assign","recursivePredicateFor","ModelType","allowRecursion","tail","starter","baseCondition","tailCondition","link","copyLink","newTail","newLink","childConditions","isArray","fieldName","Object","defineProperty","enumerable","def","allFields","association","reduce","fieldMatcher","_i","arguments","normalizedOperands","connectionType","relatedMeta","type","modelConstructor","newquery","oldtail","newtail","newlink","predicateFor"],"sources":["/Users/yannellym/Desktop/iwantapet/node_modules/@aws-amplify/datastore/src/predicates/next.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport {\n\tPersistentModel,\n\tModelFieldType,\n\tModelMeta,\n\tModelPredicate as StoragePredicate,\n\tAllFieldOperators,\n\tPredicateInternalsKey,\n\tV5ModelPredicate as ModelPredicate,\n\tRecursiveModelPredicate,\n\tRecursiveModelPredicateExtender,\n\tRecursiveModelPredicateAggregateExtender,\n} from '../types';\n\nimport {\n\tModelPredicateCreator as FlatModelPredicateCreator,\n\tcomparisonKeys,\n} from './index';\nimport { ExclusiveStorage as StorageAdapter } from '../storage/storage';\nimport { ModelRelationship } from '../storage/relationship';\nimport { asyncSome, asyncEvery } from '../util';\n\nconst ops = [...comparisonKeys] as AllFieldOperators[];\n\ntype GroupOperator = 'and' | 'or' | 'not';\n\ntype UntypedCondition = {\n\tfetch: (storage: StorageAdapter) => Promise<Record<string, any>[]>;\n\tmatches: (item: Record<string, any>) => Promise<boolean>;\n\tcopy(\n\t\textract?: GroupCondition\n\t): [UntypedCondition, GroupCondition | undefined];\n\ttoAST(): any;\n};\n\n/**\n * A map from keys (exposed to customers) to the internal predicate data\n * structures invoking code should not muck with.\n */\nconst predicateInternalsMap = new Map<PredicateInternalsKey, GroupCondition>();\n\n/**\n * Creates a link between a key (and generates a key if needed) and an internal\n * `GroupCondition`, which allows us to return a key object instead of the gory\n * conditions details to customers/invoking code.\n *\n * @param condition The internal condition to keep hidden.\n * @param key The object DataStore will use to find the internal condition.\n * If no key is given, an empty one is created.\n */\nconst registerPredicateInternals = (condition: GroupCondition, key?: any) => {\n\tconst finalKey = key || new PredicateInternalsKey();\n\tpredicateInternalsMap.set(finalKey, condition);\n\treturn finalKey;\n};\n\n/**\n * Takes a key object from `registerPredicateInternals()` to fetch an internal\n * `GroupCondition` object, which can then be used to query storage or\n * test/match objects.\n *\n * This indirection exists to hide `GroupCondition` from public interfaces, since\n * `GroupCondition` contains extra methods and properties that public callers\n * should not use.\n *\n * @param key A key object previously returned by `registerPredicateInternals()`\n */\nexport const internals = (key: any) => {\n\tif (!predicateInternalsMap.has(key)) {\n\t\tthrow new Error(\n\t\t\t\"Invalid predicate. Terminate your predicate with a valid condition (e.g., `p => p.field.eq('value')`) or pass `Predicates.ALL`.\"\n\t\t);\n\t}\n\treturn predicateInternalsMap.get(key)!;\n};\n\n/**\n * Maps operators to negated operators.\n * Used to facilitate propagation of negation down a tree of conditions.\n */\nconst negations = {\n\tand: 'or',\n\tor: 'and',\n\tnot: 'and',\n\teq: 'ne',\n\tne: 'eq',\n\tgt: 'le',\n\tge: 'lt',\n\tlt: 'ge',\n\tle: 'gt',\n\tcontains: 'notContains',\n\tnotContains: 'contains',\n};\n\n/**\n * A condition that can operate against a single \"primitive\" field of a model or item.\n * @member field The field of *some record* to test against.\n * @member operator The equality or comparison operator to use.\n * @member operands The operands for the equality/comparison check.\n */\nexport class FieldCondition {\n\tconstructor(\n\t\tpublic field: string,\n\t\tpublic operator: string,\n\t\tpublic operands: string[]\n\t) {\n\t\tthis.validate();\n\t}\n\n\t/**\n\t * Creates a copy of self.\n\t * @param extract Not used. Present only to fulfill the `UntypedCondition` interface.\n\t * @returns A new, identitical `FieldCondition`.\n\t */\n\tcopy(extract?: GroupCondition): [FieldCondition, GroupCondition | undefined] {\n\t\treturn [\n\t\t\tnew FieldCondition(this.field, this.operator, [...this.operands]),\n\t\t\tundefined,\n\t\t];\n\t}\n\n\t/**\n\t * Produces a tree structure similar to a graphql condition. The returned\n\t * structure is \"dumb\" and is intended for another query/condition\n\t * generation mechanism to interpret, such as the cloud or storage query\n\t * builders.\n\t *\n\t * E.g.,\n\t *\n\t * ```json\n\t * {\n\t * \t\"name\": {\n\t * \t\t\"eq\": \"robert\"\n\t * \t}\n\t * }\n\t * ```\n\t */\n\ttoAST() {\n\t\treturn {\n\t\t\t[this.field]: {\n\t\t\t\t[this.operator]:\n\t\t\t\t\tthis.operator === 'between'\n\t\t\t\t\t\t? [this.operands[0], this.operands[1]]\n\t\t\t\t\t\t: this.operands[0],\n\t\t\t},\n\t\t};\n\t}\n\n\t/**\n\t * Produces a new condition (`FieldCondition` or `GroupCondition`) that\n\t * matches the opposite of this condition.\n\t *\n\t * Intended to be used when applying De Morgan's Law, which can be done to\n\t * produce more efficient queries against the storage layer if a negation\n\t * appears in the query tree.\n\t *\n\t * For example:\n\t *\n\t * 1. `name.eq('robert')` becomes `name.ne('robert')`\n\t * 2. `price.between(100, 200)` becomes `m => m.or(m => [m.price.lt(100), m.price.gt(200)])`\n\t *\n\t * @param model The model meta to use when construction a new `GroupCondition`\n\t * for cases where the negation requires multiple `FieldCondition`'s.\n\t */\n\tnegated(model: ModelMeta<any>) {\n\t\tif (this.operator === 'between') {\n\t\t\treturn new GroupCondition(model, undefined, undefined, 'or', [\n\t\t\t\tnew FieldCondition(this.field, 'lt', [this.operands[0]]),\n\t\t\t\tnew FieldCondition(this.field, 'gt', [this.operands[1]]),\n\t\t\t]);\n\t\t} else if (this.operator === 'beginsWith') {\n\t\t\t// beginsWith negation doesn't have a good, safe optimation right now.\n\t\t\t// just re-wrap it in negation. The adapter will have to scan-and-filter,\n\t\t\t// as is likely optimal for negated beginsWith conditions *anyway*.\n\t\t\treturn new GroupCondition(model, undefined, undefined, 'not', [\n\t\t\t\tnew FieldCondition(this.field, 'beginsWith', [this.operands[0]]),\n\t\t\t]);\n\t\t} else {\n\t\t\treturn new FieldCondition(\n\t\t\t\tthis.field,\n\t\t\t\tnegations[this.operator],\n\t\t\t\tthis.operands\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Not implemented. Not needed. GroupCondition instead consumes FieldConditions and\n\t * transforms them into legacy predicates. (*For now.*)\n\t * @param storage N/A. If ever implemented, the storage adapter to query.\n\t * @returns N/A. If ever implemented, return items from `storage` that match.\n\t */\n\tasync fetch(storage: StorageAdapter): Promise<Record<string, any>[]> {\n\t\treturn Promise.reject('No implementation needed [yet].');\n\t}\n\n\t/**\n\t * Determins whether a given item matches the expressed condition.\n\t * @param item The item to test.\n\t * @returns `Promise<boolean>`, `true` if matches; `false` otherwise.\n\t */\n\tasync matches(item: Record<string, any>): Promise<boolean> {\n\t\tconst v = item[this.field];\n\t\tconst operations = {\n\t\t\teq: () => v === this.operands[0],\n\t\t\tne: () => v !== this.operands[0],\n\t\t\tgt: () => v > this.operands[0],\n\t\t\tge: () => v >= this.operands[0],\n\t\t\tlt: () => v < this.operands[0],\n\t\t\tle: () => v <= this.operands[0],\n\t\t\tcontains: () => v?.indexOf(this.operands[0]) > -1,\n\t\t\tnotContains: () => (!v ? true : v.indexOf(this.operands[0]) === -1),\n\t\t\tbeginsWith: () => v?.startsWith(this.operands[0]),\n\t\t\tbetween: () => v >= this.operands[0] && v <= this.operands[1],\n\t\t};\n\t\tconst operation = operations[this.operator as keyof typeof operations];\n\t\tif (operation) {\n\t\t\tconst result = operation();\n\t\t\treturn result;\n\t\t} else {\n\t\t\tthrow new Error(`Invalid operator given: ${this.operator}`);\n\t\t}\n\t}\n\n\t/**\n\t * Checks `this.operands` for compatibility with `this.operator`.\n\t */\n\tvalidate(): void {\n\t\t/**\n\t\t * Creates a validator that checks for a particular `operands` count.\n\t\t * Throws an exception if the `count` disagrees with `operands.length`.\n\t\t * @param count The number of `operands` expected.\n\t\t */\n\t\tconst argumentCount = count => {\n\t\t\tconst argsClause = count === 1 ? 'argument is' : 'arguments are';\n\t\t\treturn () => {\n\t\t\t\tif (this.operands.length !== count) {\n\t\t\t\t\treturn `Exactly ${count} ${argsClause} required.`;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t\t// NOTE: validations should return a message on failure.\n\t\t// hence, they should be \"joined\" together with logical OR's\n\t\t// as seen in the `between:` entry.\n\t\tconst validations = {\n\t\t\teq: argumentCount(1),\n\t\t\tne: argumentCount(1),\n\t\t\tgt: argumentCount(1),\n\t\t\tge: argumentCount(1),\n\t\t\tlt: argumentCount(1),\n\t\t\tle: argumentCount(1),\n\t\t\tcontains: argumentCount(1),\n\t\t\tnotContains: argumentCount(1),\n\t\t\tbeginsWith: argumentCount(1),\n\t\t\tbetween: () =>\n\t\t\t\targumentCount(2)() ||\n\t\t\t\t(this.operands[0] > this.operands[1]\n\t\t\t\t\t? 'The first argument must be less than or equal to the second argument.'\n\t\t\t\t\t: null),\n\t\t};\n\t\tconst validate = validations[this.operator as keyof typeof validations];\n\t\tif (validate) {\n\t\t\tconst e = validate();\n\t\t\tif (typeof e === 'string')\n\t\t\t\tthrow new Error(`Incorrect usage of \\`${this.operator}()\\`: ${e}`);\n\t\t} else {\n\t\t\tthrow new Error(`Non-existent operator: \\`${this.operator}()\\``);\n\t\t}\n\t}\n}\n\n/**\n * Small utility function to generate a monotonically increasing ID.\n * Used by GroupCondition to help keep track of which group is doing what,\n * when, and where during troubleshooting.\n */\nconst getGroupId = (() => {\n\tlet seed = 1;\n\treturn () => `group_${seed++}`;\n})();\n\n/**\n * A set of sub-conditions to operate against a model, optionally scoped to\n * a specific field, combined with the given operator (one of `and`, `or`, or `not`).\n * @member groupId Used to distinguish between GroupCondition instances for\n * debugging and troublehsooting.\n * @member model A metadata object that tells GroupCondition what to query and how.\n * @member field The field on the model that the sub-conditions apply to.\n * @member operator How to group child conditions together.\n * @member operands The child conditions.\n */\nexport class GroupCondition {\n\t// `groupId` was used for development/debugging.\n\t// Should we leave this in for future troubleshooting?\n\tpublic groupId = getGroupId();\n\n\tconstructor(\n\t\t/**\n\t\t * The `ModelMeta` of the model to query and/or filter against.\n\t\t * Expected to contain:\n\t\t *\n\t\t * ```js\n\t\t * {\n\t\t * \tbuilder: ModelConstructor,\n\t\t * \tschema: SchemaModel,\n\t\t * \tpkField: string[]\n\t\t * }\n\t\t * ```\n\t\t */\n\t\tpublic model: ModelMeta<any>,\n\n\t\t/**\n\t\t * If populated, this group specifices a condition on a relationship.\n\t\t *\n\t\t * If `field` does *not* point to a related model, that's an error. It\n\t\t * could indicate that the `GroupCondition` was instantiated with bad\n\t\t * data, or that the model metadata is incorrect.\n\t\t */\n\t\tpublic field: string | undefined,\n\n\t\t/**\n\t\t * If a `field` is given, whether the relationship is a `HAS_ONE`,\n\t\t * 'HAS_MANY`, or `BELONGS_TO`.\n\t\t *\n\t\t * TODO: Remove this and replace with derivation using\n\t\t * `ModelRelationship.from(this.model, this.field).relationship`;\n\t\t */\n\t\tpublic relationshipType: string | undefined,\n\n\t\t/**\n\t\t *\n\t\t */\n\t\tpublic operator: GroupOperator,\n\n\t\t/**\n\t\t *\n\t\t */\n\t\tpublic operands: UntypedCondition[],\n\n\t\t/**\n\t\t * Whether this GroupCondition is the result of an optimize call.\n\t\t *\n\t\t * This is used to guard against infinitely fetch -> optimize -> fetch\n\t\t * recursion.\n\t\t */\n\t\tpublic isOptimized: boolean = false\n\t) {}\n\n\t/**\n\t * Returns a copy of a GroupCondition, which also returns the copy of a\n\t * given reference node to \"extract\".\n\t * @param extract A node of interest. Its copy will *also* be returned if the node exists.\n\t * @returns [The full copy, the copy of `extract` | undefined]\n\t */\n\tcopy(extract?: GroupCondition): [GroupCondition, GroupCondition | undefined] {\n\t\tconst copied = new GroupCondition(\n\t\t\tthis.model,\n\t\t\tthis.field,\n\t\t\tthis.relationshipType,\n\t\t\tthis.operator,\n\t\t\t[]\n\t\t);\n\n\t\tlet extractedCopy: GroupCondition | undefined =\n\t\t\textract === this ? copied : undefined;\n\n\t\tthis.operands.forEach(o => {\n\t\t\tconst [operandCopy, extractedFromOperand] = o.copy(extract);\n\t\t\tcopied.operands.push(operandCopy);\n\t\t\textractedCopy = extractedCopy || extractedFromOperand;\n\t\t});\n\n\t\treturn [copied, extractedCopy];\n\t}\n\n\t/**\n\t * Creates a new `GroupCondition` that contains only the local field conditions,\n\t * omitting related model conditions. That resulting `GroupCondition` can be\n\t * used to produce predicates that are compatible with the storage adapters and\n\t * Cloud storage.\n\t *\n\t * @param negate Whether the condition tree should be negated according\n\t * to De Morgan's law.\n\t */\n\twithFieldConditionsOnly(negate: boolean) {\n\t\tconst negateChildren = negate !== (this.operator === 'not');\n\t\treturn new GroupCondition(\n\t\t\tthis.model,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\t(negate ? negations[this.operator] : this.operator) as\n\t\t\t\t| 'or'\n\t\t\t\t| 'and'\n\t\t\t\t| 'not',\n\t\t\tthis.operands\n\t\t\t\t.filter(o => o instanceof FieldCondition)\n\t\t\t\t.map(o =>\n\t\t\t\t\tnegateChildren ? (o as FieldCondition).negated(this.model) : o\n\t\t\t\t)\n\t\t);\n\t}\n\n\t/**\n\t * Returns a version of the predicate tree with unnecessary logical groups\n\t * condensed and merged together. This is intended to create a dense tree\n\t * with leaf nodes (`FieldCondition`'s) aggregated under as few group conditions\n\t * as possible for the most efficient fetching possible -- it allows `fetch()`.\n\t *\n\t * E.g. a grouping like this:\n\t *\n\t * ```yaml\n\t * and:\n\t * \tand:\n\t * \t\tid:\n\t * \t\t\teq: \"abc\"\n\t * \tand:\n\t * \t\tname:\n\t * \t\t\teq: \"xyz\"\n\t * ```\n\t *\n\t * Will become this:\n\t *\n\t * ```yaml\n\t * and:\n\t * \tid:\n\t * \t\teq: \"abc\"\n\t * \tname:\n\t * \t\teq: \"xyz\"\n\t * ```\n\t *\n\t * This allows `fetch()` to pass both the `id` and `name` conditions to the adapter\n\t * together, which can then decide what index to use based on both fields together.\n\t *\n\t * @param preserveNode Whether to preserve the current node and to explicitly not eliminate\n\t * it during optimization. Used internally to preserve the root node and children of\n\t * `not` groups. `not` groups will always have a single child, so there's nothing to\n\t * optimize below a `not` (for now), and it makes the query logic simpler later.\n\t */\n\toptimized(preserveNode = true): UntypedCondition {\n\t\tconst operands = this.operands.map(o =>\n\t\t\to instanceof GroupCondition ? o.optimized(this.operator === 'not') : o\n\t\t);\n\n\t\t// we're only collapsing and/or groups that contains a single child for now,\n\t\t// because they're much more common and much more trivial to collapse. basically,\n\t\t// an `and`/`or` that contains a single child doesn't require the layer of\n\t\t// logical grouping.\n\t\tif (\n\t\t\t!preserveNode &&\n\t\t\t['and', 'or'].includes(this.operator) &&\n\t\t\t!this.field &&\n\t\t\toperands.length === 1\n\t\t) {\n\t\t\tconst operand = operands[0];\n\t\t\tif (operand instanceof FieldCondition) {\n\t\t\t\t// between conditions should NOT be passed up the chain. if they\n\t\t\t\t// need to be *negated* later, it is important that they be properly\n\t\t\t\t// contained in an AND group. when de morgan's law is applied, the\n\t\t\t\t// conditions are reversed and the AND group flips to an OR. this\n\t\t\t\t// doesn't work right if the a `between` doesn't live in an AND group.\n\t\t\t\tif (operand.operator !== 'between') {\n\t\t\t\t\treturn operand;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn operand;\n\t\t\t}\n\t\t}\n\n\t\treturn new GroupCondition(\n\t\t\tthis.model,\n\t\t\tthis.field,\n\t\t\tthis.relationshipType,\n\t\t\tthis.operator,\n\t\t\toperands,\n\t\t\ttrue\n\t\t);\n\t}\n\n\t/**\n\t * Fetches matching records from a given storage adapter using legacy predicates (for now).\n\t * @param storage The storage adapter this predicate will query against.\n\t * @param breadcrumb For debugging/troubleshooting. A list of the `groupId`'s this\n\t * GroupdCondition.fetch is nested within.\n\t * @param negate Whether to match on the `NOT` of `this`.\n\t * @returns An `Promise` of `any[]` from `storage` matching the child conditions.\n\t */\n\tasync fetch(\n\t\tstorage: StorageAdapter,\n\t\tbreadcrumb: string[] = [],\n\t\tnegate = false\n\t): Promise<Record<string, any>[]> {\n\t\tif (!this.isOptimized) {\n\t\t\treturn this.optimized().fetch(storage);\n\t\t}\n\n\t\tconst resultGroups: Array<Record<string, any>[]> = [];\n\n\t\tconst operator = (negate ? negations[this.operator] : this.operator) as\n\t\t\t| 'or'\n\t\t\t| 'and'\n\t\t\t| 'not';\n\n\t\tconst negateChildren = negate !== (this.operator === 'not');\n\n\t\t/**\n\t\t * Conditions that must be branched out and used to generate a base, \"candidate\"\n\t\t * result set.\n\t\t *\n\t\t * If `field` is populated, these groups select *related* records, and the base,\n\t\t * candidate results are selected to match those.\n\t\t */\n\t\tconst groups = this.operands.filter(\n\t\t\top => op instanceof GroupCondition\n\t\t) as GroupCondition[];\n\n\t\t/**\n\t\t * Simple conditions that must match the target model of `this`.\n\t\t */\n\t\tconst conditions = this.operands.filter(\n\t\t\top => op instanceof FieldCondition\n\t\t) as FieldCondition[];\n\n\t\tfor (const g of groups) {\n\t\t\tconst relatives = await g.fetch(\n\t\t\t\tstorage,\n\t\t\t\t[...breadcrumb, this.groupId],\n\t\t\t\tnegateChildren\n\t\t\t);\n\n\t\t\t// no relatives -> no need to attempt to perform a \"join\" query for\n\t\t\t// candidate results:\n\t\t\t//\n\t\t\t// select a.* from a,b where b.id in EMPTY_SET ==> EMPTY_SET\n\t\t\t//\n\t\t\t// Additionally, the entire (sub)-query can be short-circuited if\n\t\t\t// the operator is `AND`. Illustrated in SQL:\n\t\t\t//\n\t\t\t// select a.* from a where\n\t\t\t//   id in [a,b,c]\n\t\t\t//     AND                        <\n\t\t\t//   id in EMTPY_SET            <<< Look!\n\t\t\t//     AND                        <\n\t\t\t//   id in [x,y,z]\n\t\t\t//\n\t\t\t// YIELDS: EMPTY_SET           // <-- Easy peasy. Lemon squeezy.\n\t\t\t//\n\t\t\tif (relatives.length === 0) {\n\t\t\t\t// aggressively short-circuit as soon as we know the group condition will fail\n\t\t\t\tif (operator === 'and') {\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\n\t\t\t\t// less aggressive short-circuit if we know the relatives will produce no\n\t\t\t\t// candidate results; but aren't sure yet how this affects the group condition.\n\t\t\t\tresultGroups.push([]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (g.field) {\n\t\t\t\t// `relatives` are actual relatives. We'll skim them for FK query values.\n\t\t\t\t// Use the relatives to add candidate result sets (`resultGroups`)\n\n\t\t\t\tconst relationship = ModelRelationship.from(this.model, g.field);\n\n\t\t\t\ttype JoinCondition = { [x: string]: { eq: any } };\n\t\t\t\tif (relationship) {\n\t\t\t\t\tconst allJoinConditions: { and: JoinCondition[] }[] = [];\n\t\t\t\t\tfor (const relative of relatives) {\n\t\t\t\t\t\tconst relativeConditions: JoinCondition[] = [];\n\t\t\t\t\t\tfor (let i = 0; i < relationship.localJoinFields.length; i++) {\n\t\t\t\t\t\t\trelativeConditions.push({\n\t\t\t\t\t\t\t\t[relationship.localJoinFields[i]]: {\n\t\t\t\t\t\t\t\t\teq: relative[relationship.remoteJoinFields[i]],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tallJoinConditions.push({ and: relativeConditions });\n\t\t\t\t\t}\n\n\t\t\t\t\tconst predicate = FlatModelPredicateCreator.createFromAST(\n\t\t\t\t\t\tthis.model.schema,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tor: allJoinConditions,\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t\tresultGroups.push(await storage.query(this.model.builder, predicate));\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error('Missing field metadata.');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// relatives are not actually relatives. they're candidate results.\n\t\t\t\tresultGroups.push(relatives);\n\t\t\t}\n\t\t}\n\n\t\t// if conditions is empty at this point, child predicates found no matches.\n\t\t// i.e., we can stop looking and return empty.\n\t\tif (conditions.length > 0) {\n\t\t\tconst predicate =\n\t\t\t\tthis.withFieldConditionsOnly(negateChildren).toStoragePredicate();\n\t\t\tresultGroups.push(await storage.query(this.model.builder, predicate));\n\t\t} else if (conditions.length === 0 && resultGroups.length === 0) {\n\t\t\tresultGroups.push(await storage.query(this.model.builder));\n\t\t}\n\n\t\t// PK might be a single field, like `id`, or it might be several fields.\n\t\t// so, we'll need to extract the list of PK fields from an object\n\t\t// and stringify the list for easy comparison / merging.\n\t\tconst getPKValue = item =>\n\t\t\tJSON.stringify(this.model.pkField.map(name => item[name]));\n\n\t\t// will be used for intersecting or unioning results\n\t\tlet resultIndex: Map<string, Record<string, any>> | undefined;\n\n\t\tif (operator === 'and') {\n\t\t\tif (resultGroups.length === 0) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\t// for each group, we intersect, removing items from the result index\n\t\t\t// that aren't present in each subsequent group.\n\t\t\tfor (const group of resultGroups) {\n\t\t\t\tif (resultIndex === undefined) {\n\t\t\t\t\tresultIndex = new Map(group.map(item => [getPKValue(item), item]));\n\t\t\t\t} else {\n\t\t\t\t\tconst intersectWith = new Map<string, Record<string, any>>(\n\t\t\t\t\t\tgroup.map(item => [getPKValue(item), item])\n\t\t\t\t\t);\n\t\t\t\t\tfor (const k of resultIndex.keys()) {\n\t\t\t\t\t\tif (!intersectWith.has(k)) {\n\t\t\t\t\t\t\tresultIndex.delete(k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (operator === 'or' || operator === 'not') {\n\t\t\t// it's OK to handle NOT here, because NOT must always only negate\n\t\t\t// a single child predicate. NOT logic will have been distributed down\n\t\t\t// to the leaf conditions already.\n\n\t\t\tresultIndex = new Map();\n\n\t\t\t// just merge the groups, performing DISTINCT-ification by ID.\n\t\t\tfor (const group of resultGroups) {\n\t\t\t\tfor (const item of group) {\n\t\t\t\t\tresultIndex.set(getPKValue(item), item);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn Array.from(resultIndex?.values() || []);\n\t}\n\n\t/**\n\t * Determines whether a single item matches the conditions of `this`.\n\t * When checking the target `item`'s properties, each property will be `await`'d\n\t * to ensure lazy-loading is respected where applicable.\n\t * @param item The item to match against.\n\t * @param ignoreFieldName Tells `match()` that the field name has already been dereferenced.\n\t * (Used for iterating over children on HAS_MANY checks.)\n\t * @returns A boolean (promise): `true` if matched, `false` otherwise.\n\t */\n\tasync matches(\n\t\titem: Record<string, any>,\n\t\tignoreFieldName: boolean = false\n\t): Promise<boolean> {\n\t\tconst itemToCheck =\n\t\t\tthis.field && !ignoreFieldName ? await item[this.field] : item;\n\n\t\t// if there is no item to check, we can stop recursing immediately.\n\t\t// a condition cannot match against an item that does not exist. this\n\t\t// can occur when `item.field` is optional in the schema.\n\t\tif (!itemToCheck) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (\n\t\t\tthis.relationshipType === 'HAS_MANY' &&\n\t\t\ttypeof itemToCheck[Symbol.asyncIterator] === 'function'\n\t\t) {\n\t\t\tfor await (const singleItem of itemToCheck) {\n\t\t\t\tif (await this.matches(singleItem, true)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.operator === 'or') {\n\t\t\treturn asyncSome(this.operands, c => c.matches(itemToCheck));\n\t\t} else if (this.operator === 'and') {\n\t\t\treturn asyncEvery(this.operands, c => c.matches(itemToCheck));\n\t\t} else if (this.operator === 'not') {\n\t\t\tif (this.operands.length !== 1) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Invalid arguments! `not()` accepts exactly one predicate expression.'\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn !(await this.operands[0].matches(itemToCheck));\n\t\t} else {\n\t\t\tthrow new Error('Invalid group operator!');\n\t\t}\n\t}\n\n\t/**\n\t * Tranfsorm to a AppSync GraphQL compatible AST.\n\t * (Does not support filtering in nested types.)\n\t */\n\ttoAST() {\n\t\tif (this.field)\n\t\t\tthrow new Error('Nested type conditions are not supported!');\n\n\t\treturn {\n\t\t\t[this.operator]: this.operands.map(operand => operand.toAST()),\n\t\t};\n\t}\n\n\t/**\n\t * Turn this predicate group into something a storage adapter\n\t * understands how to use.\n\t */\n\ttoStoragePredicate<T>(): StoragePredicate<T> {\n\t\treturn FlatModelPredicateCreator.createFromAST<T>(\n\t\t\tthis.model.schema,\n\t\t\tthis.toAST()\n\t\t) as StoragePredicate<T>;\n\t}\n\n\t/**\n\t * A JSON representation that's good for debugging.\n\t */\n\ttoJSON() {\n\t\treturn {\n\t\t\t...this,\n\t\t\tmodel: this.model.schema.name,\n\t\t};\n\t}\n}\n\n/**\n * Creates a \"seed\" predicate that can be used to build an executable condition.\n * This is used in `query()`, for example, to seed customer- E.g.,\n *\n * ```\n * const p = predicateFor({builder: modelConstructor, schema: modelSchema, pkField: string[]});\n * p.and(child => [\n *   child.field.eq('whatever'),\n *   child.childModel.childField.eq('whatever else'),\n *   child.childModel.or(child => [\n *     child.otherField.contains('x'),\n *     child.otherField.contains('y'),\n *     child.otherField.contains('z'),\n *   ])\n * ])\n * ```\n *\n * `predicateFor()` returns objecst with recursive getters. To facilitate this,\n * a `query` and `tail` can be provided to \"accumulate\" nested conditions.\n *\n * @param ModelType The ModelMeta used to build child properties.\n * @param field Scopes the query branch to a field.\n * @param query A base query to build on. Omit to start a new query.\n * @param tail The point in an existing `query` to attach new conditions to.\n * @returns A ModelPredicate (builder) that customers can create queries with.\n * (As shown in function description.)\n */\nexport function recursivePredicateFor<T extends PersistentModel>(\n\tModelType: ModelMeta<T>,\n\tallowRecursion: boolean = true,\n\tfield?: string,\n\tquery?: GroupCondition,\n\ttail?: GroupCondition\n): RecursiveModelPredicate<T> & PredicateInternalsKey {\n\t// to be used if we don't have a base query or tail to build onto\n\tconst starter = new GroupCondition(ModelType, field, undefined, 'and', []);\n\n\tconst baseCondition = query && tail ? query : starter;\n\tconst tailCondition = query && tail ? tail : starter;\n\n\t// our eventual return object, which can be built upon.\n\t// next steps will be to add or(), and(), not(), and field.op() methods.\n\tconst link = {} as RecursiveModelPredicate<T>;\n\n\t// so it can be looked up later with in the internals when processing conditions.\n\tregisterPredicateInternals(baseCondition, link);\n\n\tconst copyLink = () => {\n\t\tconst [query, newTail] = baseCondition.copy(tailCondition);\n\t\tconst newLink = recursivePredicateFor(\n\t\t\tModelType,\n\t\t\tallowRecursion,\n\t\t\tundefined,\n\t\t\tquery,\n\t\t\tnewTail\n\t\t);\n\t\treturn { query, newTail, newLink };\n\t};\n\n\t// Adds .or() and .and() methods to the link.\n\t// TODO: If revisiting this code, consider writing a Proxy instead.\n\t(['and', 'or'] as const).forEach(op => {\n\t\tlink[op] = (builder: RecursiveModelPredicateAggregateExtender<T>) => {\n\t\t\t// or() and and() will return a copy of the original link\n\t\t\t// to head off mutability concerns.\n\t\t\tconst { query, newTail } = copyLink();\n\n\t\t\tconst childConditions = builder(\n\t\t\t\trecursivePredicateFor(ModelType, allowRecursion)\n\t\t\t);\n\t\t\tif (!Array.isArray(childConditions)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Invalid predicate. \\`${op}\\` groups must return an array of child conditions.`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// the customer will supply a child predicate, which apply to the `model.field`\n\t\t\t// of the tail GroupCondition.\n\t\t\tnewTail?.operands.push(\n\t\t\t\tnew GroupCondition(\n\t\t\t\t\tModelType,\n\t\t\t\t\tfield,\n\t\t\t\t\tundefined,\n\t\t\t\t\top as 'and' | 'or',\n\t\t\t\t\tchildConditions.map(c => internals(c))\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// FinalPredicate\n\t\t\treturn registerPredicateInternals(query);\n\t\t};\n\t});\n\n\t// TODO: If revisiting this code, consider proxy.\n\tlink.not = (\n\t\tbuilder: RecursiveModelPredicateExtender<T>\n\t): PredicateInternalsKey => {\n\t\t// not() will return a copy of the original link\n\t\t// to head off mutability concerns.\n\t\tconst { query, newTail } = copyLink();\n\n\t\t// unlike and() and or(), the customer will supply a \"singular\" child predicate.\n\t\t// the difference being: not() does not accept an array of predicate-like objects.\n\t\t// it negates only a *single* predicate subtree.\n\t\tnewTail?.operands.push(\n\t\t\tnew GroupCondition(ModelType, field, undefined, 'not', [\n\t\t\t\tinternals(builder(recursivePredicateFor(ModelType, allowRecursion))),\n\t\t\t])\n\t\t);\n\n\t\t// A `FinalModelPredicate`.\n\t\t// Return a thing that can no longer be extended, but instead used to `async filter(items)`\n\t\t// or query storage: `.__query.fetch(storage)`.\n\t\treturn registerPredicateInternals(query);\n\t};\n\n\t// For each field on the model schema, we want to add a getter\n\t// that creates the appropriate new `link` in the query chain.\n\t// TODO: If revisiting, consider a proxy.\n\tfor (const fieldName in ModelType.schema.allFields) {\n\t\tObject.defineProperty(link, fieldName, {\n\t\t\tenumerable: true,\n\t\t\tget: () => {\n\t\t\t\tconst def = ModelType.schema.allFields![fieldName];\n\n\t\t\t\tif (!def.association) {\n\t\t\t\t\t// we're looking at a value field. we need to return a\n\t\t\t\t\t// \"field matcher object\", which contains all of the comparison\n\t\t\t\t\t// functions ('eq', 'ne', 'gt', etc.), scoped to operate\n\t\t\t\t\t// against the target field (fieldName).\n\t\t\t\t\treturn ops.reduce((fieldMatcher, operator) => {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t...fieldMatcher,\n\n\t\t\t\t\t\t\t// each operator on the fieldMatcher objcect is a function.\n\t\t\t\t\t\t\t// when the customer calls the function, it returns a new link\n\t\t\t\t\t\t\t// in the chain -- for now -- this is the \"leaf\" link that\n\t\t\t\t\t\t\t// cannot be further extended.\n\t\t\t\t\t\t\t[operator]: (...operands: any[]) => {\n\t\t\t\t\t\t\t\t// build off a fresh copy of the existing `link`, just in case\n\t\t\t\t\t\t\t\t// the same link is being used elsewhere by the customer.\n\t\t\t\t\t\t\t\tconst { query, newTail } = copyLink();\n\n\t\t\t\t\t\t\t\t// normalize operands. if any of the values are `undefiend`, use\n\t\t\t\t\t\t\t\t// `null` instead, because that's what will be stored cross-platform.\n\t\t\t\t\t\t\t\tconst normalizedOperands = operands.map(o =>\n\t\t\t\t\t\t\t\t\to === undefined ? null : o\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t// add the given condition to the link's TAIL node.\n\t\t\t\t\t\t\t\t// remember: the base link might go N nodes deep! e.g.,\n\t\t\t\t\t\t\t\tnewTail?.operands.push(\n\t\t\t\t\t\t\t\t\tnew FieldCondition(fieldName, operator, normalizedOperands)\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t// A `FinalModelPredicate`.\n\t\t\t\t\t\t\t\t// Return a thing that can no longer be extended, but instead used to `async filter(items)`\n\t\t\t\t\t\t\t\t// or query storage: `.__query.fetch(storage)`.\n\t\t\t\t\t\t\t\treturn registerPredicateInternals(query);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t};\n\t\t\t\t\t}, {});\n\t\t\t\t} else {\n\t\t\t\t\tif (!allowRecursion) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Predication on releated models is not supported in this context.'\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tdef.association.connectionType === 'BELONGS_TO' ||\n\t\t\t\t\t\tdef.association.connectionType === 'HAS_ONE' ||\n\t\t\t\t\t\tdef.association.connectionType === 'HAS_MANY'\n\t\t\t\t\t) {\n\t\t\t\t\t\t// the use has just typed '.someRelatedModel'. we need to given them\n\t\t\t\t\t\t// back a predicate chain.\n\n\t\t\t\t\t\tconst relatedMeta = (def.type as ModelFieldType).modelConstructor;\n\t\t\t\t\t\tif (!relatedMeta) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t'Related model metadata is missing. This is a bug! Please report it.'\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// `Model.reletedModelField` returns a copy of the original link,\n\t\t\t\t\t\t// and will contains copies of internal GroupConditions\n\t\t\t\t\t\t// to head off mutability concerns.\n\t\t\t\t\t\tconst [newquery, oldtail] = baseCondition.copy(tailCondition);\n\t\t\t\t\t\tconst newtail = new GroupCondition(\n\t\t\t\t\t\t\trelatedMeta,\n\t\t\t\t\t\t\tfieldName,\n\t\t\t\t\t\t\tdef.association.connectionType,\n\t\t\t\t\t\t\t'and',\n\t\t\t\t\t\t\t[]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// `oldtail` here refers to the *copy* of the old tail.\n\t\t\t\t\t\t// so, it's safe to modify at this point. and we need to modify\n\t\t\t\t\t\t// it to push the *new* tail onto the end of it.\n\t\t\t\t\t\t(oldtail as GroupCondition).operands.push(newtail);\n\t\t\t\t\t\tconst newlink = recursivePredicateFor(\n\t\t\t\t\t\t\trelatedMeta,\n\t\t\t\t\t\t\tallowRecursion,\n\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\tnewquery,\n\t\t\t\t\t\t\tnewtail\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn newlink;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\"Related model definition doesn't have a typedef. This is a bug! Please report it.\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t}\n\n\treturn link;\n}\n\nexport function predicateFor<T extends PersistentModel>(\n\tModelType: ModelMeta<T>\n): ModelPredicate<T> & PredicateInternalsKey {\n\t// the cast here is just a cheap way to reduce the surface area from\n\t// the recursive type.\n\treturn recursivePredicateFor(ModelType, false) as any as ModelPredicate<T>;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}