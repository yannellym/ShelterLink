{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { isAWSDate, isAWSTime, isAWSDateTime, isAWSTimestamp, isAWSEmail, isAWSJSON, isAWSURL, isAWSPhone, isAWSIPAddress, extractPrimaryKeyFieldNames } from './util';\nexport function isSchemaModel(obj) {\n  return obj && obj.pluralName !== undefined;\n}\nexport function isSchemaModelWithAttributes(m) {\n  return isSchemaModel(m) && m.attributes !== undefined;\n}\nexport function isAssociatedWith(obj) {\n  return obj && obj.associatedWith;\n}\nexport function isTargetNameAssociation(obj) {\n  return (obj === null || obj === void 0 ? void 0 : obj.targetName) || (obj === null || obj === void 0 ? void 0 : obj.targetNames);\n}\nexport function isFieldAssociation(obj, fieldName) {\n  var _a, _b;\n  return (_b = (_a = obj === null || obj === void 0 ? void 0 : obj.fields[fieldName]) === null || _a === void 0 ? void 0 : _a.association) === null || _b === void 0 ? void 0 : _b.connectionType;\n}\nexport function isModelAttributeAuth(attr) {\n  return attr.type === 'auth' && attr.properties && attr.properties.rules && attr.properties.rules.length > 0;\n}\nexport function isModelAttributeKey(attr) {\n  return attr.type === 'key' && attr.properties && attr.properties.fields && attr.properties.fields.length > 0;\n}\nexport function isModelAttributePrimaryKey(attr) {\n  return isModelAttributeKey(attr) && attr.properties.name === undefined;\n}\nexport function isModelAttributeCompositeKey(attr) {\n  return isModelAttributeKey(attr) && attr.properties.name !== undefined && attr.properties.fields.length > 2;\n}\nexport var ModelAttributeAuthAllow;\n(function (ModelAttributeAuthAllow) {\n  ModelAttributeAuthAllow[\"CUSTOM\"] = \"custom\";\n  ModelAttributeAuthAllow[\"OWNER\"] = \"owner\";\n  ModelAttributeAuthAllow[\"GROUPS\"] = \"groups\";\n  ModelAttributeAuthAllow[\"PRIVATE\"] = \"private\";\n  ModelAttributeAuthAllow[\"PUBLIC\"] = \"public\";\n})(ModelAttributeAuthAllow || (ModelAttributeAuthAllow = {}));\nexport var ModelAttributeAuthProvider;\n(function (ModelAttributeAuthProvider) {\n  ModelAttributeAuthProvider[\"FUNCTION\"] = \"function\";\n  ModelAttributeAuthProvider[\"USER_POOLS\"] = \"userPools\";\n  ModelAttributeAuthProvider[\"OIDC\"] = \"oidc\";\n  ModelAttributeAuthProvider[\"IAM\"] = \"iam\";\n  ModelAttributeAuthProvider[\"API_KEY\"] = \"apiKey\";\n})(ModelAttributeAuthProvider || (ModelAttributeAuthProvider = {}));\nexport var GraphQLScalarType;\n(function (GraphQLScalarType) {\n  GraphQLScalarType[GraphQLScalarType[\"ID\"] = 0] = \"ID\";\n  GraphQLScalarType[GraphQLScalarType[\"String\"] = 1] = \"String\";\n  GraphQLScalarType[GraphQLScalarType[\"Int\"] = 2] = \"Int\";\n  GraphQLScalarType[GraphQLScalarType[\"Float\"] = 3] = \"Float\";\n  GraphQLScalarType[GraphQLScalarType[\"Boolean\"] = 4] = \"Boolean\";\n  GraphQLScalarType[GraphQLScalarType[\"AWSDate\"] = 5] = \"AWSDate\";\n  GraphQLScalarType[GraphQLScalarType[\"AWSTime\"] = 6] = \"AWSTime\";\n  GraphQLScalarType[GraphQLScalarType[\"AWSDateTime\"] = 7] = \"AWSDateTime\";\n  GraphQLScalarType[GraphQLScalarType[\"AWSTimestamp\"] = 8] = \"AWSTimestamp\";\n  GraphQLScalarType[GraphQLScalarType[\"AWSEmail\"] = 9] = \"AWSEmail\";\n  GraphQLScalarType[GraphQLScalarType[\"AWSJSON\"] = 10] = \"AWSJSON\";\n  GraphQLScalarType[GraphQLScalarType[\"AWSURL\"] = 11] = \"AWSURL\";\n  GraphQLScalarType[GraphQLScalarType[\"AWSPhone\"] = 12] = \"AWSPhone\";\n  GraphQLScalarType[GraphQLScalarType[\"AWSIPAddress\"] = 13] = \"AWSIPAddress\";\n})(GraphQLScalarType || (GraphQLScalarType = {}));\n(function (GraphQLScalarType) {\n  function getJSType(scalar) {\n    switch (scalar) {\n      case 'Boolean':\n        return 'boolean';\n      case 'ID':\n      case 'String':\n      case 'AWSDate':\n      case 'AWSTime':\n      case 'AWSDateTime':\n      case 'AWSEmail':\n      case 'AWSURL':\n      case 'AWSPhone':\n      case 'AWSIPAddress':\n        return 'string';\n      case 'Int':\n      case 'Float':\n      case 'AWSTimestamp':\n        return 'number';\n      case 'AWSJSON':\n        return 'object';\n      default:\n        throw new Error('Invalid scalar type');\n    }\n  }\n  GraphQLScalarType.getJSType = getJSType;\n  function getValidationFunction(scalar) {\n    switch (scalar) {\n      case 'AWSDate':\n        return isAWSDate;\n      case 'AWSTime':\n        return isAWSTime;\n      case 'AWSDateTime':\n        return isAWSDateTime;\n      case 'AWSTimestamp':\n        return isAWSTimestamp;\n      case 'AWSEmail':\n        return isAWSEmail;\n      case 'AWSJSON':\n        return isAWSJSON;\n      case 'AWSURL':\n        return isAWSURL;\n      case 'AWSPhone':\n        return isAWSPhone;\n      case 'AWSIPAddress':\n        return isAWSIPAddress;\n      default:\n        return undefined;\n    }\n  }\n  GraphQLScalarType.getValidationFunction = getValidationFunction;\n})(GraphQLScalarType || (GraphQLScalarType = {}));\nexport function isGraphQLScalarType(obj) {\n  return obj && GraphQLScalarType[obj] !== undefined;\n}\nexport function isModelFieldType(obj) {\n  var modelField = 'model';\n  if (obj && obj[modelField]) return true;\n  return false;\n}\nexport function isNonModelFieldType(obj) {\n  var typeField = 'nonModel';\n  if (obj && obj[typeField]) return true;\n  return false;\n}\nexport function isEnumFieldType(obj) {\n  var modelField = 'enum';\n  if (obj && obj[modelField]) return true;\n  return false;\n}\nexport function isIdentifierObject(obj, modelDefinition) {\n  var keys = extractPrimaryKeyFieldNames(modelDefinition);\n  return typeof obj === 'object' && obj && keys.every(function (k) {\n    return obj[k] !== undefined;\n  });\n}\n//#endregion\n//#region Subscription messages\nexport var OpType;\n(function (OpType) {\n  OpType[\"INSERT\"] = \"INSERT\";\n  OpType[\"UPDATE\"] = \"UPDATE\";\n  OpType[\"DELETE\"] = \"DELETE\";\n})(OpType || (OpType = {}));\nexport function isPredicateObj(obj) {\n  return obj && obj.field !== undefined;\n}\nexport function isPredicateGroup(obj) {\n  return obj && obj.type !== undefined;\n}\nexport var QueryOne;\n(function (QueryOne) {\n  QueryOne[QueryOne[\"FIRST\"] = 0] = \"FIRST\";\n  QueryOne[QueryOne[\"LAST\"] = 1] = \"LAST\";\n})(QueryOne || (QueryOne = {}));\nexport var SortDirection;\n(function (SortDirection) {\n  SortDirection[\"ASCENDING\"] = \"ASCENDING\";\n  SortDirection[\"DESCENDING\"] = \"DESCENDING\";\n})(SortDirection || (SortDirection = {}));\nexport var AuthModeStrategyType;\n(function (AuthModeStrategyType) {\n  AuthModeStrategyType[\"DEFAULT\"] = \"DEFAULT\";\n  AuthModeStrategyType[\"MULTI_AUTH\"] = \"MULTI_AUTH\";\n})(AuthModeStrategyType || (AuthModeStrategyType = {}));\nexport var ModelOperation;\n(function (ModelOperation) {\n  ModelOperation[\"CREATE\"] = \"CREATE\";\n  ModelOperation[\"READ\"] = \"READ\";\n  ModelOperation[\"UPDATE\"] = \"UPDATE\";\n  ModelOperation[\"DELETE\"] = \"DELETE\";\n})(ModelOperation || (ModelOperation = {}));\nexport function syncExpression(modelConstructor, conditionProducer) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n      return [2 /*return*/, {\n        modelConstructor: modelConstructor,\n        conditionProducer: conditionProducer\n      }];\n    });\n  });\n}\nexport var ProcessName;\n(function (ProcessName) {\n  ProcessName[\"sync\"] = \"sync\";\n  ProcessName[\"mutate\"] = \"mutate\";\n  ProcessName[\"subscribe\"] = \"subscribe\";\n})(ProcessName || (ProcessName = {}));\nexport var DISCARD = Symbol('DISCARD');\nexport var LimitTimerRaceResolvedValues;\n(function (LimitTimerRaceResolvedValues) {\n  LimitTimerRaceResolvedValues[\"LIMIT\"] = \"LIMIT\";\n  LimitTimerRaceResolvedValues[\"TIMER\"] = \"TIMER\";\n})(LimitTimerRaceResolvedValues || (LimitTimerRaceResolvedValues = {}));\n/**\n * A pointer used by DataStore internally to lookup predicate details\n * that should not be exposed on public customer interfaces.\n */\nvar PredicateInternalsKey = /** @class */function () {\n  function PredicateInternalsKey() {\n    this.__isPredicateInternalsKeySentinel = true;\n  }\n  return PredicateInternalsKey;\n}();\nexport { PredicateInternalsKey };\n// #endregion","map":{"version":3,"names":["isAWSDate","isAWSTime","isAWSDateTime","isAWSTimestamp","isAWSEmail","isAWSJSON","isAWSURL","isAWSPhone","isAWSIPAddress","extractPrimaryKeyFieldNames","isSchemaModel","obj","pluralName","undefined","isSchemaModelWithAttributes","m","attributes","isAssociatedWith","associatedWith","isTargetNameAssociation","targetName","targetNames","isFieldAssociation","fieldName","_b","_a","fields","association","connectionType","isModelAttributeAuth","attr","type","properties","rules","length","isModelAttributeKey","isModelAttributePrimaryKey","name","isModelAttributeCompositeKey","ModelAttributeAuthAllow","ModelAttributeAuthProvider","GraphQLScalarType","getJSType","scalar","Error","getValidationFunction","isGraphQLScalarType","isModelFieldType","modelField","isNonModelFieldType","typeField","isEnumFieldType","isIdentifierObject","modelDefinition","keys","every","k","OpType","isPredicateObj","field","isPredicateGroup","QueryOne","SortDirection","AuthModeStrategyType","ModelOperation","syncExpression","modelConstructor","conditionProducer","ProcessName","DISCARD","Symbol","LimitTimerRaceResolvedValues","PredicateInternalsKey","__isPredicateInternalsKeySentinel"],"sources":["/Users/yannellym/Desktop/iwantapet/node_modules/@aws-amplify/datastore/src/types.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ModelInstanceCreator } from './datastore/datastore';\nimport {\n\tisAWSDate,\n\tisAWSTime,\n\tisAWSDateTime,\n\tisAWSTimestamp,\n\tisAWSEmail,\n\tisAWSJSON,\n\tisAWSURL,\n\tisAWSPhone,\n\tisAWSIPAddress,\n\tNAMESPACES,\n\textractPrimaryKeyFieldNames,\n} from './util';\nimport { PredicateAll } from './predicates';\nimport { GRAPHQL_AUTH_MODE } from '@aws-amplify/api-graphql';\nimport { Auth } from '@aws-amplify/auth';\nimport { InternalAPI } from '@aws-amplify/api/internals';\nimport { Cache } from '@aws-amplify/cache';\nimport { Adapter } from './storage/adapter';\n\nexport type Scalar<T> = T extends Array<infer InnerType> ? InnerType : T;\n\n//#region Schema types\nexport type Schema = UserSchema & {\n\tversion: string;\n\tcodegenVersion: string;\n};\nexport type UserSchema = {\n\tmodels: SchemaModels;\n\tnonModels?: SchemaNonModels;\n\trelationships?: RelationshipType;\n\tkeys?: ModelKeys;\n\tenums: SchemaEnums;\n\tmodelTopologicalOrdering?: Map<string, string[]>;\n};\nexport type InternalSchema = {\n\tnamespaces: SchemaNamespaces;\n\tversion: string;\n\tcodegenVersion: string;\n};\nexport type SchemaNamespaces = Record<string, SchemaNamespace>;\nexport type SchemaNamespace = UserSchema & {\n\tname: string;\n};\nexport type SchemaModels = Record<string, SchemaModel>;\nexport type SchemaModel = {\n\tname: string;\n\tpluralName: string;\n\tattributes?: ModelAttributes;\n\n\t/**\n\t * Explicitly defined fields.\n\t */\n\tfields: ModelFields;\n\n\t/**\n\t * Explicitly defined fields plus implied fields. (E.g., foreign keys.)\n\t */\n\tallFields?: ModelFields;\n\n\tsyncable?: boolean;\n};\n\nexport function isSchemaModel(obj: any): obj is SchemaModel {\n\treturn obj && (<SchemaModel>obj).pluralName !== undefined;\n}\n\nexport function isSchemaModelWithAttributes(\n\tm: SchemaModel | SchemaNonModel\n): m is SchemaModel {\n\treturn isSchemaModel(m) && (m as SchemaModel).attributes !== undefined;\n}\n\nexport type SchemaNonModels = Record<string, SchemaNonModel>;\nexport type SchemaNonModel = {\n\tname: string;\n\tfields: ModelFields;\n};\ntype SchemaEnums = Record<string, SchemaEnum>;\ntype SchemaEnum = {\n\tname: string;\n\tvalues: string[];\n};\nexport type ModelMeta<T extends PersistentModel> = {\n\tbuilder: PersistentModelConstructor<T>;\n\tschema: SchemaModel;\n\tpkField: string[];\n};\nexport type ModelAssociation = AssociatedWith | TargetNameAssociation;\ntype AssociatedWith = {\n\tconnectionType: 'HAS_MANY' | 'HAS_ONE';\n\tassociatedWith: string | string[];\n\ttargetName?: string;\n\ttargetNames?: string[];\n};\n\nexport function isAssociatedWith(obj: any): obj is AssociatedWith {\n\treturn obj && obj.associatedWith;\n}\n\ntype TargetNameAssociation = {\n\tconnectionType: 'BELONGS_TO';\n\ttargetName?: string;\n\ttargetNames?: string[];\n};\n\nexport function isTargetNameAssociation(\n\tobj: any\n): obj is TargetNameAssociation {\n\treturn obj?.targetName || obj?.targetNames;\n}\n\ntype FieldAssociation = {\n\tconnectionType: 'HAS_ONE' | 'BELONGS_TO' | 'HAS_MANY';\n};\nexport function isFieldAssociation(\n\tobj: any,\n\tfieldName: string\n): obj is FieldAssociation {\n\treturn obj?.fields[fieldName]?.association?.connectionType;\n}\n\nexport type ModelAttributes = ModelAttribute[];\nexport type ModelAttribute = { type: string; properties?: Record<string, any> };\n\nexport type ModelAuthRule = {\n\tallow: string;\n\tprovider?: string;\n\toperations?: string[];\n\townerField?: string;\n\tidentityClaim?: string;\n\tgroups?: string[];\n\tgroupClaim?: string;\n\tgroupsField?: string;\n};\n\nexport type ModelAttributeAuth = {\n\ttype: 'auth';\n\tproperties: {\n\t\trules: ModelAuthRule[];\n\t};\n};\n\nexport function isModelAttributeAuth(\n\tattr: ModelAttribute\n): attr is ModelAttributeAuth {\n\treturn (\n\t\tattr.type === 'auth' &&\n\t\tattr.properties &&\n\t\tattr.properties.rules &&\n\t\tattr.properties.rules.length > 0\n\t);\n}\n\ntype ModelAttributeKey = {\n\ttype: 'key';\n\tproperties: {\n\t\tname?: string;\n\t\tfields: string[];\n\t};\n};\n\ntype ModelAttributePrimaryKey = {\n\ttype: 'key';\n\tproperties: {\n\t\tname: never;\n\t\tfields: string[];\n\t};\n};\n\ntype ModelAttributeCompositeKey = {\n\ttype: 'key';\n\tproperties: {\n\t\tname: string;\n\t\tfields: [string, string, string, string?, string?];\n\t};\n};\n\nexport function isModelAttributeKey(\n\tattr: ModelAttribute\n): attr is ModelAttributeKey {\n\treturn (\n\t\tattr.type === 'key' &&\n\t\tattr.properties &&\n\t\tattr.properties.fields &&\n\t\tattr.properties.fields.length > 0\n\t);\n}\n\nexport function isModelAttributePrimaryKey(\n\tattr: ModelAttribute\n): attr is ModelAttributePrimaryKey {\n\treturn isModelAttributeKey(attr) && attr.properties.name === undefined;\n}\n\nexport function isModelAttributeCompositeKey(\n\tattr: ModelAttribute\n): attr is ModelAttributeCompositeKey {\n\treturn (\n\t\tisModelAttributeKey(attr) &&\n\t\tattr.properties.name !== undefined &&\n\t\tattr.properties.fields.length > 2\n\t);\n}\n\nexport type ModelAttributeAuthProperty = {\n\tallow: ModelAttributeAuthAllow;\n\tidentityClaim?: string;\n\tgroupClaim?: string;\n\tgroups?: string[];\n\toperations?: string[];\n\townerField?: string;\n\tprovider?: ModelAttributeAuthProvider;\n};\n\nexport enum ModelAttributeAuthAllow {\n\tCUSTOM = 'custom',\n\tOWNER = 'owner',\n\tGROUPS = 'groups',\n\tPRIVATE = 'private',\n\tPUBLIC = 'public',\n}\n\nexport enum ModelAttributeAuthProvider {\n\tFUNCTION = 'function',\n\tUSER_POOLS = 'userPools',\n\tOIDC = 'oidc',\n\tIAM = 'iam',\n\tAPI_KEY = 'apiKey',\n}\n\nexport type ModelFields = Record<string, ModelField>;\nexport enum GraphQLScalarType {\n\tID,\n\tString,\n\tInt,\n\tFloat,\n\tBoolean,\n\tAWSDate,\n\tAWSTime,\n\tAWSDateTime,\n\tAWSTimestamp,\n\tAWSEmail,\n\tAWSJSON,\n\tAWSURL,\n\tAWSPhone,\n\tAWSIPAddress,\n}\n\nexport namespace GraphQLScalarType {\n\texport function getJSType(\n\t\tscalar: keyof Omit<\n\t\t\ttypeof GraphQLScalarType,\n\t\t\t'getJSType' | 'getValidationFunction'\n\t\t>\n\t) {\n\t\tswitch (scalar) {\n\t\t\tcase 'Boolean':\n\t\t\t\treturn 'boolean';\n\t\t\tcase 'ID':\n\t\t\tcase 'String':\n\t\t\tcase 'AWSDate':\n\t\t\tcase 'AWSTime':\n\t\t\tcase 'AWSDateTime':\n\t\t\tcase 'AWSEmail':\n\t\t\tcase 'AWSURL':\n\t\t\tcase 'AWSPhone':\n\t\t\tcase 'AWSIPAddress':\n\t\t\t\treturn 'string';\n\t\t\tcase 'Int':\n\t\t\tcase 'Float':\n\t\t\tcase 'AWSTimestamp':\n\t\t\t\treturn 'number';\n\t\t\tcase 'AWSJSON':\n\t\t\t\treturn 'object';\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Invalid scalar type');\n\t\t}\n\t}\n\n\texport function getValidationFunction(\n\t\tscalar: keyof Omit<\n\t\t\ttypeof GraphQLScalarType,\n\t\t\t'getJSType' | 'getValidationFunction'\n\t\t>\n\t): ((val: string) => boolean) | ((val: number) => boolean) | undefined {\n\t\tswitch (scalar) {\n\t\t\tcase 'AWSDate':\n\t\t\t\treturn isAWSDate;\n\t\t\tcase 'AWSTime':\n\t\t\t\treturn isAWSTime;\n\t\t\tcase 'AWSDateTime':\n\t\t\t\treturn isAWSDateTime;\n\t\t\tcase 'AWSTimestamp':\n\t\t\t\treturn isAWSTimestamp;\n\t\t\tcase 'AWSEmail':\n\t\t\t\treturn isAWSEmail;\n\t\t\tcase 'AWSJSON':\n\t\t\t\treturn isAWSJSON;\n\t\t\tcase 'AWSURL':\n\t\t\t\treturn isAWSURL;\n\t\t\tcase 'AWSPhone':\n\t\t\t\treturn isAWSPhone;\n\t\t\tcase 'AWSIPAddress':\n\t\t\t\treturn isAWSIPAddress;\n\t\t\tdefault:\n\t\t\t\treturn undefined;\n\t\t}\n\t}\n}\n\nexport type AuthorizationRule = {\n\tidentityClaim: string;\n\townerField: string;\n\tprovider: 'userPools' | 'oidc' | 'iam' | 'apiKey';\n\tgroupClaim: string;\n\tgroups: [string];\n\tgroupsField: string;\n\tauthStrategy: 'owner' | 'groups' | 'private' | 'public';\n\tareSubscriptionsPublic: boolean;\n};\n\nexport function isGraphQLScalarType(\n\tobj: any\n): obj is keyof Omit<\n\ttypeof GraphQLScalarType,\n\t'getJSType' | 'getValidationFunction'\n> {\n\treturn obj && GraphQLScalarType[obj] !== undefined;\n}\n\nexport type ModelFieldType = {\n\tmodel: string;\n\tmodelConstructor?: ModelMeta<PersistentModel>;\n};\nexport function isModelFieldType<T extends PersistentModel>(\n\tobj: any\n): obj is ModelFieldType {\n\tconst modelField: keyof ModelFieldType = 'model';\n\tif (obj && obj[modelField]) return true;\n\n\treturn false;\n}\n\nexport type NonModelFieldType = { nonModel: string };\nexport function isNonModelFieldType(obj: any): obj is NonModelFieldType {\n\tconst typeField: keyof NonModelFieldType = 'nonModel';\n\tif (obj && obj[typeField]) return true;\n\n\treturn false;\n}\n\ntype EnumFieldType = { enum: string };\nexport function isEnumFieldType(obj: any): obj is EnumFieldType {\n\tconst modelField: keyof EnumFieldType = 'enum';\n\tif (obj && obj[modelField]) return true;\n\n\treturn false;\n}\n\nexport type ModelField = {\n\tname: string;\n\ttype:\n\t\t| keyof Omit<\n\t\t\t\ttypeof GraphQLScalarType,\n\t\t\t\t'getJSType' | 'getValidationFunction'\n\t\t  >\n\t\t| ModelFieldType\n\t\t| NonModelFieldType\n\t\t| EnumFieldType;\n\tisArray: boolean;\n\tisRequired?: boolean;\n\tisReadOnly?: boolean;\n\tisArrayNullable?: boolean;\n\tassociation?: ModelAssociation;\n\tattributes?: ModelAttributes[];\n};\n//#endregion\n\n//#region Model definition\nexport type NonModelTypeConstructor<T> = {\n\tnew (init: T): T;\n};\n\n// Class for model\nexport type PersistentModelConstructor<T extends PersistentModel> = {\n\tnew (init: ModelInit<T, PersistentModelMetaData<T>>): T;\n\tcopyOf(\n\t\tsrc: T,\n\t\tmutator: (draft: MutableModel<T, PersistentModelMetaData<T>>) => void\n\t): T;\n};\n\n/**\n * @private\n * Internal use of Amplify only.\n *\n * Indicates to use lazy models or eager models.\n */\nexport declare class LazyLoadingDisabled {\n\tdisabled: true;\n}\n\n/**\n * @private\n * Internal use of Amplify only.\n *\n * Indicates to use lazy models or eager models.\n */\nexport declare class LazyLoading {}\n\nexport type TypeConstructorMap = Record<\n\tstring,\n\tPersistentModelConstructor<any> | NonModelTypeConstructor<unknown>\n>;\n\n/**\n * Each identifier type is represented using nominal types, see:\n * https://basarat.gitbook.io/typescript/main-1/nominaltyping\n */\nexport declare const __identifierBrand__: unique symbol;\nexport type IdentifierBrand<T, K> = T & { [__identifierBrand__]: K };\n\n// datastore generates a uuid for you\nexport type ManagedIdentifier<T, F extends keyof T> = IdentifierBrand<\n\t{ field: F extends string ? F : never; type: T },\n\t'ManagedIdentifier'\n>;\n\n// you can provide a value, if not, datastore generates a uuid for you\nexport type OptionallyManagedIdentifier<T, F extends keyof T> = IdentifierBrand<\n\t{ field: F extends string ? F : never; type: T },\n\t'OptionallyManagedIdentifier'\n>;\n\n// You provide the values\nexport type CompositeIdentifier<T, K extends Array<keyof T>> = IdentifierBrand<\n\t{ fields: K; type: T },\n\t'CompositeIdentifier'\n>;\n\n// You provide the value\nexport type CustomIdentifier<T, K extends keyof T> = CompositeIdentifier<\n\tT,\n\t[K]\n>;\n\nexport type Identifier<T> =\n\t| ManagedIdentifier<T, any>\n\t| OptionallyManagedIdentifier<T, any>\n\t| CompositeIdentifier<T, any>\n\t| CustomIdentifier<T, any>;\n\nexport type IdentifierFields<\n\tT extends PersistentModel,\n\tM extends PersistentModelMetaData<T> = never\n> = (MetadataOrDefault<T, M>['identifier'] extends\n\t| ManagedIdentifier<any, any>\n\t| OptionallyManagedIdentifier<any, any>\n\t? MetadataOrDefault<T, M>['identifier']['field']\n\t: MetadataOrDefault<T, M>['identifier'] extends CompositeIdentifier<\n\t\t\tT,\n\t\t\tinfer B\n\t  >\n\t? B[number] // B[number]\n\t: MetadataOrDefault<T, M>['identifier']['field']) &\n\tstring;\n\nexport type IdentifierFieldsForInit<\n\tT extends PersistentModel,\n\tM extends PersistentModelMetaData<T>\n> = MetadataOrDefault<T, M>['identifier'] extends\n\t| DefaultPersistentModelMetaData\n\t| ManagedIdentifier<T, any>\n\t? never\n\t: MetadataOrDefault<T, M>['identifier'] extends OptionallyManagedIdentifier<\n\t\t\tT,\n\t\t\tany\n\t  >\n\t? IdentifierFields<T, M>\n\t: MetadataOrDefault<T, M>['identifier'] extends CompositeIdentifier<T, any>\n\t? IdentifierFields<T, M>\n\t: never;\n\n// Instance of model\nexport declare const __modelMeta__: unique symbol;\n\nexport type PersistentModelMetaData<T> = {\n\tidentifier?: Identifier<T>;\n\treadOnlyFields?: string;\n};\n\nexport interface AsyncCollection<T> extends AsyncIterable<T> {\n\ttoArray(options?: { max?: number }): Promise<T[]>;\n}\n\nexport type SettableFieldType<T> = T extends Promise<infer InnerPromiseType>\n\t? undefined extends InnerPromiseType\n\t\t? InnerPromiseType | null\n\t\t: InnerPromiseType\n\t: T extends AsyncCollection<infer InnerCollectionType>\n\t? InnerCollectionType[] | undefined\n\t: undefined extends T\n\t? T | null\n\t: T;\n\nexport type PredicateFieldType<T> = NonNullable<\n\tScalar<\n\t\tT extends Promise<infer InnerPromiseType>\n\t\t\t? InnerPromiseType\n\t\t\t: T extends AsyncCollection<infer InnerCollectionType>\n\t\t\t? InnerCollectionType\n\t\t\t: T\n\t>\n>;\n\ntype KeysOfType<T, FilterType> = {\n\t[P in keyof T]: T[P] extends FilterType ? P : never;\n}[keyof T];\n\ntype KeysOfSuperType<T, FilterType> = {\n\t[P in keyof T]: FilterType extends T[P] ? P : never;\n}[keyof T];\n\ntype OptionalRelativesOf<T> =\n\t| KeysOfType<T, AsyncCollection<any>>\n\t| KeysOfSuperType<T, Promise<undefined>>;\n\ntype OmitOptionalRelatives<T> = Omit<T, OptionalRelativesOf<T>>;\ntype PickOptionalRelatives<T> = Pick<T, OptionalRelativesOf<T>>;\ntype OmitOptionalFields<T> = Omit<\n\tT,\n\tKeysOfSuperType<T, undefined> | OptionalRelativesOf<T>\n>;\ntype PickOptionalFields<T> = Pick<\n\tT,\n\tKeysOfSuperType<T, undefined> | OptionalRelativesOf<T>\n>;\n\nexport type DefaultPersistentModelMetaData = {\n\tidentifier: ManagedIdentifier<{ id: string }, 'id'>;\n\treadOnlyFields: never;\n};\n\nexport type MetadataOrDefault<\n\tT extends PersistentModel,\n\t_ extends PersistentModelMetaData<T> = never\n> = T extends {\n\t[__modelMeta__]: PersistentModelMetaData<T>;\n}\n\t? T[typeof __modelMeta__]\n\t: DefaultPersistentModelMetaData;\n\nexport type PersistentModel = Readonly<Record<string, any>>;\n\nexport type MetadataReadOnlyFields<\n\tT extends PersistentModel,\n\tM extends PersistentModelMetaData<T>\n> = Extract<\n\tMetadataOrDefault<T, M>['readOnlyFields'] | M['readOnlyFields'],\n\tkeyof T\n>;\n\n// This type omits the metadata field in the constructor init object\n// This type omits identifier fields in the constructor init object\n// This type omits readOnlyFields in the constructor init object\n// This type requires some identifiers in the constructor init object (e.g. CustomIdentifier)\n// This type makes optional some identifiers in the constructor init object (e.g. OptionallyManagedIdentifier)\nexport type ModelInitBase<\n\tT extends PersistentModel,\n\tM extends PersistentModelMetaData<T> = {}\n> = Omit<\n\tT,\n\ttypeof __modelMeta__ | IdentifierFields<T, M> | MetadataReadOnlyFields<T, M>\n> &\n\t(MetadataOrDefault<T, M>['identifier'] extends OptionallyManagedIdentifier<\n\t\tT,\n\t\tany\n\t>\n\t\t? Partial<Pick<T, IdentifierFieldsForInit<T, M>>>\n\t\t: Required<Pick<T, IdentifierFieldsForInit<T, M>>>);\n\nexport type ModelInit<\n\tT extends PersistentModel,\n\tM extends PersistentModelMetaData<T> = {}\n> = {\n\t[P in keyof OmitOptionalRelatives<ModelInitBase<T, M>>]: SettableFieldType<\n\t\tModelInitBase<T, M>[P]\n\t>;\n} & {\n\t[P in keyof PickOptionalRelatives<ModelInitBase<T, M>>]+?: SettableFieldType<\n\t\tModelInitBase<T, M>[P]\n\t>;\n};\n\ntype DeepWritable<T> = {\n\t-readonly [P in keyof T]: T[P] extends TypeName<T[P]>\n\t\t? T[P]\n\t\t: T[P] extends Promise<infer InnerPromiseType>\n\t\t? undefined extends InnerPromiseType\n\t\t\t? InnerPromiseType | null\n\t\t\t: InnerPromiseType\n\t\t: T[P] extends AsyncCollection<infer InnerCollectionType>\n\t\t? InnerCollectionType[] | undefined | null\n\t\t: DeepWritable<T[P]>;\n};\n\nexport type MutableModel<\n\tT extends PersistentModel,\n\tM extends PersistentModelMetaData<T> = {}\n\t// This provides Intellisense with ALL of the properties, regardless of read-only\n\t// but will throw a linting error if trying to overwrite a read-only property\n> = DeepWritable<\n\tOmit<T, IdentifierFields<T, M> | MetadataReadOnlyFields<T, M>>\n> &\n\tReadonly<Pick<T, IdentifierFields<T, M> | MetadataReadOnlyFields<T, M>>>;\n\nexport type ModelInstanceMetadata = {\n\t_version: number;\n\t_lastChangedAt: number;\n\t_deleted: boolean;\n};\n\nexport type IdentifierFieldValue<\n\tT extends PersistentModel,\n\tM extends PersistentModelMetaData<T>\n> = MetadataOrDefault<T, M>['identifier'] extends CompositeIdentifier<T, any>\n\t? MetadataOrDefault<T, M>['identifier']['fields'] extends [any]\n\t\t? T[MetadataOrDefault<T, M>['identifier']['fields'][0]]\n\t\t: never\n\t: T[MetadataOrDefault<T, M>['identifier']['field']];\n\nexport type IdentifierFieldOrIdentifierObject<\n\tT extends PersistentModel,\n\tM extends PersistentModelMetaData<T>\n> = Pick<T, IdentifierFields<T, M>> | IdentifierFieldValue<T, M>;\n\nexport function isIdentifierObject<T extends PersistentModel>(\n\tobj: any,\n\tmodelDefinition: SchemaModel\n): obj is IdentifierFields<T extends PersistentModel ? T : never, any> {\n\tconst keys = extractPrimaryKeyFieldNames(modelDefinition);\n\n\treturn (\n\t\ttypeof obj === 'object' && obj && keys.every(k => obj[k] !== undefined)\n\t);\n}\n//#endregion\n\n//#region Subscription messages\nexport enum OpType {\n\tINSERT = 'INSERT',\n\tUPDATE = 'UPDATE',\n\tDELETE = 'DELETE',\n}\n\nexport type SubscriptionMessage<T extends PersistentModel> = Pick<\n\tInternalSubscriptionMessage<T>,\n\t'opType' | 'element' | 'model' | 'condition'\n>;\n\nexport type InternalSubscriptionMessage<T extends PersistentModel> = {\n\topType: OpType;\n\telement: T;\n\tmodel: PersistentModelConstructor<T>;\n\tcondition: PredicatesGroup<T> | null;\n\tsavedElement?: T;\n};\n\nexport type DataStoreSnapshot<T extends PersistentModel> = {\n\titems: T[];\n\tisSynced: boolean;\n};\n//#endregion\n\n//#region Predicates\n\nexport type PredicateExpression<\n\tM extends PersistentModel,\n\tFT\n> = TypeName<FT> extends keyof MapTypeToOperands<FT>\n\t? (\n\t\t\toperator: keyof MapTypeToOperands<FT>[TypeName<FT>],\n\t\t\t// make the operand type match the type they're trying to filter on\n\t\t\toperand: MapTypeToOperands<FT>[TypeName<FT>][keyof MapTypeToOperands<FT>[TypeName<FT>]]\n\t  ) => ModelPredicate<M>\n\t: never;\n\ntype EqualityOperators<T> = {\n\tne: T;\n\teq: T;\n};\ntype ScalarNumberOperators<T> = EqualityOperators<T> & {\n\tle: T;\n\tlt: T;\n\tge: T;\n\tgt: T;\n};\ntype NumberOperators<T> = ScalarNumberOperators<T> & {\n\tbetween: [T, T];\n};\ntype StringOperators<T> = ScalarNumberOperators<T> & {\n\tbeginsWith: T;\n\tcontains: T;\n\tnotContains: T;\n};\ntype BooleanOperators<T> = EqualityOperators<T>;\ntype ArrayOperators<T> = {\n\tcontains: T;\n\tnotContains: T;\n};\nexport type AllOperators = NumberOperators<any> &\n\tStringOperators<any> &\n\tArrayOperators<any>;\n\ntype MapTypeToOperands<T> = {\n\tnumber: NumberOperators<NonNullable<T>>;\n\tstring: StringOperators<NonNullable<T>>;\n\tboolean: BooleanOperators<NonNullable<T>>;\n\t'number[]': ArrayOperators<number>;\n\t'string[]': ArrayOperators<string>;\n\t'boolean[]': ArrayOperators<boolean>;\n};\n\ntype TypeName<T> = T extends string\n\t? 'string'\n\t: T extends number\n\t? 'number'\n\t: T extends boolean\n\t? 'boolean'\n\t: T extends string[]\n\t? 'string[]'\n\t: T extends number[]\n\t? 'number[]'\n\t: T extends boolean[]\n\t? 'boolean[]'\n\t: never;\n\nexport type PredicateGroups<T extends PersistentModel> = {\n\tand: (\n\t\tpredicate: (predicate: ModelPredicate<T>) => ModelPredicate<T>\n\t) => ModelPredicate<T>;\n\tor: (\n\t\tpredicate: (predicate: ModelPredicate<T>) => ModelPredicate<T>\n\t) => ModelPredicate<T>;\n\tnot: (\n\t\tpredicate: (predicate: ModelPredicate<T>) => ModelPredicate<T>\n\t) => ModelPredicate<T>;\n};\n\nexport type ModelPredicate<M extends PersistentModel> = {\n\t[K in keyof M]-?: PredicateExpression<M, NonNullable<M[K]>>;\n} & PredicateGroups<M>;\n\nexport type ProducerModelPredicate<M extends PersistentModel> = (\n\tcondition: ModelPredicate<M>\n) => ModelPredicate<M>;\n\nexport type PredicatesGroup<T extends PersistentModel> = {\n\ttype: keyof PredicateGroups<T>;\n\tpredicates: (PredicateObject<T> | PredicatesGroup<T>)[];\n};\n\nexport function isPredicateObj<T extends PersistentModel>(\n\tobj: any\n): obj is PredicateObject<T> {\n\treturn obj && (<PredicateObject<T>>obj).field !== undefined;\n}\n\nexport function isPredicateGroup<T extends PersistentModel>(\n\tobj: any\n): obj is PredicatesGroup<T> {\n\treturn obj && (<PredicatesGroup<T>>obj).type !== undefined;\n}\n\nexport type PredicateObject<T extends PersistentModel> = {\n\tfield: keyof T;\n\toperator: keyof AllOperators;\n\toperand: any;\n};\n\nexport enum QueryOne {\n\tFIRST,\n\tLAST,\n}\nexport type GraphQLField = {\n\t[field: string]: {\n\t\t[operator: string]: string | number | [number, number];\n\t};\n};\n\nexport type GraphQLCondition = Partial<\n\t| GraphQLField\n\t| {\n\t\t\tand: [GraphQLCondition];\n\t\t\tor: [GraphQLCondition];\n\t\t\tnot: GraphQLCondition;\n\t  }\n>;\n\nexport type GraphQLFilter = Partial<\n\t| GraphQLField\n\t| {\n\t\t\tand: GraphQLFilter[];\n\t  }\n\t| {\n\t\t\tor: GraphQLFilter[];\n\t  }\n\t| {\n\t\t\tnot: GraphQLFilter;\n\t  }\n>;\n\n//#endregion\n\n//#region Pagination\n\nexport type ProducerPaginationInput<T extends PersistentModel> = {\n\tsort?: ProducerSortPredicate<T>;\n\tlimit?: number;\n\tpage?: number;\n};\n\nexport type ObserveQueryOptions<T extends PersistentModel> = Pick<\n\tProducerPaginationInput<T>,\n\t'sort'\n>;\n\nexport type PaginationInput<T extends PersistentModel> = {\n\tsort?: SortPredicate<T>;\n\tlimit?: number;\n\tpage?: number;\n};\n\nexport type ProducerSortPredicate<M extends PersistentModel> = (\n\tcondition: SortPredicate<M>\n) => SortPredicate<M>;\n\nexport type SortPredicate<T extends PersistentModel> = {\n\t[K in keyof T]-?: SortPredicateExpression<T, NonNullable<T[K]>>;\n};\n\nexport type SortPredicateExpression<\n\tM extends PersistentModel,\n\tFT\n> = TypeName<FT> extends keyof MapTypeToOperands<FT>\n\t? (sortDirection: keyof typeof SortDirection) => SortPredicate<M>\n\t: never;\n\nexport enum SortDirection {\n\tASCENDING = 'ASCENDING',\n\tDESCENDING = 'DESCENDING',\n}\n\nexport type SortPredicatesGroup<T extends PersistentModel> =\n\tSortPredicateObject<T>[];\n\nexport type SortPredicateObject<T extends PersistentModel> = {\n\tfield: keyof T;\n\tsortDirection: keyof typeof SortDirection;\n};\n\n//#endregion\n\n//#region System Components\n\nexport type SystemComponent = {\n\tsetUp(\n\t\tschema: InternalSchema,\n\t\tnamespaceResolver: NamespaceResolver,\n\t\tmodelInstanceCreator: ModelInstanceCreator,\n\t\tgetModelConstructorByModelName: (\n\t\t\tnamsespaceName: NAMESPACES,\n\t\t\tmodelName: string\n\t\t) => PersistentModelConstructor<any>,\n\t\tappId?: string\n\t): Promise<void>;\n};\n\nexport type NamespaceResolver = (\n\tmodelConstructor: PersistentModelConstructor<any>\n) => string;\n\nexport type ControlMessageType<T> = {\n\ttype: T;\n\tdata?: any;\n};\n\n//#endregion\n\n//#region Relationship types\nexport type RelationType = {\n\tfieldName: string;\n\tmodelName: string;\n\trelationType: 'HAS_ONE' | 'HAS_MANY' | 'BELONGS_TO';\n\ttargetName?: string;\n\ttargetNames?: string[];\n\tassociatedWith?: string | string[];\n};\n\ntype IndexOptions = {\n\tunique?: boolean;\n};\n\nexport type IndexesType = Array<[string, string[], IndexOptions?]>;\n\nexport type RelationshipType = {\n\t[modelName: string]: {\n\t\tindexes: IndexesType;\n\t\trelationTypes: RelationType[];\n\t};\n};\n\n//#endregion\n\n//#region Key type\nexport type KeyType = {\n\tprimaryKey?: string[];\n\tcompositeKeys?: Set<string>[];\n};\n\nexport type ModelKeys = {\n\t[modelName: string]: KeyType;\n};\n\n//#endregion\n\n//#region DataStore config types\nexport type DataStoreConfig = {\n\tDataStore?: {\n\t\tauthModeStrategyType?: AuthModeStrategyType;\n\t\tconflictHandler?: ConflictHandler; // default : retry until client wins up to x times\n\t\terrorHandler?: (error: SyncError<PersistentModel>) => void; // default : logger.warn\n\t\tmaxRecordsToSync?: number; // merge\n\t\tsyncPageSize?: number;\n\t\tfullSyncInterval?: number;\n\t\tsyncExpressions?: SyncExpression[];\n\t\tauthProviders?: AuthProviders;\n\t\tstorageAdapter?: Adapter;\n\t};\n\tauthModeStrategyType?: AuthModeStrategyType;\n\tconflictHandler?: ConflictHandler; // default : retry until client wins up to x times\n\terrorHandler?: (error: SyncError<PersistentModel>) => void; // default : logger.warn\n\tmaxRecordsToSync?: number; // merge\n\tsyncPageSize?: number;\n\tfullSyncInterval?: number;\n\tsyncExpressions?: SyncExpression[];\n\tauthProviders?: AuthProviders;\n\tstorageAdapter?: Adapter;\n};\n\nexport type AuthProviders = {\n\tfunctionAuthProvider: () => { token: string } | Promise<{ token: string }>;\n};\n\nexport enum AuthModeStrategyType {\n\tDEFAULT = 'DEFAULT',\n\tMULTI_AUTH = 'MULTI_AUTH',\n}\n\nexport type AuthModeStrategyReturn =\n\t| GRAPHQL_AUTH_MODE\n\t| GRAPHQL_AUTH_MODE[]\n\t| undefined\n\t| null;\n\nexport type AuthModeStrategyParams = {\n\tschema: InternalSchema;\n\tmodelName: string;\n\toperation: ModelOperation;\n};\n\nexport type AuthModeStrategy = (\n\tauthModeStrategyParams: AuthModeStrategyParams\n) => AuthModeStrategyReturn | Promise<AuthModeStrategyReturn>;\n\nexport enum ModelOperation {\n\tCREATE = 'CREATE',\n\tREAD = 'READ',\n\tUPDATE = 'UPDATE',\n\tDELETE = 'DELETE',\n}\n\nexport type ModelAuthModes = Record<\n\tstring,\n\t{\n\t\t[Property in ModelOperation]: GRAPHQL_AUTH_MODE[];\n\t}\n>;\n\nexport type SyncExpression = Promise<{\n\tmodelConstructor: any;\n\tconditionProducer: (c?: any) => any;\n}>;\n\n/*\nAdds Intellisense when passing a function | promise that returns a predicate\nOr just a predicate. E.g.,\n\nsyncExpressions: [\n\tsyncExpression(Post, c => c.rating('gt', 5)),\n\n\tOR\n\n\tsyncExpression(Post, async () => {\n\t\treturn c => c.rating('gt', 5)\n\t}),\n]\n*/\n\ntype Option0 = [];\ntype Option1<T extends PersistentModel> = [V5ModelPredicate<T> | undefined];\ntype Option<T extends PersistentModel> = Option0 | Option1<T>;\n\ntype Lookup<T extends PersistentModel> = {\n\t0:\n\t\t| ModelPredicateExtender<T>\n\t\t| Promise<ModelPredicateExtender<T>>\n\t\t| typeof PredicateAll\n\t\t| Promise<typeof PredicateAll | symbol>;\n\t1: PredicateInternalsKey | undefined;\n};\n\ntype ConditionProducer<T extends PersistentModel, A extends Option<T>> = (\n\t...args: A\n) => A['length'] extends keyof Lookup<T> ? Lookup<T>[A['length']] : never;\n\nexport async function syncExpression<\n\tT extends PersistentModel,\n\tA extends Option<T>\n>(\n\tmodelConstructor: PersistentModelConstructor<T>,\n\tconditionProducer: ConditionProducer<T, A>\n): Promise<{\n\tmodelConstructor: PersistentModelConstructor<T>;\n\tconditionProducer: ConditionProducer<T, A>;\n}> {\n\treturn {\n\t\tmodelConstructor,\n\t\tconditionProducer,\n\t};\n}\n\nexport type SyncConflict = {\n\tmodelConstructor: PersistentModelConstructor<any>;\n\tlocalModel: PersistentModel;\n\tremoteModel: PersistentModel;\n\toperation: OpType;\n\tattempts: number;\n};\n\nexport type SyncError<T extends PersistentModel> = {\n\tmessage: string;\n\terrorType: ErrorType;\n\terrorInfo?: string;\n\trecoverySuggestion?: string;\n\tmodel?: string;\n\tlocalModel: T;\n\tremoteModel: T;\n\tprocess: ProcessName;\n\toperation: string;\n\tcause?: Error;\n};\n\nexport type ErrorType =\n\t| 'ConfigError'\n\t| 'BadModel'\n\t| 'BadRecord'\n\t| 'Unauthorized'\n\t| 'Transient'\n\t| 'Unknown';\n\nexport enum ProcessName {\n\t'sync' = 'sync',\n\t'mutate' = 'mutate',\n\t'subscribe' = 'subscribe',\n}\n\nexport const DISCARD = Symbol('DISCARD');\n\nexport type ConflictHandler = (\n\tconflict: SyncConflict\n) =>\n\t| Promise<PersistentModel | typeof DISCARD>\n\t| PersistentModel\n\t| typeof DISCARD;\nexport type ErrorHandler = (error: SyncError<PersistentModel>) => void;\n\nexport type DeferredCallbackResolverOptions = {\n\tcallback: () => void;\n\tmaxInterval?: number;\n\terrorHandler?: (error: string) => void;\n};\n\nexport enum LimitTimerRaceResolvedValues {\n\tLIMIT = 'LIMIT',\n\tTIMER = 'TIMER',\n}\n//#endregion\n\nexport type AmplifyContext = {\n\tAuth: typeof Auth;\n\tInternalAPI: typeof InternalAPI;\n\tCache: typeof Cache;\n};\n\n// #region V5 predicate types\n\nexport type MatchableTypes =\n\t| string\n\t| string[]\n\t| number\n\t| number[]\n\t| boolean\n\t| boolean[];\n\nexport type AllFieldOperators = keyof AllOperators;\n\nexport type NonNeverKeys<T> = {\n\t[K in keyof T]: T[K] extends never ? never : K;\n}[keyof T];\n\nexport type WithoutNevers<T> = Pick<T, NonNeverKeys<T>>;\n\n/**\n * A function that accepts a RecursiveModelPrecicate<T>, which it must use to\n * return a final condition.\n *\n * This is used in `DataStore.query()`, `DataStore.observe()`, and\n * `DataStore.observeQuery()` as the second argument. E.g.,\n *\n * ```\n * DataStore.query(MyModel, model => model.field.eq('some value'))\n * ```\n *\n * More complex queries should also be supported. E.g.,\n *\n * ```\n * DataStore.query(MyModel, model => model.and(m => [\n *   m.relatedEntity.or(relative => [\n *     relative.relativeField.eq('whatever'),\n *     relative.relativeField.eq('whatever else')\n *   ]),\n *   m.myModelField.ne('something')\n * ]))\n * ```\n */\nexport type RecursiveModelPredicateExtender<RT extends PersistentModel> = (\n\tlambda: RecursiveModelPredicate<RT>\n) => PredicateInternalsKey;\n\nexport type RecursiveModelPredicateAggregateExtender<\n\tRT extends PersistentModel\n> = (lambda: RecursiveModelPredicate<RT>) => PredicateInternalsKey[];\n\nexport type RecursiveModelPredicateOperator<RT extends PersistentModel> = (\n\tpredicates: RecursiveModelPredicateAggregateExtender<RT>\n) => PredicateInternalsKey;\n\nexport type RecursiveModelPredicateNegation<RT extends PersistentModel> = (\n\tpredicate: RecursiveModelPredicateExtender<RT>\n) => PredicateInternalsKey;\n\nexport type RecursiveModelPredicate<RT extends PersistentModel> = {\n\t[K in keyof RT]-?: PredicateFieldType<RT[K]> extends PersistentModel\n\t\t? RecursiveModelPredicate<PredicateFieldType<RT[K]>>\n\t\t: ValuePredicate<RT, RT[K]>;\n} & {\n\tor: RecursiveModelPredicateOperator<RT>;\n\tand: RecursiveModelPredicateOperator<RT>;\n\tnot: RecursiveModelPredicateNegation<RT>;\n} & PredicateInternalsKey;\n\n/**\n * A function that accepts a ModelPrecicate<T>, which it must use to return a\n * final condition.\n *\n * This is used as predicates in `DataStore.save()`, `DataStore.delete()`, and\n * DataStore sync expressions.\n *\n * ```\n * DataStore.save(record, model => model.field.eq('some value'))\n * ```\n *\n * Logical operators are supported. But, condtiions are related records are\n * NOT supported. E.g.,\n *\n * ```\n * DataStore.delete(record, model => model.or(m => [\n * \tm.field.eq('whatever'),\n * \tm.field.eq('whatever else')\n * ]))\n * ```\n */\nexport type ModelPredicateExtender<RT extends PersistentModel> = (\n\tlambda: V5ModelPredicate<RT>\n) => PredicateInternalsKey;\n\nexport type ModelPredicateAggregateExtender<RT extends PersistentModel> = (\n\tlambda: V5ModelPredicate<RT>\n) => PredicateInternalsKey[];\n\nexport type ValuePredicate<\n\tRT extends PersistentModel,\n\tMT extends MatchableTypes\n> = {\n\t[K in AllFieldOperators]: K extends 'between'\n\t\t? (\n\t\t\t\tinclusiveLowerBound: Scalar<MT>,\n\t\t\t\tinclusiveUpperBound: Scalar<MT>\n\t\t  ) => PredicateInternalsKey\n\t\t: (operand: Scalar<MT>) => PredicateInternalsKey;\n};\n\nexport type V5ModelPredicate<RT extends PersistentModel> = WithoutNevers<{\n\t[K in keyof RT]-?: PredicateFieldType<RT[K]> extends PersistentModel\n\t\t? never\n\t\t: ValuePredicate<RT, RT[K]>;\n}> & {\n\tor: ModelPredicateOperator<RT>;\n\tand: ModelPredicateOperator<RT>;\n\tnot: ModelPredicateNegation<RT>;\n} & PredicateInternalsKey;\n\nexport type ModelPredicateOperator<RT extends PersistentModel> = (\n\tpredicates: ModelPredicateAggregateExtender<RT>\n) => PredicateInternalsKey;\n\nexport type ModelPredicateNegation<RT extends PersistentModel> = (\n\tpredicate: ModelPredicateExtender<RT>\n) => PredicateInternalsKey;\n\n/**\n * A pointer used by DataStore internally to lookup predicate details\n * that should not be exposed on public customer interfaces.\n */\nexport class PredicateInternalsKey {\n\tprivate __isPredicateInternalsKeySentinel: boolean = true;\n}\n\n// #endregion\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}