{"ast":null,"code":"import { NO_RETRY_INCREMENT, RETRY_COST, TIMEOUT_RETRY_COST } from \"./constants\";\nexport var getDefaultRetryQuota = function (initialRetryTokens) {\n  var MAX_CAPACITY = initialRetryTokens;\n  var availableCapacity = initialRetryTokens;\n  var getCapacityAmount = function (error) {\n    return error.name === \"TimeoutError\" ? TIMEOUT_RETRY_COST : RETRY_COST;\n  };\n  var hasRetryTokens = function (error) {\n    return getCapacityAmount(error) <= availableCapacity;\n  };\n  var retrieveRetryTokens = function (error) {\n    if (!hasRetryTokens(error)) {\n      // retryStrategy should stop retrying, and return last error\n      throw new Error(\"No retry token available\");\n    }\n    var capacityAmount = getCapacityAmount(error);\n    availableCapacity -= capacityAmount;\n    return capacityAmount;\n  };\n  var releaseRetryTokens = function (capacityReleaseAmount) {\n    availableCapacity += capacityReleaseAmount !== null && capacityReleaseAmount !== void 0 ? capacityReleaseAmount : NO_RETRY_INCREMENT;\n    availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);\n  };\n  return Object.freeze({\n    hasRetryTokens: hasRetryTokens,\n    retrieveRetryTokens: retrieveRetryTokens,\n    releaseRetryTokens: releaseRetryTokens\n  });\n};","map":{"version":3,"names":["NO_RETRY_INCREMENT","RETRY_COST","TIMEOUT_RETRY_COST","getDefaultRetryQuota","initialRetryTokens","MAX_CAPACITY","availableCapacity","getCapacityAmount","error","name","hasRetryTokens","retrieveRetryTokens","Error","capacityAmount","releaseRetryTokens","capacityReleaseAmount","Math","min","Object","freeze"],"sources":["/Users/yannellym/Desktop/iwantapet/node_modules/@aws-sdk/middleware-retry/src/defaultRetryQuota.ts"],"sourcesContent":["import { SdkError } from \"@aws-sdk/smithy-client\";\n\nimport { NO_RETRY_INCREMENT, RETRY_COST, TIMEOUT_RETRY_COST } from \"./constants\";\nimport { RetryQuota } from \"./defaultStrategy\";\n\nexport const getDefaultRetryQuota = (initialRetryTokens: number): RetryQuota => {\n  const MAX_CAPACITY = initialRetryTokens;\n  let availableCapacity = initialRetryTokens;\n\n  const getCapacityAmount = (error: SdkError) => (error.name === \"TimeoutError\" ? TIMEOUT_RETRY_COST : RETRY_COST);\n\n  const hasRetryTokens = (error: SdkError) => getCapacityAmount(error) <= availableCapacity;\n\n  const retrieveRetryTokens = (error: SdkError) => {\n    if (!hasRetryTokens(error)) {\n      // retryStrategy should stop retrying, and return last error\n      throw new Error(\"No retry token available\");\n    }\n    const capacityAmount = getCapacityAmount(error);\n    availableCapacity -= capacityAmount;\n    return capacityAmount;\n  };\n\n  const releaseRetryTokens = (capacityReleaseAmount?: number) => {\n    availableCapacity += capacityReleaseAmount ?? NO_RETRY_INCREMENT;\n    availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);\n  };\n\n  return Object.freeze({\n    hasRetryTokens,\n    retrieveRetryTokens,\n    releaseRetryTokens,\n  });\n};\n"],"mappings":"AAEA,SAASA,kBAAkB,EAAEC,UAAU,EAAEC,kBAAkB,QAAQ,aAAa;AAGhF,OAAO,IAAMC,oBAAoB,GAAG,SAAAA,CAACC,kBAA0B;EAC7D,IAAMC,YAAY,GAAGD,kBAAkB;EACvC,IAAIE,iBAAiB,GAAGF,kBAAkB;EAE1C,IAAMG,iBAAiB,GAAG,SAAAA,CAACC,KAAe;IAAK,OAACA,KAAK,CAACC,IAAI,KAAK,cAAc,GAAGP,kBAAkB,GAAGD,UAAU;EAAhE,CAAiE;EAEhH,IAAMS,cAAc,GAAG,SAAAA,CAACF,KAAe;IAAK,OAAAD,iBAAiB,CAACC,KAAK,CAAC,IAAIF,iBAAiB;EAA7C,CAA6C;EAEzF,IAAMK,mBAAmB,GAAG,SAAAA,CAACH,KAAe;IAC1C,IAAI,CAACE,cAAc,CAACF,KAAK,CAAC,EAAE;MAC1B;MACA,MAAM,IAAII,KAAK,CAAC,0BAA0B,CAAC;;IAE7C,IAAMC,cAAc,GAAGN,iBAAiB,CAACC,KAAK,CAAC;IAC/CF,iBAAiB,IAAIO,cAAc;IACnC,OAAOA,cAAc;EACvB,CAAC;EAED,IAAMC,kBAAkB,GAAG,SAAAA,CAACC,qBAA8B;IACxDT,iBAAiB,IAAIS,qBAAqB,aAArBA,qBAAqB,cAArBA,qBAAqB,GAAIf,kBAAkB;IAChEM,iBAAiB,GAAGU,IAAI,CAACC,GAAG,CAACX,iBAAiB,EAAED,YAAY,CAAC;EAC/D,CAAC;EAED,OAAOa,MAAM,CAACC,MAAM,CAAC;IACnBT,cAAc,EAAAA,cAAA;IACdC,mBAAmB,EAAAA,mBAAA;IACnBG,kBAAkB,EAAAA;GACnB,CAAC;AACJ,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}