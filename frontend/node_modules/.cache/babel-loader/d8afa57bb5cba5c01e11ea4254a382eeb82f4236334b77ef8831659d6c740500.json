{"ast":null,"code":"import { __assign, __asyncValues, __awaiter, __extends, __generator, __read, __rest, __spread, __values } from \"tslib\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { InternalAPI } from '@aws-amplify/api/internals';\nimport { Auth } from '@aws-amplify/auth';\nimport { Cache } from '@aws-amplify/cache';\nimport { Amplify, ConsoleLogger as Logger, Hub, browserOrNode, BackgroundProcessManager } from '@aws-amplify/core';\nimport { immerable, produce, setAutoFreeze, enablePatches } from 'immer';\nimport { v4 as uuid4 } from 'uuid';\nimport Observable from 'zen-observable-ts';\nimport { defaultAuthStrategy, multiAuthStrategy } from '../authModeStrategies';\nimport { isPredicatesAll, ModelPredicateCreator, ModelSortPredicateCreator } from '../predicates';\nimport { ExclusiveStorage as Storage } from '../storage/storage';\nimport { ModelRelationship } from '../storage/relationship';\nimport { ControlMessage, SyncEngine } from '../sync';\nimport { GraphQLScalarType, isGraphQLScalarType, isSchemaModelWithAttributes, AuthModeStrategyType, isNonModelFieldType, isModelFieldType, isIdentifierObject } from '../types';\nimport { DATASTORE, errorMessages, establishRelationAndKeys, isModelConstructor, monotonicUlidFactory, STORAGE, SYNC, USER, isNullOrUndefined, registerNonModelClass, sortCompareFunction, DeferredCallbackResolver, inMemoryPagination, extractPrimaryKeyFieldNames, extractPrimaryKeysAndValues, isIdManaged, isIdOptionallyManaged, mergePatches, getTimestampFields } from '../util';\nimport { recursivePredicateFor, predicateFor, internals } from '../predicates/next';\nimport { getIdentifierValue } from '../sync/utils';\nsetAutoFreeze(true);\nenablePatches();\nvar logger = new Logger('DataStore');\nvar ulid = monotonicUlidFactory(Date.now());\nvar isNode = browserOrNode().isNode;\nvar SETTING_SCHEMA_VERSION = 'schemaVersion';\nvar schema;\nvar modelNamespaceMap = new WeakMap();\n/**\n * Stores data for crafting the correct update mutation input for a model.\n *\n * - `Patch[]` - array of changed fields and metadata.\n * - `PersistentModel` - the source model, used for diffing object-type fields.\n */\nvar modelPatchesMap = new WeakMap();\nvar getModelDefinition = function (modelConstructor) {\n  var namespace = modelNamespaceMap.get(modelConstructor);\n  var definition = namespace ? schema.namespaces[namespace].models[modelConstructor.name] : undefined;\n  return definition;\n};\n/**\n * Determines whether the given object is a Model Constructor that DataStore can\n * safely use to construct objects and discover related metadata.\n *\n * @param obj The object to test.\n */\nvar isValidModelConstructor = function (obj) {\n  return isModelConstructor(obj) && modelNamespaceMap.has(obj);\n};\nvar namespaceResolver = function (modelConstructor) {\n  var resolver = modelNamespaceMap.get(modelConstructor);\n  if (!resolver) {\n    throw new Error(\"Namespace Resolver for '\" + modelConstructor.name + \"' not found! This is probably a bug in '@amplify-js/datastore'.\");\n  }\n  return resolver;\n};\n/**\n * Creates a predicate without any conditions that can be passed to customer\n * code to have conditions added to it.\n *\n * For example, in this query:\n *\n * ```ts\n * await DataStore.query(\n * \tModel,\n * \titem => item.field.eq('value')\n * );\n * ```\n *\n * `buildSeedPredicate(Model)` is used to create `item`, which is passed to the\n * predicate function, which in turn uses that \"seed\" predicate (`item`) to build\n * a predicate tree.\n *\n * @param modelConstructor The model the predicate will query.\n */\nvar buildSeedPredicate = function (modelConstructor) {\n  if (!modelConstructor) throw new Error('Missing modelConstructor');\n  var modelSchema = getModelDefinition(modelConstructor);\n  if (!modelSchema) throw new Error('Missing modelSchema');\n  var pks = extractPrimaryKeyFieldNames(modelSchema);\n  if (!pks) throw new Error('Could not determine PK');\n  return recursivePredicateFor({\n    builder: modelConstructor,\n    schema: modelSchema,\n    pkField: pks\n  });\n};\n// exporting syncClasses for testing outbox.test.ts\nexport var syncClasses;\nvar userClasses;\nvar dataStoreClasses;\nvar storageClasses;\n/**\n * Maps a model to its related models for memoization/immutability.\n */\nvar modelInstanceAssociationsMap = new WeakMap();\n/**\n * Describes whether and to what a model is attached for lazy loading purposes.\n */\nvar ModelAttachment;\n(function (ModelAttachment) {\n  /**\n   * Model doesn't lazy load from any data source.\n   *\n   * Related entity properties provided at instantiation are returned\n   * via the respective lazy interfaces when their properties are invoked.\n   */\n  ModelAttachment[\"Detached\"] = \"Detached\";\n  /**\n   * Model lazy loads from the global DataStore.\n   */\n  ModelAttachment[\"DataStore\"] = \"DataStore\";\n  /**\n   * Demonstrative. Not yet implemented.\n   */\n  ModelAttachment[\"API\"] = \"API\";\n})(ModelAttachment || (ModelAttachment = {}));\n/**\n * Tells us which data source a model is attached to (lazy loads from).\n *\n * If `Deatched`, the model's lazy properties will only ever return properties\n * from memory provided at construction time.\n */\nvar attachedModelInstances = new WeakMap();\n/**\n * Registers a model instance against a data source (DataStore, API, or\n * Detached/None).\n *\n * The API option is demonstrative. Lazy loading against API is not yet\n * implemented.\n *\n * @param result A model instance or array of instances\n * @param attachment A ModelAttachment data source\n * @returns passes the `result` back through after attachment\n */\nexport function attached(result, attachment) {\n  if (Array.isArray(result)) {\n    result.map(function (record) {\n      return attached(record, attachment);\n    });\n  } else {\n    result && attachedModelInstances.set(result, attachment);\n  }\n  return result;\n}\n/**\n * Determines what source a model instance should lazy load from.\n *\n * If the instace was never explicitly registered, it is detached by default.\n *\n * @param instance A model instance\n */\nexport var getAttachment = function (instance) {\n  return attachedModelInstances.has(instance) ? attachedModelInstances.get(instance) : ModelAttachment.Detached;\n};\nvar initSchema = function (userSchema) {\n  var _a;\n  if (schema !== undefined) {\n    console.warn('The schema has already been initialized');\n    return userClasses;\n  }\n  logger.log('validating schema', {\n    schema: userSchema\n  });\n  checkSchemaCodegenVersion(userSchema.codegenVersion);\n  var internalUserNamespace = __assign({\n    name: USER\n  }, userSchema);\n  logger.log('DataStore', 'Init models');\n  userClasses = createTypeClasses(internalUserNamespace);\n  logger.log('DataStore', 'Models initialized');\n  var dataStoreNamespace = getNamespace();\n  var storageNamespace = Storage.getNamespace();\n  var syncNamespace = SyncEngine.getNamespace();\n  dataStoreClasses = createTypeClasses(dataStoreNamespace);\n  storageClasses = createTypeClasses(storageNamespace);\n  syncClasses = createTypeClasses(syncNamespace);\n  schema = {\n    namespaces: (_a = {}, _a[dataStoreNamespace.name] = dataStoreNamespace, _a[internalUserNamespace.name] = internalUserNamespace, _a[storageNamespace.name] = storageNamespace, _a[syncNamespace.name] = syncNamespace, _a),\n    version: userSchema.version,\n    codegenVersion: userSchema.codegenVersion\n  };\n  Object.keys(schema.namespaces).forEach(function (namespace) {\n    var e_1, _a;\n    var _b = __read(establishRelationAndKeys(schema.namespaces[namespace]), 2),\n      relations = _b[0],\n      keys = _b[1];\n    schema.namespaces[namespace].relationships = relations;\n    schema.namespaces[namespace].keys = keys;\n    var modelAssociations = new Map();\n    Object.values(schema.namespaces[namespace].models).forEach(function (model) {\n      var e_2, _a, e_3, _b;\n      var connectedModels = [];\n      Object.values(model.fields).filter(function (field) {\n        return field.association && field.association.connectionType === 'BELONGS_TO' && field.type.model !== model.name;\n      }).forEach(function (field) {\n        return connectedModels.push(field.type.model);\n      });\n      modelAssociations.set(model.name, connectedModels);\n      // Precompute model info (such as pk fields) so that downstream schema consumers\n      // (such as predicate builders) don't have to reach back into \"DataStore\" space\n      // to go looking for it.\n      Object.values(model.fields).forEach(function (field) {\n        var relatedModel = userClasses[field.type.model];\n        if (isModelConstructor(relatedModel)) {\n          Object.defineProperty(field.type, 'modelConstructor', {\n            get: function () {\n              var relatedModelDefinition = getModelDefinition(relatedModel);\n              if (!relatedModelDefinition) throw new Error(\"Could not find model definition for \" + relatedModel.name);\n              return {\n                builder: relatedModel,\n                schema: relatedModelDefinition,\n                pkField: extractPrimaryKeyFieldNames(relatedModelDefinition)\n              };\n            }\n          });\n        }\n      });\n      // compatibility with legacy/pre-PK codegen for lazy loading to inject\n      // index fields into the model definition.\n      // definition.cloudFields = { ...definition.fields };\n      var indexes = schema.namespaces[namespace].relationships[model.name].indexes;\n      var indexFields = new Set();\n      try {\n        for (var indexes_1 = __values(indexes), indexes_1_1 = indexes_1.next(); !indexes_1_1.done; indexes_1_1 = indexes_1.next()) {\n          var index = indexes_1_1.value;\n          try {\n            for (var _c = (e_3 = void 0, __values(index[1])), _d = _c.next(); !_d.done; _d = _c.next()) {\n              var indexField = _d.value;\n              indexFields.add(indexField);\n            }\n          } catch (e_3_1) {\n            e_3 = {\n              error: e_3_1\n            };\n          } finally {\n            try {\n              if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n            } finally {\n              if (e_3) throw e_3.error;\n            }\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (indexes_1_1 && !indexes_1_1.done && (_a = indexes_1.return)) _a.call(indexes_1);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n      model.allFields = __assign(__assign({}, Object.fromEntries(__spread(indexFields.values()).map(function (name) {\n        return [name, {\n          name: name,\n          type: 'ID',\n          isArray: false\n        }];\n      }))), model.fields);\n    });\n    var result = new Map();\n    var count = 1000;\n    while (true && count > 0) {\n      if (modelAssociations.size === 0) {\n        break;\n      }\n      count--;\n      if (count === 0) {\n        throw new Error('Models are not topologically sortable. Please verify your schema.');\n      }\n      try {\n        for (var _c = (e_1 = void 0, __values(Array.from(modelAssociations.keys()))), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var modelName = _d.value;\n          var parents = modelAssociations.get(modelName);\n          if (parents === null || parents === void 0 ? void 0 : parents.every(function (x) {\n            return result.has(x);\n          })) {\n            result.set(modelName, parents);\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n      Array.from(result.keys()).forEach(function (x) {\n        return modelAssociations.delete(x);\n      });\n    }\n    schema.namespaces[namespace].modelTopologicalOrdering = result;\n  });\n  return userClasses;\n};\n/**\n * Throws an exception if the schema has *not* been initialized\n * by `initSchema()`.\n *\n * **To be called before trying to access schema.**\n *\n * Currently this only needs to be called in `start()` and `clear()` because\n * all other functions will call start first.\n */\nvar checkSchemaInitialized = function () {\n  if (schema === undefined) {\n    var message = 'Schema is not initialized. DataStore will not function as expected. This could happen if you have multiple versions of DataStore installed. Please see https://docs.amplify.aws/lib/troubleshooting/upgrading/q/platform/js/#check-for-duplicate-versions';\n    logger.error(message);\n    throw new Error(message);\n  }\n};\n/**\n * Throws an exception if the schema is using a codegen version that is not supported.\n *\n * Set the supported version by setting majorVersion and minorVersion\n * This functions similar to ^ version range.\n * The tested codegenVersion major version must exactly match the set majorVersion\n * The tested codegenVersion minor version must be gt or equal to the set minorVersion\n * Example: For a min supported version of 5.4.0 set majorVersion = 5 and minorVersion = 4\n *\n * This regex will not work when setting a supported range with minor version\n * of 2 or more digits.\n * i.e. minorVersion = 10 will not work\n * The regex will work for testing a codegenVersion with multi digit minor\n * versions as long as the minimum minorVersion is single digit.\n * i.e. codegenVersion = 5.30.1, majorVersion = 5, minorVersion = 4 PASSES\n *\n * @param codegenVersion schema codegenVersion\n */\nvar checkSchemaCodegenVersion = function (codegenVersion) {\n  var majorVersion = 3;\n  var minorVersion = 2;\n  var isValid = false;\n  try {\n    var versionParts = codegenVersion.split('.');\n    var _a = __read(versionParts, 4),\n      major = _a[0],\n      minor = _a[1],\n      patch = _a[2],\n      patchrevision = _a[3];\n    isValid = Number(major) === majorVersion && Number(minor) >= minorVersion;\n  } catch (err) {\n    console.log(\"Error parsing codegen version: \" + codegenVersion + \"\\n\" + err);\n  }\n  if (!isValid) {\n    var message = \"Models were generated with an unsupported version of codegen. Codegen artifacts are from \" + (codegenVersion || 'an unknown version') + \", whereas ^\" + majorVersion + \".\" + minorVersion + \".0 is required. \" + \"Update to the latest CLI and run 'amplify codegen models'.\";\n    logger.error(message);\n    throw new Error(message);\n  }\n};\nvar createTypeClasses = function (namespace) {\n  var classes = {};\n  Object.entries(namespace.models).forEach(function (_a) {\n    var _b = __read(_a, 2),\n      modelName = _b[0],\n      modelDefinition = _b[1];\n    var clazz = createModelClass(modelDefinition);\n    classes[modelName] = clazz;\n    modelNamespaceMap.set(clazz, namespace.name);\n  });\n  Object.entries(namespace.nonModels || {}).forEach(function (_a) {\n    var _b = __read(_a, 2),\n      typeName = _b[0],\n      typeDefinition = _b[1];\n    var clazz = createNonModelClass(typeDefinition);\n    classes[typeName] = clazz;\n  });\n  return classes;\n};\n/**\n * Collection of instantiated models to allow storage of metadata apart from\n * the model visible to the consuming app -- in case the app doesn't have\n * metadata fields (_version, _deleted, etc.) exposed on the model itself.\n */\nvar instancesMetadata = new WeakSet();\nfunction modelInstanceCreator(modelConstructor, init) {\n  instancesMetadata.add(init);\n  return new modelConstructor(init);\n}\nvar validateModelFields = function (modelDefinition) {\n  return function (k, v) {\n    var fieldDefinition = modelDefinition.fields[k];\n    if (fieldDefinition !== undefined) {\n      var type_1 = fieldDefinition.type,\n        isRequired_1 = fieldDefinition.isRequired,\n        isArrayNullable = fieldDefinition.isArrayNullable,\n        name_1 = fieldDefinition.name,\n        isArray = fieldDefinition.isArray;\n      var timestamps = isSchemaModelWithAttributes(modelDefinition) ? getTimestampFields(modelDefinition) : {};\n      var isTimestampField = !!timestamps[name_1];\n      if ((!isArray && isRequired_1 || isArray && !isArrayNullable) && !isTimestampField && (v === null || v === undefined)) {\n        throw new Error(\"Field \" + name_1 + \" is required\");\n      }\n      if (isSchemaModelWithAttributes(modelDefinition) && !isIdManaged(modelDefinition)) {\n        var keys = extractPrimaryKeyFieldNames(modelDefinition);\n        if (keys.includes(k) && v === '') {\n          logger.error(errorMessages.idEmptyString, {\n            k: k,\n            value: v\n          });\n          throw new Error(errorMessages.idEmptyString);\n        }\n      }\n      if (isGraphQLScalarType(type_1)) {\n        var jsType_1 = GraphQLScalarType.getJSType(type_1);\n        var validateScalar_1 = GraphQLScalarType.getValidationFunction(type_1);\n        if (type_1 === 'AWSJSON') {\n          if (typeof v === jsType_1) {\n            return;\n          }\n          if (typeof v === 'string') {\n            try {\n              JSON.parse(v);\n              return;\n            } catch (error) {\n              throw new Error(\"Field \" + name_1 + \" is an invalid JSON object. \" + v);\n            }\n          }\n        }\n        if (isArray) {\n          var errorTypeText = jsType_1;\n          if (!isRequired_1) {\n            errorTypeText = jsType_1 + \" | null | undefined\";\n          }\n          if (!Array.isArray(v) && !isArrayNullable) {\n            throw new Error(\"Field \" + name_1 + \" should be of type [\" + errorTypeText + \"], \" + typeof v + \" received. \" + v);\n          }\n          if (!isNullOrUndefined(v) && v.some(function (e) {\n            return isNullOrUndefined(e) ? isRequired_1 : typeof e !== jsType_1;\n          })) {\n            var elemTypes = v.map(function (e) {\n              return e === null ? 'null' : typeof e;\n            }).join(',');\n            throw new Error(\"All elements in the \" + name_1 + \" array should be of type \" + errorTypeText + \", [\" + elemTypes + \"] received. \" + v);\n          }\n          if (validateScalar_1 && !isNullOrUndefined(v)) {\n            var validationStatus = v.map(function (e) {\n              if (!isNullOrUndefined(e)) {\n                return validateScalar_1(e);\n              } else if (isNullOrUndefined(e) && !isRequired_1) {\n                return true;\n              } else {\n                return false;\n              }\n            });\n            if (!validationStatus.every(function (s) {\n              return s;\n            })) {\n              throw new Error(\"All elements in the \" + name_1 + \" array should be of type \" + type_1 + \", validation failed for one or more elements. \" + v);\n            }\n          }\n        } else if (!isRequired_1 && v === undefined) {\n          return;\n        } else if (typeof v !== jsType_1 && v !== null) {\n          throw new Error(\"Field \" + name_1 + \" should be of type \" + jsType_1 + \", \" + typeof v + \" received. \" + v);\n        } else if (!isNullOrUndefined(v) && validateScalar_1 && !validateScalar_1(v) // TODO: why never, TS ... why ...\n        ) {\n          throw new Error(\"Field \" + name_1 + \" should be of type \" + type_1 + \", validation failed. \" + v);\n        }\n      } else if (isNonModelFieldType(type_1)) {\n        // do not check non model fields if undefined or null\n        if (!isNullOrUndefined(v)) {\n          var subNonModelDefinition_1 = schema.namespaces.user.nonModels[type_1.nonModel];\n          var modelValidator_1 = validateModelFields(subNonModelDefinition_1);\n          if (isArray) {\n            var errorTypeText = type_1.nonModel;\n            if (!isRequired_1) {\n              errorTypeText = type_1.nonModel + \" | null | undefined\";\n            }\n            if (!Array.isArray(v)) {\n              throw new Error(\"Field \" + name_1 + \" should be of type [\" + errorTypeText + \"], \" + typeof v + \" received. \" + v);\n            }\n            v.forEach(function (item) {\n              if (isNullOrUndefined(item) && isRequired_1 || typeof item !== 'object' && typeof item !== 'undefined') {\n                throw new Error(\"All elements in the \" + name_1 + \" array should be of type \" + type_1.nonModel + \", [\" + typeof item + \"] received. \" + item);\n              }\n              if (!isNullOrUndefined(item)) {\n                Object.keys(subNonModelDefinition_1.fields).forEach(function (subKey) {\n                  modelValidator_1(subKey, item[subKey]);\n                });\n              }\n            });\n          } else {\n            if (typeof v !== 'object') {\n              throw new Error(\"Field \" + name_1 + \" should be of type \" + type_1.nonModel + \", \" + typeof v + \" recieved. \" + v);\n            }\n            Object.keys(subNonModelDefinition_1.fields).forEach(function (subKey) {\n              modelValidator_1(subKey, v[subKey]);\n            });\n          }\n        }\n      }\n    }\n  };\n};\nvar castInstanceType = function (modelDefinition, k, v) {\n  var _a = modelDefinition.fields[k] || {},\n    isArray = _a.isArray,\n    type = _a.type;\n  // attempt to parse stringified JSON\n  if (typeof v === 'string' && (isArray || type === 'AWSJSON' || isNonModelFieldType(type) || isModelFieldType(type))) {\n    try {\n      return JSON.parse(v);\n    } catch (_b) {\n      // if JSON is invalid, don't throw and let modelValidator handle it\n    }\n  }\n  // cast from numeric representation of boolean to JS boolean\n  if (typeof v === 'number' && type === 'Boolean') {\n    return Boolean(v);\n  }\n  return v;\n};\n/**\n * Records the patches (as if against an empty object) used to initialize\n * an instance of a Model. This can be used for determining which fields to\n * send to the cloud durnig a CREATE mutation.\n */\nvar initPatches = new WeakMap();\n/**\n * Attempts to apply type-aware, casted field values from a given `init`\n * object to the given `draft`.\n *\n * @param init The initialization object to extract field values from.\n * @param modelDefinition The definition describing the target object shape.\n * @param draft The draft to apply field values to.\n */\nvar initializeInstance = function (init, modelDefinition, draft) {\n  var modelValidator = validateModelFields(modelDefinition);\n  Object.entries(init).forEach(function (_a) {\n    var _b = __read(_a, 2),\n      k = _b[0],\n      v = _b[1];\n    var parsedValue = castInstanceType(modelDefinition, k, v);\n    modelValidator(k, parsedValue);\n    draft[k] = parsedValue;\n  });\n};\n/**\n * Updates a draft to standardize its customer-defined fields so that they are\n * consistent with the data as it would look after having been synchronized from\n * Cloud storage.\n *\n * The exceptions to this are:\n *\n * 1. Non-schema/Internal [sync] metadata fields.\n * 2. Cloud-managed fields, which are `null` until set by cloud storage.\n *\n * This function should be expanded if/when deviations between canonical Cloud\n * storage data and locally managed data are found. For now, the known areas\n * that require normalization are:\n *\n * 1. Ensuring all non-metadata fields are *defined*. (I.e., turn `undefined` -> `null`.)\n *\n * @param modelDefinition Definition for the draft. Used to discover all fields.\n * @param draft The instance draft to apply normalizations to.\n */\nvar normalize = function (modelDefinition, draft) {\n  var e_4, _a;\n  try {\n    for (var _b = __values(Object.keys(modelDefinition.fields)), _c = _b.next(); !_c.done; _c = _b.next()) {\n      var k = _c.value;\n      if (draft[k] === undefined) draft[k] = null;\n    }\n  } catch (e_4_1) {\n    e_4 = {\n      error: e_4_1\n    };\n  } finally {\n    try {\n      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n    } finally {\n      if (e_4) throw e_4.error;\n    }\n  }\n};\nvar createModelClass = function (modelDefinition) {\n  var e_5, _a;\n  var clazz = /** @class */function () {\n    function Model(init) {\n      // we create a base instance first so we can distinguish which fields were explicitly\n      // set by customer code versus those set by normalization. only those fields\n      // which are explicitly set by customers should be part of create mutations.\n      var patches = [];\n      var baseInstance = produce(this, function (draft) {\n        initializeInstance(init, modelDefinition, draft);\n        // model is initialized inside a DataStore component (e.g. by Sync Engine, Storage Engine, etc.)\n        var isInternallyInitialized = instancesMetadata.has(init);\n        var modelInstanceMetadata = isInternallyInitialized ? init : {};\n        var _id = modelInstanceMetadata.id;\n        if (isIdManaged(modelDefinition)) {\n          var isInternalModel = _id !== null && _id !== undefined;\n          var id = isInternalModel ? _id : modelDefinition.syncable ? uuid4() : ulid();\n          draft.id = id;\n        } else if (isIdOptionallyManaged(modelDefinition)) {\n          // only auto-populate if the id was not provided\n          draft.id = draft.id || uuid4();\n        }\n        if (!isInternallyInitialized) {\n          checkReadOnlyPropertyOnCreate(draft, modelDefinition);\n        }\n        var _version = modelInstanceMetadata._version,\n          _lastChangedAt = modelInstanceMetadata._lastChangedAt,\n          _deleted = modelInstanceMetadata._deleted;\n        if (modelDefinition.syncable) {\n          draft._version = _version;\n          draft._lastChangedAt = _lastChangedAt;\n          draft._deleted = _deleted;\n        }\n      }, function (p) {\n        return patches = p;\n      });\n      // now that we have a list of patches that encapsulate the explicit, customer-provided\n      // fields, we can normalize. patches from normalization are ignored, because the changes\n      // are only create to provide a consistent view of the data for fields pre/post sync\n      // where possible. (not all fields can be normalized pre-sync, because they're generally\n      // \"cloud managed\" fields, like createdAt and updatedAt.)\n      var normalized = produce(baseInstance, function (draft) {\n        return normalize(modelDefinition, draft);\n      });\n      initPatches.set(normalized, patches);\n      return normalized;\n    }\n    Model.copyOf = function (source, fn) {\n      var modelConstructor = Object.getPrototypeOf(source || {}).constructor;\n      if (!isValidModelConstructor(modelConstructor)) {\n        var msg = 'The source object is not a valid model';\n        logger.error(msg, {\n          source: source\n        });\n        throw new Error(msg);\n      }\n      var patches = [];\n      var model = produce(source, function (draft) {\n        fn(draft);\n        var keyNames = extractPrimaryKeyFieldNames(modelDefinition);\n        // Keys are immutable\n        keyNames.forEach(function (key) {\n          if (draft[key] !== source[key]) {\n            logger.warn(\"copyOf() does not update PK fields. The '\" + key + \"' update is being ignored.\", {\n              source: source\n            });\n          }\n          draft[key] = source[key];\n        });\n        var modelValidator = validateModelFields(modelDefinition);\n        Object.entries(draft).forEach(function (_a) {\n          var _b = __read(_a, 2),\n            k = _b[0],\n            v = _b[1];\n          var parsedValue = castInstanceType(modelDefinition, k, v);\n          modelValidator(k, parsedValue);\n        });\n        normalize(modelDefinition, draft);\n      }, function (p) {\n        return patches = p;\n      });\n      var hasExistingPatches = modelPatchesMap.has(source);\n      if (patches.length || hasExistingPatches) {\n        if (hasExistingPatches) {\n          var _a = __read(modelPatchesMap.get(source), 2),\n            existingPatches = _a[0],\n            existingSource = _a[1];\n          var mergedPatches = mergePatches(existingSource, existingPatches, patches);\n          modelPatchesMap.set(model, [mergedPatches, existingSource]);\n          checkReadOnlyPropertyOnUpdate(mergedPatches, modelDefinition);\n        } else {\n          modelPatchesMap.set(model, [patches, source]);\n          checkReadOnlyPropertyOnUpdate(patches, modelDefinition);\n        }\n      } else {\n        // always register patches when performing a copyOf, even if the\n        // patches list is empty. this allows `save()` to recognize when an\n        // instance is the result of a `copyOf()`. without more significant\n        // refactoring, this is the only way for `save()` to know which\n        // diffs (patches) are relevant for `storage` to use in building\n        // the list of \"changed\" fields for mutations.\n        modelPatchesMap.set(model, [[], source]);\n      }\n      return attached(model, ModelAttachment.DataStore);\n    };\n    // \"private\" method (that's hidden via `Setting`) for `withSSRContext` to use\n    // to gain access to `modelInstanceCreator` and `clazz` for persisting IDs from server to client.\n    Model.fromJSON = function (json) {\n      var _this = this;\n      if (Array.isArray(json)) {\n        return json.map(function (init) {\n          return _this.fromJSON(init);\n        });\n      }\n      var instance = modelInstanceCreator(clazz, json);\n      var modelValidator = validateModelFields(modelDefinition);\n      Object.entries(instance).forEach(function (_a) {\n        var _b = __read(_a, 2),\n          k = _b[0],\n          v = _b[1];\n        modelValidator(k, v);\n      });\n      return attached(instance, ModelAttachment.DataStore);\n    };\n    return Model;\n  }();\n  clazz[immerable] = true;\n  Object.defineProperty(clazz, 'name', {\n    value: modelDefinition.name\n  });\n  // Add getters/setters for relationship fields.\n  //  getter - for lazy loading\n  //  setter - for FK management\n  var allModelRelationships = ModelRelationship.allFrom({\n    builder: clazz,\n    schema: modelDefinition,\n    pkField: extractPrimaryKeyFieldNames(modelDefinition)\n  });\n  var _loop_1 = function (relationship) {\n    var field = relationship.field;\n    Object.defineProperty(clazz.prototype, modelDefinition.fields[field].name, {\n      set: function (model) {\n        if (!(typeof model === 'object' || typeof model === 'undefined')) return;\n        // if model is undefined or null, the connection should be removed\n        if (model) {\n          // Avoid validation error when processing AppSync response with nested\n          // selection set. Nested entitites lack version field and can not be validated\n          // TODO: explore a more reliable method to solve this\n          if (model.hasOwnProperty('_version')) {\n            var modelConstructor = Object.getPrototypeOf(model || {}).constructor;\n            if (!isValidModelConstructor(modelConstructor)) {\n              var msg = \"Value passed to \" + modelDefinition.name + \".\" + field + \" is not a valid instance of a model\";\n              logger.error(msg, {\n                model: model\n              });\n              throw new Error(msg);\n            }\n            if (modelConstructor.name.toLowerCase() !== relationship.remoteModelConstructor.name.toLowerCase()) {\n              var msg = \"Value passed to \" + modelDefinition.name + \".\" + field + \" is not an instance of \" + relationship.remoteModelConstructor.name;\n              logger.error(msg, {\n                model: model\n              });\n              throw new Error(msg);\n            }\n          }\n        }\n        // if the relationship can be managed automagically, set the FK's\n        if (relationship.isComplete) {\n          for (var i = 0; i < relationship.localJoinFields.length; i++) {\n            this[relationship.localJoinFields[i]] = model === null || model === void 0 ? void 0 : model[relationship.remoteJoinFields[i]];\n          }\n          var instanceMemos = modelInstanceAssociationsMap.has(this) ? modelInstanceAssociationsMap.get(this) : modelInstanceAssociationsMap.set(this, {}).get(this);\n          instanceMemos[field] = model || undefined;\n        }\n      },\n      get: function () {\n        var _this = this;\n        /**\n         * Bucket for holding related models instances specific to `this` instance.\n         */\n        var instanceMemos = modelInstanceAssociationsMap.has(this) ? modelInstanceAssociationsMap.get(this) : modelInstanceAssociationsMap.set(this, {}).get(this);\n        // if the memos already has a result for this field, we'll use it.\n        // there is no \"cache\" invalidation of any kind; memos are permanent to\n        // keep an immutable perception of the instance.\n        if (!instanceMemos.hasOwnProperty(field)) {\n          // before we populate the memo, we need to know where to look for relatives.\n          // today, this only supports DataStore. Models aren't managed elsewhere in Amplify.\n          if (getAttachment(this) === ModelAttachment.DataStore) {\n            // when we fetch the results using a query constructed under the guidance\n            // of the relationship metadata, we DO NOT AWAIT resolution. we want to\n            // drop the promise into the memo's synchronously, eliminating the chance\n            // for a race.\n            var resultPromise = instance.query(relationship.remoteModelConstructor, function (base) {\n              return base.and(function (q) {\n                return relationship.remoteJoinFields.map(function (field, index) {\n                  // TODO: anything we can use instead of `any` here?\n                  return q[field].eq(_this[relationship.localJoinFields[index]]);\n                });\n              });\n            });\n            // results in hand, how we return them to the caller depends on the relationship type.\n            if (relationship.type === 'HAS_MANY') {\n              // collections should support async iteration, even though we don't\n              // leverage it fully [yet].\n              instanceMemos[field] = new AsyncCollection(resultPromise);\n            } else {\n              // non-collections should only ever return 1 value *or nothing*.\n              // if we have more than 1 record, something's amiss. it's not our job\n              // pick a result for the customer. it's our job to say \"something's wrong.\"\n              instanceMemos[field] = resultPromise.then(function (rows) {\n                if (rows.length > 1) {\n                  // should never happen for a HAS_ONE or BELONGS_TO.\n                  var err = new Error(\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tData integrity error.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tToo many records found for a HAS_ONE/BELONGS_TO field '\" + modelDefinition.name + \".\" + field + \"'\\n\\t\\t\\t\\t\\t\\t\\t\\t\");\n                  console.error(err);\n                  throw err;\n                } else {\n                  return rows[0];\n                }\n              });\n            }\n          } else if (getAttachment(this) === ModelAttachment.API) {\n            throw new Error('Lazy loading from API is not yet supported!');\n          } else {\n            if (relationship.type === 'HAS_MANY') {\n              return new AsyncCollection([]);\n            } else {\n              return Promise.resolve(undefined);\n            }\n          }\n        }\n        return instanceMemos[field];\n      }\n    });\n  };\n  try {\n    for (var allModelRelationships_1 = __values(allModelRelationships), allModelRelationships_1_1 = allModelRelationships_1.next(); !allModelRelationships_1_1.done; allModelRelationships_1_1 = allModelRelationships_1.next()) {\n      var relationship = allModelRelationships_1_1.value;\n      _loop_1(relationship);\n    }\n  } catch (e_5_1) {\n    e_5 = {\n      error: e_5_1\n    };\n  } finally {\n    try {\n      if (allModelRelationships_1_1 && !allModelRelationships_1_1.done && (_a = allModelRelationships_1.return)) _a.call(allModelRelationships_1);\n    } finally {\n      if (e_5) throw e_5.error;\n    }\n  }\n  return clazz;\n};\n/**\n * An eventually loaded related model instance.\n */\nvar AsyncItem = /** @class */function (_super) {\n  __extends(AsyncItem, _super);\n  function AsyncItem() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  return AsyncItem;\n}(Promise);\nexport { AsyncItem };\n/**\n * A collection of related model instances.\n *\n * This collection can be async-iterated or turned directly into an array using `toArray()`.\n */\nvar AsyncCollection = /** @class */function () {\n  function AsyncCollection(values) {\n    this.values = values;\n  }\n  /**\n   * Facilitates async iteration.\n   *\n   * ```ts\n   * for await (const item of collection) {\n   *   handle(item)\n   * }\n   * ```\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of\n   */\n  AsyncCollection.prototype[Symbol.asyncIterator] = function () {\n    var _this = this;\n    var values;\n    var index = 0;\n    return {\n      next: function () {\n        return __awaiter(_this, void 0, void 0, function () {\n          var result;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                if (!!values) return [3 /*break*/, 2];\n                return [4 /*yield*/, this.values];\n              case 1:\n                values = _a.sent();\n                _a.label = 2;\n              case 2:\n                if (index < values.length) {\n                  result = {\n                    value: values[index],\n                    done: false\n                  };\n                  index++;\n                  return [2 /*return*/, result];\n                }\n                return [2 /*return*/, {\n                  value: null,\n                  done: true\n                }];\n            }\n          });\n        });\n      }\n    };\n  };\n  /**\n   * Turns the collection into an array, up to the amount specified in `max` param.\n   *\n   * ```ts\n   * const all = await collection.toArray();\n   * const first100 = await collection.toArray({max: 100});\n   * ```\n   */\n  AsyncCollection.prototype.toArray = function (_a) {\n    var _b = (_a === void 0 ? {} : _a).max,\n      max = _b === void 0 ? Number.MAX_SAFE_INTEGER : _b;\n    var e_6, _c;\n    return __awaiter(this, void 0, void 0, function () {\n      var output, i, _d, _e, element, e_6_1;\n      return __generator(this, function (_f) {\n        switch (_f.label) {\n          case 0:\n            output = [];\n            i = 0;\n            _f.label = 1;\n          case 1:\n            _f.trys.push([1, 6, 7, 12]);\n            _d = __asyncValues(this);\n            _f.label = 2;\n          case 2:\n            return [4 /*yield*/, _d.next()];\n          case 3:\n            if (!(_e = _f.sent(), !_e.done)) return [3 /*break*/, 5];\n            element = _e.value;\n            if (i < max) {\n              output.push(element);\n              i++;\n            } else {\n              return [3 /*break*/, 5];\n            }\n            _f.label = 4;\n          case 4:\n            return [3 /*break*/, 2];\n          case 5:\n            return [3 /*break*/, 12];\n          case 6:\n            e_6_1 = _f.sent();\n            e_6 = {\n              error: e_6_1\n            };\n            return [3 /*break*/, 12];\n          case 7:\n            _f.trys.push([7,, 10, 11]);\n            if (!(_e && !_e.done && (_c = _d.return))) return [3 /*break*/, 9];\n            return [4 /*yield*/, _c.call(_d)];\n          case 8:\n            _f.sent();\n            _f.label = 9;\n          case 9:\n            return [3 /*break*/, 11];\n          case 10:\n            if (e_6) throw e_6.error;\n            return [7 /*endfinally*/];\n          case 11:\n            return [7 /*endfinally*/];\n          case 12:\n            return [2 /*return*/, output];\n        }\n      });\n    });\n  };\n  return AsyncCollection;\n}();\nexport { AsyncCollection };\nvar checkReadOnlyPropertyOnCreate = function (draft, modelDefinition) {\n  var modelKeys = Object.keys(draft);\n  var fields = modelDefinition.fields;\n  modelKeys.forEach(function (key) {\n    if (fields[key] && fields[key].isReadOnly) {\n      throw new Error(key + \" is read-only.\");\n    }\n  });\n};\nvar checkReadOnlyPropertyOnUpdate = function (patches, modelDefinition) {\n  var patchArray = patches.map(function (p) {\n    return [p.path[0], p.value];\n  });\n  var fields = modelDefinition.fields;\n  patchArray.forEach(function (_a) {\n    var _b = __read(_a, 2),\n      key = _b[0],\n      val = _b[1];\n    if (!val || !fields[key]) return;\n    if (fields[key].isReadOnly) {\n      throw new Error(key + \" is read-only.\");\n    }\n  });\n};\nvar createNonModelClass = function (typeDefinition) {\n  var clazz = /** @class */function () {\n    function Model(init) {\n      var instance = produce(this, function (draft) {\n        initializeInstance(init, typeDefinition, draft);\n      });\n      return instance;\n    }\n    return Model;\n  }();\n  clazz[immerable] = true;\n  Object.defineProperty(clazz, 'name', {\n    value: typeDefinition.name\n  });\n  registerNonModelClass(clazz);\n  return clazz;\n};\nfunction isQueryOne(obj) {\n  return typeof obj === 'string';\n}\nfunction defaultConflictHandler(conflictData) {\n  var localModel = conflictData.localModel,\n    modelConstructor = conflictData.modelConstructor,\n    remoteModel = conflictData.remoteModel;\n  var _version = remoteModel._version;\n  return modelInstanceCreator(modelConstructor, __assign(__assign({}, localModel), {\n    _version: _version\n  }));\n}\nfunction defaultErrorHandler(error) {\n  logger.warn(error);\n}\nfunction getModelConstructorByModelName(namespaceName, modelName) {\n  var result;\n  switch (namespaceName) {\n    case DATASTORE:\n      result = dataStoreClasses[modelName];\n      break;\n    case USER:\n      result = userClasses[modelName];\n      break;\n    case SYNC:\n      result = syncClasses[modelName];\n      break;\n    case STORAGE:\n      result = storageClasses[modelName];\n      break;\n    default:\n      throw new Error(\"Invalid namespace: \" + namespaceName);\n  }\n  if (isValidModelConstructor(result)) {\n    return result;\n  } else {\n    var msg = \"Model name is not valid for namespace. modelName: \" + modelName + \", namespace: \" + namespaceName;\n    logger.error(msg);\n    throw new Error(msg);\n  }\n}\n/**\n * Queries the DataStore metadata tables to see if they are the expected\n * version. If not, clobbers the whole DB. If so, leaves them alone.\n * Otherwise, simply writes the schema version.\n *\n * SIDE EFFECT:\n * 1. Creates a transaction\n * 1. Updates data.\n *\n * @param storage Storage adapter containing the metadata.\n * @param version The expected schema version.\n */\nfunction checkSchemaVersion(storage, version) {\n  return __awaiter(this, void 0, void 0, function () {\n    var Setting, modelDefinition;\n    var _this = this;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          Setting = dataStoreClasses.Setting;\n          modelDefinition = schema.namespaces[DATASTORE].models.Setting;\n          return [4 /*yield*/, storage.runExclusive(function (s) {\n            return __awaiter(_this, void 0, void 0, function () {\n              var _a, schemaVersionSetting, storedValue;\n              return __generator(this, function (_b) {\n                switch (_b.label) {\n                  case 0:\n                    return [4 /*yield*/, s.query(Setting, ModelPredicateCreator.createFromAST(modelDefinition, {\n                      and: {\n                        key: {\n                          eq: SETTING_SCHEMA_VERSION\n                        }\n                      }\n                    }), {\n                      page: 0,\n                      limit: 1\n                    })];\n                  case 1:\n                    _a = __read.apply(void 0, [_b.sent(), 1]), schemaVersionSetting = _a[0];\n                    if (!(schemaVersionSetting !== undefined && schemaVersionSetting.value !== undefined)) return [3 /*break*/, 4];\n                    storedValue = JSON.parse(schemaVersionSetting.value);\n                    if (!(storedValue !== version)) return [3 /*break*/, 3];\n                    return [4 /*yield*/, s.clear(false)];\n                  case 2:\n                    _b.sent();\n                    _b.label = 3;\n                  case 3:\n                    return [3 /*break*/, 6];\n                  case 4:\n                    return [4 /*yield*/, s.save(modelInstanceCreator(Setting, {\n                      key: SETTING_SCHEMA_VERSION,\n                      value: JSON.stringify(version)\n                    }))];\n                  case 5:\n                    _b.sent();\n                    _b.label = 6;\n                  case 6:\n                    return [2 /*return*/];\n                }\n              });\n            });\n          })];\n\n        case 1:\n          _a.sent();\n          return [2 /*return*/];\n      }\n    });\n  });\n}\n\nvar syncSubscription;\nfunction getNamespace() {\n  var namespace = {\n    name: DATASTORE,\n    relationships: {},\n    enums: {},\n    nonModels: {},\n    models: {\n      Setting: {\n        name: 'Setting',\n        pluralName: 'Settings',\n        syncable: false,\n        fields: {\n          id: {\n            name: 'id',\n            type: 'ID',\n            isRequired: true,\n            isArray: false\n          },\n          key: {\n            name: 'key',\n            type: 'String',\n            isRequired: true,\n            isArray: false\n          },\n          value: {\n            name: 'value',\n            type: 'String',\n            isRequired: true,\n            isArray: false\n          }\n        }\n      }\n    }\n  };\n  return namespace;\n}\nvar DataStoreState;\n(function (DataStoreState) {\n  DataStoreState[\"NotRunning\"] = \"Not Running\";\n  DataStoreState[\"Starting\"] = \"Starting\";\n  DataStoreState[\"Running\"] = \"Running\";\n  DataStoreState[\"Stopping\"] = \"Stopping\";\n  DataStoreState[\"Clearing\"] = \"Clearing\";\n})(DataStoreState || (DataStoreState = {}));\n// TODO: How can we get rid of the non-null assertions?\n// https://github.com/aws-amplify/amplify-js/pull/10477/files#r1007363485\nvar DataStore = /** @class */function () {\n  function DataStore() {\n    var _this = this;\n    // reference to configured category instances. Used for preserving SSR context\n    this.Auth = Auth;\n    this.InternalAPI = InternalAPI;\n    this.Cache = Cache;\n    // Non-null assertions (bang operator) have been added to most of these properties\n    // to make TS happy. These properties are all expected to be set immediately after\n    // construction.\n    // TODO: Refactor to use proper DI if possible. If not possible, change these to\n    // optionals and implement conditional checks throughout. Rinse/repeat on all\n    // sync engine processors, storage engine, adapters, etc..\n    this.amplifyConfig = {};\n    this.syncPredicates = new WeakMap();\n    // object that gets passed to descendent classes. Allows us to pass these down by reference\n    this.amplifyContext = {\n      Auth: this.Auth,\n      InternalAPI: this.InternalAPI,\n      Cache: this.Cache\n    };\n    /**\n     * **IMPORTANT!**\n     *\n     * Accumulator for background things that can **and MUST** be called when\n     * DataStore stops.\n     *\n     * These jobs **MUST** be *idempotent promises* that resolve ONLY\n     * once the intended jobs are completely finished and/or otherwise destroyed\n     * and cleaned up with ZERO outstanding:\n     *\n     * 1. side effects (e.g., state changes)\n     * 1. callbacks\n     * 1. subscriptions\n     * 1. calls to storage\n     * 1. *etc.*\n     *\n     * Methods that create pending promises, subscriptions, callbacks, or any\n     * type of side effect **MUST** be registered with the manager. And, a new\n     * manager must be created after each `exit()`.\n     *\n     * Failure to comply will put DataStore into a highly unpredictable state\n     * when it needs to stop or clear -- which occurs when restarting with new\n     * sync expressions, during testing, and potentially during app code\n     * recovery handling, etc..\n     *\n     * It is up to the discretion of each disposer whether to wait for job\n     * completion or to cancel operations and issue failures *as long as the\n     * disposer returns in a reasonable amount of time.*\n     *\n     * (Reasonable = *seconds*, not minutes.)\n     */\n    this.runningProcesses = new BackgroundProcessManager();\n    /**\n     * Indicates what state DataStore is in.\n     *\n     * Not [yet?] used for actual state management; but for messaging\n     * when errors occur, to help troubleshoot.\n     */\n    this.state = DataStoreState.NotRunning;\n    /**\n     * If not already done:\n     * 1. Attaches and initializes storage.\n     * 2. Loads the schema and records metadata.\n     * 3. If `this.amplifyConfig.aws_appsync_graphqlEndpoint` contains a URL,\n     * attaches a sync engine, starts it, and subscribes.\n     */\n    this.start = function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _this = this;\n        return __generator(this, function (_a) {\n          return [2 /*return*/, this.runningProcesses.add(function () {\n            return __awaiter(_this, void 0, void 0, function () {\n              var aws_appsync_graphqlEndpoint, _a, fullSyncIntervalInMilliseconds;\n              var _this = this;\n              return __generator(this, function (_b) {\n                switch (_b.label) {\n                  case 0:\n                    this.state = DataStoreState.Starting;\n                    if (!(this.initialized === undefined)) return [3 /*break*/, 1];\n                    logger.debug('Starting DataStore');\n                    this.initialized = new Promise(function (res, rej) {\n                      _this.initResolve = res;\n                      _this.initReject = rej;\n                    });\n                    return [3 /*break*/, 3];\n                  case 1:\n                    return [4 /*yield*/, this.initialized];\n                  case 2:\n                    _b.sent();\n                    return [2 /*return*/];\n                  case 3:\n                    this.storage = new Storage(schema, namespaceResolver, getModelConstructorByModelName, modelInstanceCreator, this.storageAdapter, this.sessionId);\n                    return [4 /*yield*/, this.storage.init()];\n                  case 4:\n                    _b.sent();\n                    checkSchemaInitialized();\n                    return [4 /*yield*/, checkSchemaVersion(this.storage, schema.version)];\n                  case 5:\n                    _b.sent();\n                    aws_appsync_graphqlEndpoint = this.amplifyConfig.aws_appsync_graphqlEndpoint;\n                    if (!aws_appsync_graphqlEndpoint) return [3 /*break*/, 7];\n                    logger.debug('GraphQL endpoint available', aws_appsync_graphqlEndpoint);\n                    _a = this;\n                    return [4 /*yield*/, this.processSyncExpressions()];\n                  case 6:\n                    _a.syncPredicates = _b.sent();\n                    this.sync = new SyncEngine(schema, namespaceResolver, syncClasses, userClasses, this.storage, modelInstanceCreator, this.conflictHandler, this.errorHandler, this.syncPredicates, this.amplifyConfig, this.authModeStrategy, this.amplifyContext, this.connectivityMonitor);\n                    fullSyncIntervalInMilliseconds = this.fullSyncInterval * 1000 * 60;\n                    syncSubscription = this.sync.start({\n                      fullSyncInterval: fullSyncIntervalInMilliseconds\n                    }).subscribe({\n                      next: function (_a) {\n                        var type = _a.type,\n                          data = _a.data;\n                        // In Node, we need to wait for queries to be synced to prevent returning empty arrays.\n                        // In the Browser, we can begin returning data once subscriptions are in place.\n                        var readyType = isNode ? ControlMessage.SYNC_ENGINE_SYNC_QUERIES_READY : ControlMessage.SYNC_ENGINE_STORAGE_SUBSCRIBED;\n                        if (type === readyType) {\n                          _this.initResolve();\n                        }\n                        Hub.dispatch('datastore', {\n                          event: type,\n                          data: data\n                        });\n                      },\n                      error: function (err) {\n                        logger.warn('Sync error', err);\n                        _this.initReject();\n                      }\n                    });\n                    return [3 /*break*/, 8];\n                  case 7:\n                    logger.warn(\"Data won't be synchronized. No GraphQL endpoint configured. Did you forget `Amplify.configure(awsconfig)`?\", {\n                      config: this.amplifyConfig\n                    });\n                    this.initResolve();\n                    _b.label = 8;\n                  case 8:\n                    return [4 /*yield*/, this.initialized];\n                  case 9:\n                    _b.sent();\n                    this.state = DataStoreState.Running;\n                    return [2 /*return*/];\n                }\n              });\n            });\n          }, 'datastore start').catch(this.handleAddProcError('DataStore.start()'))];\n        });\n      });\n    };\n    this.query = function (modelConstructor, identifierOrCriteria, paginationProducer) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _this = this;\n        return __generator(this, function (_a) {\n          return [2 /*return*/, this.runningProcesses.add(function () {\n            return __awaiter(_this, void 0, void 0, function () {\n              var result, msg, modelDefinition, pagination, keyFields, msg, predicate, predicate, seedPredicate, predicate, returnOne;\n              var _a;\n              var _b;\n              return __generator(this, function (_c) {\n                switch (_c.label) {\n                  case 0:\n                    return [4 /*yield*/, this.start()];\n                  case 1:\n                    _c.sent();\n                    if (!this.storage) {\n                      throw new Error('No storage to query');\n                    }\n                    //#region Input validation\n                    if (!isValidModelConstructor(modelConstructor)) {\n                      msg = 'Constructor is not for a valid model';\n                      logger.error(msg, {\n                        modelConstructor: modelConstructor\n                      });\n                      throw new Error(msg);\n                    }\n                    if (typeof identifierOrCriteria === 'string') {\n                      if (paginationProducer !== undefined) {\n                        logger.warn('Pagination is ignored when querying by id');\n                      }\n                    }\n                    modelDefinition = getModelDefinition(modelConstructor);\n                    if (!modelDefinition) {\n                      throw new Error('Invalid model definition provided!');\n                    }\n                    pagination = this.processPagination(modelDefinition, paginationProducer);\n                    keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n                    if (!isQueryOne(identifierOrCriteria)) return [3 /*break*/, 3];\n                    if (keyFields.length > 1) {\n                      msg = errorMessages.queryByPkWithCompositeKeyPresent;\n                      logger.error(msg, {\n                        keyFields: keyFields\n                      });\n                      throw new Error(msg);\n                    }\n                    predicate = ModelPredicateCreator.createFromFlatEqualities(modelDefinition, (_a = {}, _a[keyFields[0]] = identifierOrCriteria, _a));\n                    return [4 /*yield*/, this.storage.query(modelConstructor, predicate, pagination)];\n                  case 2:\n                    result = _c.sent();\n                    return [3 /*break*/, 9];\n                  case 3:\n                    if (!isIdentifierObject(identifierOrCriteria, modelDefinition)) return [3 /*break*/, 5];\n                    predicate = ModelPredicateCreator.createForPk(modelDefinition, identifierOrCriteria);\n                    return [4 /*yield*/, this.storage.query(modelConstructor, predicate, pagination)];\n                  case 4:\n                    result = _c.sent();\n                    return [3 /*break*/, 9];\n                  case 5:\n                    if (!(!identifierOrCriteria || isPredicatesAll(identifierOrCriteria))) return [3 /*break*/, 7];\n                    return [4 /*yield*/, (_b = this.storage) === null || _b === void 0 ? void 0 : _b.query(modelConstructor, undefined, pagination)];\n                  case 6:\n                    result = _c.sent();\n                    return [3 /*break*/, 9];\n                  case 7:\n                    seedPredicate = recursivePredicateFor({\n                      builder: modelConstructor,\n                      schema: modelDefinition,\n                      pkField: extractPrimaryKeyFieldNames(modelDefinition)\n                    });\n                    predicate = internals(identifierOrCriteria(seedPredicate));\n                    return [4 /*yield*/, predicate.fetch(this.storage)];\n                  case 8:\n                    result = _c.sent();\n                    result = inMemoryPagination(result, pagination);\n                    _c.label = 9;\n                  case 9:\n                    returnOne = isQueryOne(identifierOrCriteria) || isIdentifierObject(identifierOrCriteria, modelDefinition);\n                    return [2 /*return*/, attached(returnOne ? result[0] : result, ModelAttachment.DataStore)];\n                }\n              });\n            });\n          }, 'datastore query').catch(this.handleAddProcError('DataStore.query()'))];\n        });\n      });\n    };\n    this.save = function (model, condition) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _this = this;\n        return __generator(this, function (_a) {\n          return [2 /*return*/, this.runningProcesses.add(function () {\n            return __awaiter(_this, void 0, void 0, function () {\n              var updatedPatchesTuple, initPatchesTuple, patchesTuple, modelConstructor, msg, modelDefinition, modelMeta, producedCondition, _a, savedModel;\n              var _this = this;\n              return __generator(this, function (_b) {\n                switch (_b.label) {\n                  case 0:\n                    return [4 /*yield*/, this.start()];\n                  case 1:\n                    _b.sent();\n                    if (!this.storage) {\n                      throw new Error('No storage to save to');\n                    }\n                    updatedPatchesTuple = modelPatchesMap.get(model);\n                    initPatchesTuple = initPatches.has(model) ? [initPatches.get(model), {}] : undefined;\n                    patchesTuple = updatedPatchesTuple || initPatchesTuple;\n                    modelConstructor = model ? model.constructor : undefined;\n                    if (!isValidModelConstructor(modelConstructor)) {\n                      msg = 'Object is not an instance of a valid model';\n                      logger.error(msg, {\n                        model: model\n                      });\n                      throw new Error(msg);\n                    }\n                    modelDefinition = getModelDefinition(modelConstructor);\n                    if (!modelDefinition) {\n                      throw new Error('Model Definition could not be found for model');\n                    }\n                    modelMeta = {\n                      builder: modelConstructor,\n                      schema: modelDefinition,\n                      pkField: extractPrimaryKeyFieldNames(modelDefinition)\n                    };\n                    return [4 /*yield*/, this.storage.runExclusive(function (s) {\n                      return __awaiter(_this, void 0, void 0, function () {\n                        var nonHasManyRelationships, nonHasManyRelationships_1, nonHasManyRelationships_1_1, relationship, queryObject, related, e_7_1;\n                        var e_7, _a;\n                        var _b;\n                        return __generator(this, function (_c) {\n                          switch (_c.label) {\n                            case 0:\n                              nonHasManyRelationships = ModelRelationship.allFrom(modelMeta).filter(function (r) {\n                                return r.type === 'BELONGS_TO';\n                              });\n                              _c.label = 1;\n                            case 1:\n                              _c.trys.push([1, 6, 7, 8]);\n                              nonHasManyRelationships_1 = __values(nonHasManyRelationships), nonHasManyRelationships_1_1 = nonHasManyRelationships_1.next();\n                              _c.label = 2;\n                            case 2:\n                              if (!!nonHasManyRelationships_1_1.done) return [3 /*break*/, 5];\n                              relationship = nonHasManyRelationships_1_1.value;\n                              queryObject = relationship.createRemoteQueryObject(model);\n                              if (!(queryObject !== null)) return [3 /*break*/, 4];\n                              return [4 /*yield*/, s.query(relationship.remoteModelConstructor, ModelPredicateCreator.createFromFlatEqualities(relationship.remoteDefinition, queryObject))];\n                            case 3:\n                              related = _c.sent();\n                              if (related.length === 0) {\n                                throw new Error([\"Data integrity error. You tried to save a \" + modelDefinition.name + \" (\" + JSON.stringify(model) + \")\", \"but the instance assigned to the \\\"\" + relationship.field + \"\\\" property\", \"does not exist in the local database. If you're trying to create the related\", \"\\\"\" + ((_b = relationship.remoteDefinition) === null || _b === void 0 ? void 0 : _b.name) + \"\\\", you must save it independently first.\"].join(' '));\n                              }\n                              _c.label = 4;\n                            case 4:\n                              nonHasManyRelationships_1_1 = nonHasManyRelationships_1.next();\n                              return [3 /*break*/, 2];\n                            case 5:\n                              return [3 /*break*/, 8];\n                            case 6:\n                              e_7_1 = _c.sent();\n                              e_7 = {\n                                error: e_7_1\n                              };\n                              return [3 /*break*/, 8];\n                            case 7:\n                              try {\n                                if (nonHasManyRelationships_1_1 && !nonHasManyRelationships_1_1.done && (_a = nonHasManyRelationships_1.return)) _a.call(nonHasManyRelationships_1);\n                              } finally {\n                                if (e_7) throw e_7.error;\n                              }\n                              return [7 /*endfinally*/];\n                            case 8:\n                              return [2 /*return*/];\n                          }\n                        });\n                      });\n                    })];\n\n                  case 2:\n                    _b.sent();\n                    producedCondition = condition ? internals(condition(predicateFor(modelMeta))).toStoragePredicate() : undefined;\n                    return [4 /*yield*/, this.storage.runExclusive(function (s) {\n                      return __awaiter(_this, void 0, void 0, function () {\n                        var saved;\n                        return __generator(this, function (_a) {\n                          switch (_a.label) {\n                            case 0:\n                              return [4 /*yield*/, s.save(model, producedCondition, undefined, patchesTuple)];\n                            case 1:\n                              saved = _a.sent();\n                              return [2 /*return*/, s.query(modelConstructor, ModelPredicateCreator.createForPk(modelDefinition, model))];\n                          }\n                        });\n                      });\n                    })];\n                  case 3:\n                    _a = __read.apply(void 0, [_b.sent(), 1]), savedModel = _a[0];\n                    return [2 /*return*/, attached(savedModel, ModelAttachment.DataStore)];\n                }\n              });\n            });\n          }, 'datastore save').catch(this.handleAddProcError('DataStore.save()'))];\n        });\n      });\n    };\n    this.setConflictHandler = function (config) {\n      var configDataStore = config.DataStore;\n      var conflictHandlerIsDefault = function () {\n        return _this.conflictHandler === defaultConflictHandler;\n      };\n      if (configDataStore && configDataStore.conflictHandler) {\n        return configDataStore.conflictHandler;\n      }\n      if (conflictHandlerIsDefault() && config.conflictHandler) {\n        return config.conflictHandler;\n      }\n      return _this.conflictHandler || defaultConflictHandler;\n    };\n    this.setErrorHandler = function (config) {\n      var configDataStore = config.DataStore;\n      var errorHandlerIsDefault = function () {\n        return _this.errorHandler === defaultErrorHandler;\n      };\n      if (configDataStore && configDataStore.errorHandler) {\n        return configDataStore.errorHandler;\n      }\n      if (errorHandlerIsDefault() && config.errorHandler) {\n        return config.errorHandler;\n      }\n      return _this.errorHandler || defaultErrorHandler;\n    };\n    this.delete = function (modelOrConstructor, identifierOrCriteria) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _this = this;\n        return __generator(this, function (_a) {\n          return [2 /*return*/, this.runningProcesses.add(function () {\n            return __awaiter(_this, void 0, void 0, function () {\n              var condition, msg, modelConstructor, msg, modelDefinition, keyFields, msg, msg, _a, deleted, model, modelConstructor, msg, modelDefinition, pkPredicate, msg, _b, _c, deleted;\n              var _d;\n              return __generator(this, function (_e) {\n                switch (_e.label) {\n                  case 0:\n                    return [4 /*yield*/, this.start()];\n                  case 1:\n                    _e.sent();\n                    if (!this.storage) {\n                      throw new Error('No storage to delete from');\n                    }\n                    if (!modelOrConstructor) {\n                      msg = 'Model or Model Constructor required';\n                      logger.error(msg, {\n                        modelOrConstructor: modelOrConstructor\n                      });\n                      throw new Error(msg);\n                    }\n                    if (!isValidModelConstructor(modelOrConstructor)) return [3 /*break*/, 3];\n                    modelConstructor = modelOrConstructor;\n                    if (!identifierOrCriteria) {\n                      msg = 'Id to delete or criteria required. Do you want to delete all? Pass Predicates.ALL';\n                      logger.error(msg, {\n                        identifierOrCriteria: identifierOrCriteria\n                      });\n                      throw new Error(msg);\n                    }\n                    modelDefinition = getModelDefinition(modelConstructor);\n                    if (!modelDefinition) {\n                      throw new Error('Could not find model definition for modelConstructor.');\n                    }\n                    if (typeof identifierOrCriteria === 'string') {\n                      keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n                      if (keyFields.length > 1) {\n                        msg = errorMessages.deleteByPkWithCompositeKeyPresent;\n                        logger.error(msg, {\n                          keyFields: keyFields\n                        });\n                        throw new Error(msg);\n                      }\n                      condition = ModelPredicateCreator.createFromFlatEqualities(modelDefinition, (_d = {}, _d[keyFields[0]] = identifierOrCriteria, _d));\n                    } else {\n                      if (isIdentifierObject(identifierOrCriteria, modelDefinition)) {\n                        condition = ModelPredicateCreator.createForPk(modelDefinition, identifierOrCriteria);\n                      } else {\n                        condition = internals(identifierOrCriteria(predicateFor({\n                          builder: modelConstructor,\n                          schema: modelDefinition,\n                          pkField: extractPrimaryKeyFieldNames(modelDefinition)\n                        }))).toStoragePredicate();\n                      }\n                      if (!condition || !ModelPredicateCreator.isValidPredicate(condition)) {\n                        msg = 'Criteria required. Do you want to delete all? Pass Predicates.ALL';\n                        logger.error(msg, {\n                          condition: condition\n                        });\n                        throw new Error(msg);\n                      }\n                    }\n                    return [4 /*yield*/, this.storage.delete(modelConstructor, condition)];\n                  case 2:\n                    _a = __read.apply(void 0, [_e.sent(), 1]), deleted = _a[0];\n                    return [2 /*return*/, attached(deleted, ModelAttachment.DataStore)];\n                  case 3:\n                    model = modelOrConstructor;\n                    modelConstructor = Object.getPrototypeOf(model || {}).constructor;\n                    if (!isValidModelConstructor(modelConstructor)) {\n                      msg = 'Object is not an instance of a valid model';\n                      logger.error(msg, {\n                        model: model\n                      });\n                      throw new Error(msg);\n                    }\n                    modelDefinition = getModelDefinition(modelConstructor);\n                    if (!modelDefinition) {\n                      throw new Error('Could not find model definition for modelConstructor.');\n                    }\n                    pkPredicate = ModelPredicateCreator.createForPk(modelDefinition, model);\n                    if (identifierOrCriteria) {\n                      if (typeof identifierOrCriteria !== 'function') {\n                        msg = 'Invalid criteria';\n                        logger.error(msg, {\n                          identifierOrCriteria: identifierOrCriteria\n                        });\n                        throw new Error(msg);\n                      }\n                      condition = internals(identifierOrCriteria(predicateFor({\n                        builder: modelConstructor,\n                        schema: modelDefinition,\n                        pkField: extractPrimaryKeyFieldNames(modelDefinition)\n                      }))).toStoragePredicate();\n                    } else {\n                      condition = pkPredicate;\n                    }\n                    return [4 /*yield*/, this.storage.delete(model, condition)];\n                  case 4:\n                    _b = __read.apply(void 0, [_e.sent(), 1]), _c = __read(_b[0], 1), deleted = _c[0];\n                    return [2 /*return*/, attached(deleted, ModelAttachment.DataStore)];\n                }\n              });\n            });\n          }, 'datastore delete').catch(this.handleAddProcError('DataStore.delete()'))];\n        });\n      });\n    };\n    this.observe = function (modelOrConstructor, identifierOrCriteria) {\n      var executivePredicate;\n      var modelConstructor = modelOrConstructor && isValidModelConstructor(modelOrConstructor) ? modelOrConstructor : undefined;\n      if (modelOrConstructor && modelConstructor === undefined) {\n        var model = modelOrConstructor;\n        var modelConstructor_1 = model && Object.getPrototypeOf(model).constructor;\n        if (isValidModelConstructor(modelConstructor_1)) {\n          if (identifierOrCriteria) {\n            logger.warn('idOrCriteria is ignored when using a model instance', {\n              model: model,\n              identifierOrCriteria: identifierOrCriteria\n            });\n          }\n          return _this.observe(modelConstructor_1, model.id);\n        } else {\n          var msg = 'The model is not an instance of a PersistentModelConstructor';\n          logger.error(msg, {\n            model: model\n          });\n          throw new Error(msg);\n        }\n      }\n      // observe should not accept object literal syntax\n      if (identifierOrCriteria && modelConstructor && isIdentifierObject(identifierOrCriteria, getModelDefinition(modelConstructor))) {\n        var msg = errorMessages.observeWithObjectLiteral;\n        logger.error(msg, {\n          objectLiteral: identifierOrCriteria\n        });\n        throw new Error(msg);\n      }\n      if (identifierOrCriteria !== undefined && modelConstructor === undefined) {\n        var msg = 'Cannot provide criteria without a modelConstructor';\n        logger.error(msg, identifierOrCriteria);\n        throw new Error(msg);\n      }\n      if (modelConstructor && !isValidModelConstructor(modelConstructor)) {\n        var msg = 'Constructor is not for a valid model';\n        logger.error(msg, {\n          modelConstructor: modelConstructor\n        });\n        throw new Error(msg);\n      }\n      if (modelConstructor && typeof identifierOrCriteria === 'string') {\n        var buildIdPredicate = function (seed) {\n          return seed.id.eq(identifierOrCriteria);\n        };\n        executivePredicate = internals(buildIdPredicate(buildSeedPredicate(modelConstructor)));\n      } else if (modelConstructor && typeof identifierOrCriteria === 'function') {\n        executivePredicate = internals(identifierOrCriteria(buildSeedPredicate(modelConstructor)));\n      }\n      return new Observable(function (observer) {\n        var source;\n        _this.runningProcesses.add(function () {\n          return __awaiter(_this, void 0, void 0, function () {\n            var _this = this;\n            return __generator(this, function (_a) {\n              switch (_a.label) {\n                case 0:\n                  return [4 /*yield*/, this.start()];\n                case 1:\n                  _a.sent();\n                  // Filter the events returned by Storage according to namespace,\n                  // append original element data, and subscribe to the observable\n                  source = this.storage.observe(modelConstructor).filter(function (_a) {\n                    var model = _a.model;\n                    return namespaceResolver(model) === USER;\n                  }).subscribe({\n                    next: function (item) {\n                      return _this.runningProcesses.isOpen && _this.runningProcesses.add(function () {\n                        return __awaiter(_this, void 0, void 0, function () {\n                          var message, modelDefinition, keyFields, primaryKeysAndValues, freshElement, _a;\n                          return __generator(this, function (_b) {\n                            switch (_b.label) {\n                              case 0:\n                                message = item;\n                                if (!(item.opType !== 'DELETE')) return [3 /*break*/, 2];\n                                modelDefinition = getModelDefinition(item.model);\n                                keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n                                primaryKeysAndValues = extractPrimaryKeysAndValues(item.element, keyFields);\n                                return [4 /*yield*/, this.query(item.model, primaryKeysAndValues)];\n                              case 1:\n                                freshElement = _b.sent();\n                                message = __assign(__assign({}, message), {\n                                  element: freshElement\n                                });\n                                _b.label = 2;\n                              case 2:\n                                _a = !executivePredicate;\n                                if (_a) return [3 /*break*/, 4];\n                                return [4 /*yield*/, executivePredicate.matches(message.element)];\n                              case 3:\n                                _a = _b.sent();\n                                _b.label = 4;\n                              case 4:\n                                if (_a) {\n                                  observer.next(message);\n                                }\n                                return [2 /*return*/];\n                            }\n                          });\n                        });\n                      }, 'datastore observe message handler');\n                    },\n                    error: function (err) {\n                      return observer.error(err);\n                    },\n                    complete: function () {\n                      return observer.complete();\n                    }\n                  });\n                  return [2 /*return*/];\n              }\n            });\n          });\n        }, 'datastore observe observable initialization').catch(_this.handleAddProcError('DataStore.observe()')).catch(function (error) {\n          observer.error(error);\n        });\n        // better than no cleaner, but if the subscriber is handling the\n        // complete() message async and not registering with the context,\n        // this will still be problematic.\n        return _this.runningProcesses.addCleaner(function () {\n          return __awaiter(_this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n              if (source) {\n                source.unsubscribe();\n              }\n              return [2 /*return*/];\n            });\n          });\n        }, 'DataStore.observe() cleanup');\n      });\n    };\n    this.observeQuery = function (model, criteria, options) {\n      return new Observable(function (observer) {\n        var items = new Map();\n        var itemsChanged = new Map();\n        var deletedItemIds = [];\n        var handle;\n        // let predicate: ModelPredicate<T> | undefined;\n        var executivePredicate;\n        /**\n         * As the name suggests, this geneates a snapshot in the form of\n         * \t`{items: T[], isSynced: boolean}`\n         * and sends it to the observer.\n         *\n         * SIDE EFFECT: The underlying generation and emission methods may touch:\n         * `items`, `itemsChanged`, and `deletedItemIds`.\n         *\n         * Refer to `generateSnapshot` and `emitSnapshot` for more details.\n         */\n        var generateAndEmitSnapshot = function () {\n          var snapshot = generateSnapshot();\n          emitSnapshot(snapshot);\n        };\n        // a mechanism to return data after X amount of seconds OR after the\n        // \"limit\" (itemsChanged >= this.syncPageSize) has been reached, whichever comes first\n        var limitTimerRace = new DeferredCallbackResolver({\n          callback: generateAndEmitSnapshot,\n          errorHandler: observer.error,\n          maxInterval: 2000\n        });\n        var sort = (options || {}).sort;\n        var sortOptions = sort ? {\n          sort: sort\n        } : undefined;\n        var modelDefinition = getModelDefinition(model);\n        if (!modelDefinition) {\n          throw new Error('Could not find model definition.');\n        }\n        if (model && typeof criteria === 'function') {\n          executivePredicate = internals(criteria(buildSeedPredicate(model)));\n        } else if (isPredicatesAll(criteria)) {\n          executivePredicate = undefined;\n        }\n        _this.runningProcesses.add(function () {\n          return __awaiter(_this, void 0, void 0, function () {\n            var err_1;\n            var _this = this;\n            return __generator(this, function (_a) {\n              switch (_a.label) {\n                case 0:\n                  _a.trys.push([0, 2,, 3]);\n                  return [4 /*yield*/, this.query(model, criteria, sortOptions)];\n                case 1:\n                  // first, query and return any locally-available records\n                  _a.sent().forEach(function (item) {\n                    var itemModelDefinition = getModelDefinition(model);\n                    var idOrPk = getIdentifierValue(itemModelDefinition, item);\n                    items.set(idOrPk, item);\n                  });\n                  // Observe the model and send a stream of updates (debounced).\n                  // We need to post-filter results instead of passing criteria through\n                  // to have visibility into items that move from in-set to out-of-set.\n                  // We need to explicitly remove those items from the existing snapshot.\n                  handle = this.observe(model).subscribe(function (_a) {\n                    var element = _a.element,\n                      model = _a.model,\n                      opType = _a.opType;\n                    return _this.runningProcesses.isOpen && _this.runningProcesses.add(function () {\n                      return __awaiter(_this, void 0, void 0, function () {\n                        var itemModelDefinition, idOrPk, _a, isSynced, limit;\n                        var _b, _c;\n                        return __generator(this, function (_d) {\n                          switch (_d.label) {\n                            case 0:\n                              itemModelDefinition = getModelDefinition(model);\n                              idOrPk = getIdentifierValue(itemModelDefinition, element);\n                              _a = executivePredicate;\n                              if (!_a) return [3 /*break*/, 2];\n                              return [4 /*yield*/, executivePredicate.matches(element)];\n                            case 1:\n                              _a = !_d.sent();\n                              _d.label = 2;\n                            case 2:\n                              if (_a) {\n                                if (opType === 'UPDATE' && (items.has(idOrPk) || itemsChanged.has(idOrPk))) {\n                                  // tracking as a \"deleted item\" will include the item in\n                                  // page limit calculations and ensure it is removed from the\n                                  // final items collection, regardless of which collection(s)\n                                  // it is currently in. (I mean, it could be in both, right!?)\n                                  deletedItemIds.push(idOrPk);\n                                } else {\n                                  // ignore updates for irrelevant/filtered items.\n                                  return [2 /*return*/];\n                                }\n                              }\n                              // Flag items which have been recently deleted\n                              // NOTE: Merging of separate operations to the same model instance is handled upstream\n                              // in the `mergePage` method within src/sync/merger.ts. The final state of a model instance\n                              // depends on the LATEST record (for a given id).\n                              if (opType === 'DELETE') {\n                                deletedItemIds.push(idOrPk);\n                              } else {\n                                itemsChanged.set(idOrPk, element);\n                              }\n                              isSynced = (_c = (_b = this.sync) === null || _b === void 0 ? void 0 : _b.getModelSyncedStatus(model)) !== null && _c !== void 0 ? _c : false;\n                              limit = itemsChanged.size - deletedItemIds.length >= this.syncPageSize;\n                              if (limit || isSynced) {\n                                limitTimerRace.resolve();\n                              }\n                              // kicks off every subsequent race as results sync down\n                              limitTimerRace.start();\n                              return [2 /*return*/];\n                          }\n                        });\n                      });\n                    }, 'handle observeQuery observed event');\n                  });\n                  // returns a set of initial/locally-available results\n                  generateAndEmitSnapshot();\n                  return [3 /*break*/, 3];\n                case 2:\n                  err_1 = _a.sent();\n                  observer.error(err_1);\n                  return [3 /*break*/, 3];\n                case 3:\n                  return [2 /*return*/];\n              }\n            });\n          });\n        }, 'datastore observequery startup').catch(_this.handleAddProcError('DataStore.observeQuery()')).catch(function (error) {\n          observer.error(error);\n        });\n        /**\n         * Combines the `items`, `itemsChanged`, and `deletedItemIds` collections into\n         * a snapshot in the form of `{ items: T[], isSynced: boolean}`.\n         *\n         * SIDE EFFECT: The shared `items` collection is recreated.\n         */\n        var generateSnapshot = function () {\n          var _a, _b;\n          var isSynced = (_b = (_a = _this.sync) === null || _a === void 0 ? void 0 : _a.getModelSyncedStatus(model)) !== null && _b !== void 0 ? _b : false;\n          var itemsArray = __spread(Array.from(items.values()), Array.from(itemsChanged.values()));\n          items.clear();\n          itemsArray.forEach(function (item) {\n            var itemModelDefinition = getModelDefinition(model);\n            var idOrPk = getIdentifierValue(itemModelDefinition, item);\n            items.set(idOrPk, item);\n          });\n          // remove deleted items from the final result set\n          deletedItemIds.forEach(function (idOrPk) {\n            return items.delete(idOrPk);\n          });\n          var snapshot = Array.from(items.values());\n          // we sort after we merge the snapshots (items, itemsChanged)\n          // otherwise, the merge may not\n          if (options === null || options === void 0 ? void 0 : options.sort) {\n            sortItems(snapshot);\n          }\n          return {\n            items: snapshot,\n            isSynced: isSynced\n          };\n        };\n        /**\n         * Emits the list of items to the observer.\n         *\n         * SIDE EFFECT: `itemsChanged` and `deletedItemIds` are cleared to prepare\n         * for the next snapshot.\n         *\n         * @param snapshot The generated items data to emit.\n         */\n        var emitSnapshot = function (snapshot) {\n          // send the generated snapshot to the primary subscription.\n          // NOTE: This observer's handler *could* be async ...\n          observer.next(snapshot);\n          // reset the changed items sets\n          itemsChanged.clear();\n          deletedItemIds = [];\n        };\n        /**\n         * Sorts an `Array` of `T` according to the sort instructions given in the\n         * original  `observeQuery()` call.\n         *\n         * @param itemsToSort A array of model type.\n         */\n        var sortItems = function (itemsToSort) {\n          var modelDefinition = getModelDefinition(model);\n          var pagination = _this.processPagination(modelDefinition, options);\n          var sortPredicates = ModelSortPredicateCreator.getPredicates(pagination.sort);\n          if (sortPredicates.length) {\n            var compareFn = sortCompareFunction(sortPredicates);\n            itemsToSort.sort(compareFn);\n          }\n        };\n        /**\n         * Force one last snapshot when the model is fully synced.\n         *\n         * This reduces latency for that last snapshot, which will otherwise\n         * wait for the configured timeout.\n         *\n         * @param payload The payload from the Hub event.\n         */\n        var hubCallback = function (_a) {\n          var payload = _a.payload;\n          var _b;\n          var event = payload.event,\n            data = payload.data;\n          if (event === ControlMessage.SYNC_ENGINE_MODEL_SYNCED && ((_b = data === null || data === void 0 ? void 0 : data.model) === null || _b === void 0 ? void 0 : _b.name) === model.name) {\n            generateAndEmitSnapshot();\n            Hub.remove('datastore', hubCallback);\n          }\n        };\n        Hub.listen('datastore', hubCallback);\n        return _this.runningProcesses.addCleaner(function () {\n          return __awaiter(_this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n              if (handle) {\n                handle.unsubscribe();\n              }\n              return [2 /*return*/];\n            });\n          });\n        }, 'datastore observequery cleaner');\n      });\n    };\n    this.configure = function (config) {\n      if (config === void 0) {\n        config = {};\n      }\n      _this.amplifyContext.Auth = _this.Auth;\n      _this.amplifyContext.InternalAPI = _this.InternalAPI;\n      _this.amplifyContext.Cache = _this.Cache;\n      var configDataStore = config.DataStore,\n        configAuthModeStrategyType = config.authModeStrategyType,\n        configConflictHandler = config.conflictHandler,\n        configErrorHandler = config.errorHandler,\n        configMaxRecordsToSync = config.maxRecordsToSync,\n        configSyncPageSize = config.syncPageSize,\n        configFullSyncInterval = config.fullSyncInterval,\n        configSyncExpressions = config.syncExpressions,\n        configAuthProviders = config.authProviders,\n        configStorageAdapter = config.storageAdapter,\n        configFromAmplify = __rest(config, [\"DataStore\", \"authModeStrategyType\", \"conflictHandler\", \"errorHandler\", \"maxRecordsToSync\", \"syncPageSize\", \"fullSyncInterval\", \"syncExpressions\", \"authProviders\", \"storageAdapter\"]);\n      _this.amplifyConfig = __assign(__assign({}, configFromAmplify), _this.amplifyConfig);\n      _this.conflictHandler = _this.setConflictHandler(config);\n      _this.errorHandler = _this.setErrorHandler(config);\n      var authModeStrategyType = configDataStore && configDataStore.authModeStrategyType || configAuthModeStrategyType || AuthModeStrategyType.DEFAULT;\n      switch (authModeStrategyType) {\n        case AuthModeStrategyType.MULTI_AUTH:\n          _this.authModeStrategy = multiAuthStrategy(_this.amplifyContext);\n          break;\n        case AuthModeStrategyType.DEFAULT:\n          _this.authModeStrategy = defaultAuthStrategy;\n          break;\n        default:\n          _this.authModeStrategy = defaultAuthStrategy;\n          break;\n      }\n      // store on config object, so that Sync, Subscription, and Mutation processors can have access\n      _this.amplifyConfig.authProviders = configDataStore && configDataStore.authProviders || configAuthProviders;\n      _this.syncExpressions = configDataStore && configDataStore.syncExpressions || configSyncExpressions || _this.syncExpressions;\n      _this.maxRecordsToSync = configDataStore && configDataStore.maxRecordsToSync || configMaxRecordsToSync || _this.maxRecordsToSync || 10000;\n      // store on config object, so that Sync, Subscription, and Mutation processors can have access\n      _this.amplifyConfig.maxRecordsToSync = _this.maxRecordsToSync;\n      _this.syncPageSize = configDataStore && configDataStore.syncPageSize || configSyncPageSize || _this.syncPageSize || 1000;\n      // store on config object, so that Sync, Subscription, and Mutation processors can have access\n      _this.amplifyConfig.syncPageSize = _this.syncPageSize;\n      _this.fullSyncInterval = configDataStore && configDataStore.fullSyncInterval || configFullSyncInterval || _this.fullSyncInterval || 24 * 60; // 1 day\n      _this.storageAdapter = configDataStore && configDataStore.storageAdapter || configStorageAdapter || _this.storageAdapter || undefined;\n      _this.sessionId = _this.retrieveSessionId();\n    };\n  }\n  DataStore.prototype.getModuleName = function () {\n    return 'DataStore';\n  };\n  /**\n   * Builds a function to capture `BackgroundManagerNotOpenError`'s to produce friendlier,\n   * more instructive errors for customers.\n   *\n   * @param operation The name of the operation (usually a Datastore method) the customer\n   * tried to call.\n   */\n  DataStore.prototype.handleAddProcError = function (operation) {\n    var _this = this;\n    /**\n     * If the tested error is a `BackgroundManagerNotOpenError`, it will be captured\n     * and replaced with a friendlier message that instructs the App Developer.\n     *\n     * @param err An error to test.\n     */\n    var handler = function (err) {\n      if (err.message.startsWith('BackgroundManagerNotOpenError')) {\n        throw new Error([\"DataStoreStateError: Tried to execute `\" + operation + \"` while DataStore was \\\"\" + _this.state + \"\\\".\", \"This can only be done while DataStore is \\\"Started\\\" or \\\"Stopped\\\". To remedy:\", 'Ensure all calls to `stop()` and `clear()` have completed first.', 'If this is not possible, retry the operation until it succeeds.'].join('\\n'));\n      } else {\n        throw err;\n      }\n    };\n    return handler;\n  };\n  /**\n   * Clears all data from storage and removes all data, schema info, other\n   * initialization details, and then stops DataStore.\n   *\n   * That said, reinitialization is required after clearing. This can be done\n   * by explicitiliy calling `start()` or any method that implicitly starts\n   * DataStore, such as `query()`, `save()`, or `delete()`.\n   */\n  DataStore.prototype.clear = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            checkSchemaInitialized();\n            this.state = DataStoreState.Clearing;\n            return [4 /*yield*/, this.runningProcesses.close()];\n          case 1:\n            _a.sent();\n            if (!(this.storage === undefined)) return [3 /*break*/, 3];\n            // connect to storage so that it can be cleared without fully starting DataStore\n            this.storage = new Storage(schema, namespaceResolver, getModelConstructorByModelName, modelInstanceCreator, this.storageAdapter, this.sessionId);\n            return [4 /*yield*/, this.storage.init()];\n          case 2:\n            _a.sent();\n            _a.label = 3;\n          case 3:\n            if (syncSubscription && !syncSubscription.closed) {\n              syncSubscription.unsubscribe();\n            }\n            if (!this.sync) return [3 /*break*/, 5];\n            return [4 /*yield*/, this.sync.stop()];\n          case 4:\n            _a.sent();\n            _a.label = 5;\n          case 5:\n            return [4 /*yield*/, this.storage.clear()];\n          case 6:\n            _a.sent();\n            this.initialized = undefined; // Should re-initialize when start() is called.\n            this.storage = undefined;\n            this.sync = undefined;\n            this.syncPredicates = new WeakMap();\n            return [4 /*yield*/, this.runningProcesses.open()];\n          case 7:\n            _a.sent();\n            this.state = DataStoreState.NotRunning;\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Stops all DataStore sync activities.\n   *\n   * TODO: \"Waits for graceful termination of\n   * running queries and terminates subscriptions.\"\n   */\n  DataStore.prototype.stop = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.state = DataStoreState.Stopping;\n            return [4 /*yield*/, this.runningProcesses.close()];\n          case 1:\n            _a.sent();\n            if (syncSubscription && !syncSubscription.closed) {\n              syncSubscription.unsubscribe();\n            }\n            if (!this.sync) return [3 /*break*/, 3];\n            return [4 /*yield*/, this.sync.stop()];\n          case 2:\n            _a.sent();\n            _a.label = 3;\n          case 3:\n            this.initialized = undefined; // Should re-initialize when start() is called.\n            this.sync = undefined;\n            return [4 /*yield*/, this.runningProcesses.open()];\n          case 4:\n            _a.sent();\n            this.state = DataStoreState.NotRunning;\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Validates given pagination input from a query and creates a pagination\n   * argument for use against the storage layer.\n   *\n   * @param modelDefinition\n   * @param paginationProducer\n   */\n  DataStore.prototype.processPagination = function (modelDefinition, paginationProducer) {\n    var sortPredicate;\n    var _a = paginationProducer || {},\n      limit = _a.limit,\n      page = _a.page,\n      sort = _a.sort;\n    if (limit === undefined && page === undefined && sort === undefined) {\n      return undefined;\n    }\n    if (page !== undefined && limit === undefined) {\n      throw new Error('Limit is required when requesting a page');\n    }\n    if (page !== undefined) {\n      if (typeof page !== 'number') {\n        throw new Error('Page should be a number');\n      }\n      if (page < 0) {\n        throw new Error(\"Page can't be negative\");\n      }\n    }\n    if (limit !== undefined) {\n      if (typeof limit !== 'number') {\n        throw new Error('Limit should be a number');\n      }\n      if (limit < 0) {\n        throw new Error(\"Limit can't be negative\");\n      }\n    }\n    if (sort) {\n      sortPredicate = ModelSortPredicateCreator.createFromExisting(modelDefinition, sort);\n    }\n    return {\n      limit: limit,\n      page: page,\n      sort: sortPredicate\n    };\n  };\n  /**\n   * Examines the configured `syncExpressions` and produces a WeakMap of\n   * SchemaModel -> predicate to use during sync.\n   */\n  DataStore.prototype.processSyncExpressions = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var syncPredicates;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.syncExpressions || !this.syncExpressions.length) {\n              return [2 /*return*/, new WeakMap()];\n            }\n            return [4 /*yield*/, Promise.all(this.syncExpressions.map(function (syncExpression) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var _a, modelConstructor, conditionProducer, modelDefinition, condition, predicate;\n                return __generator(this, function (_b) {\n                  switch (_b.label) {\n                    case 0:\n                      return [4 /*yield*/, syncExpression];\n                    case 1:\n                      _a = _b.sent(), modelConstructor = _a.modelConstructor, conditionProducer = _a.conditionProducer;\n                      modelDefinition = getModelDefinition(modelConstructor);\n                      return [4 /*yield*/, this.unwrapPromise(conditionProducer)];\n                    case 2:\n                      condition = _b.sent();\n                      if (isPredicatesAll(condition)) {\n                        return [2 /*return*/, [modelDefinition, null]];\n                      }\n                      predicate = internals(condition(predicateFor({\n                        builder: modelConstructor,\n                        schema: modelDefinition,\n                        pkField: extractPrimaryKeyFieldNames(modelDefinition)\n                      }))).toStoragePredicate();\n                      return [2 /*return*/, [modelDefinition, predicate]];\n                  }\n                });\n              });\n            }))];\n          case 1:\n            syncPredicates = _a.sent();\n            return [2 /*return*/, this.weakMapFromEntries(syncPredicates)];\n        }\n      });\n    });\n  };\n  DataStore.prototype.unwrapPromise = function (conditionProducer) {\n    return __awaiter(this, void 0, void 0, function () {\n      var condition, error_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n            return [4 /*yield*/, conditionProducer()];\n          case 1:\n            condition = _a.sent();\n            return [2 /*return*/, condition || conditionProducer];\n          case 2:\n            error_1 = _a.sent();\n            if (error_1 instanceof TypeError) {\n              return [2 /*return*/, conditionProducer];\n            }\n            throw error_1;\n          case 3:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  DataStore.prototype.weakMapFromEntries = function (entries) {\n    return entries.reduce(function (map, _a) {\n      var _b = __read(_a, 2),\n        modelDefinition = _b[0],\n        predicate = _b[1];\n      if (map.has(modelDefinition)) {\n        var name_2 = modelDefinition.name;\n        logger.warn(\"You can only utilize one Sync Expression per model.\\n          Subsequent sync expressions for the \" + name_2 + \" model will be ignored.\");\n        return map;\n      }\n      if (predicate) {\n        map.set(modelDefinition, predicate);\n      }\n      return map;\n    }, new WeakMap());\n  };\n  /**\n   * A session ID to allow CMS to open databases against multiple apps.\n   * This session ID is only expected be set by AWS Amplify Studio.\n   */\n  DataStore.prototype.retrieveSessionId = function () {\n    try {\n      var sessionId = sessionStorage.getItem('datastoreSessionId');\n      if (sessionId) {\n        var aws_appsync_graphqlEndpoint = this.amplifyConfig.aws_appsync_graphqlEndpoint;\n        var appSyncUrl = aws_appsync_graphqlEndpoint.split('/')[2];\n        var _a = __read(appSyncUrl.split('.'), 1),\n          appSyncId = _a[0];\n        return sessionId + \"-\" + appSyncId;\n      }\n    } catch (_b) {}\n    return undefined;\n  };\n  return DataStore;\n}();\nvar instance = new DataStore();\nAmplify.register(instance);\nexport { DataStore as DataStoreClass, initSchema, instance as DataStore };","map":{"version":3,"names":["InternalAPI","Auth","Cache","Amplify","ConsoleLogger","Logger","Hub","browserOrNode","BackgroundProcessManager","immerable","produce","setAutoFreeze","enablePatches","v4","uuid4","Observable","defaultAuthStrategy","multiAuthStrategy","isPredicatesAll","ModelPredicateCreator","ModelSortPredicateCreator","ExclusiveStorage","Storage","ModelRelationship","ControlMessage","SyncEngine","GraphQLScalarType","isGraphQLScalarType","isSchemaModelWithAttributes","AuthModeStrategyType","isNonModelFieldType","isModelFieldType","isIdentifierObject","DATASTORE","errorMessages","establishRelationAndKeys","isModelConstructor","monotonicUlidFactory","STORAGE","SYNC","USER","isNullOrUndefined","registerNonModelClass","sortCompareFunction","DeferredCallbackResolver","inMemoryPagination","extractPrimaryKeyFieldNames","extractPrimaryKeysAndValues","isIdManaged","isIdOptionallyManaged","mergePatches","getTimestampFields","recursivePredicateFor","predicateFor","internals","getIdentifierValue","logger","ulid","Date","now","isNode","SETTING_SCHEMA_VERSION","schema","modelNamespaceMap","WeakMap","modelPatchesMap","getModelDefinition","modelConstructor","namespace","get","definition","namespaces","models","name","undefined","isValidModelConstructor","obj","has","namespaceResolver","resolver","Error","buildSeedPredicate","modelSchema","pks","builder","pkField","syncClasses","userClasses","dataStoreClasses","storageClasses","modelInstanceAssociationsMap","ModelAttachment","attachedModelInstances","attached","result","attachment","Array","isArray","map","record","set","getAttachment","instance","Detached","initSchema","userSchema","console","warn","log","checkSchemaCodegenVersion","codegenVersion","internalUserNamespace","__assign","createTypeClasses","dataStoreNamespace","getNamespace","storageNamespace","syncNamespace","_a","version","Object","keys","forEach","_b","__read","relations","relationships","modelAssociations","Map","values","model","connectedModels","fields","filter","field","association","connectionType","type","push","relatedModel","defineProperty","relatedModelDefinition","indexes","indexFields","Set","indexes_1","__values","indexes_1_1","next","done","index","value","_c","e_3","_d","indexField","add","allFields","fromEntries","__spread","count","size","e_1","from","modelName","parents","every","x","delete","modelTopologicalOrdering","checkSchemaInitialized","message","error","majorVersion","minorVersion","isValid","versionParts","split","major","minor","patch","patchrevision","Number","err","classes","entries","modelDefinition","clazz","createModelClass","nonModels","typeName","typeDefinition","createNonModelClass","instancesMetadata","WeakSet","modelInstanceCreator","init","validateModelFields","k","v","fieldDefinition","type_1","isRequired_1","isRequired","isArrayNullable","name_1","timestamps","isTimestampField","includes","idEmptyString","jsType_1","getJSType","validateScalar_1","getValidationFunction","JSON","parse","errorTypeText","some","e","elemTypes","join","validationStatus","s","subNonModelDefinition_1","user","nonModel","modelValidator_1","item","subKey","castInstanceType","Boolean","initPatches","initializeInstance","draft","modelValidator","parsedValue","normalize","Model","patches","baseInstance","isInternallyInitialized","modelInstanceMetadata","_id","id","isInternalModel","syncable","checkReadOnlyPropertyOnCreate","_version","_lastChangedAt","_deleted","p","normalized","copyOf","source","fn","getPrototypeOf","constructor","msg","keyNames","key","hasExistingPatches","length","existingPatches","existingSource","mergedPatches","checkReadOnlyPropertyOnUpdate","DataStore","fromJSON","json","_this","allModelRelationships","allFrom","relationship","prototype","hasOwnProperty","toLowerCase","remoteModelConstructor","isComplete","i","localJoinFields","remoteJoinFields","instanceMemos","resultPromise","query","base","and","q","eq","AsyncCollection","then","rows","API","Promise","resolve","allModelRelationships_1","allModelRelationships_1_1","AsyncItem","_super","__extends","Symbol","asyncIterator","__awaiter","sent","toArray","max","MAX_SAFE_INTEGER","output","__asyncValues","element","_e","modelKeys","isReadOnly","patchArray","path","val","isQueryOne","defaultConflictHandler","conflictData","localModel","remoteModel","defaultErrorHandler","getModelConstructorByModelName","namespaceName","checkSchemaVersion","storage","Setting","runExclusive","createFromAST","page","limit","apply","schemaVersionSetting","storedValue","clear","save","stringify","syncSubscription","enums","pluralName","DataStoreState","amplifyConfig","syncPredicates","amplifyContext","runningProcesses","state","NotRunning","start","Starting","initialized","debug","res","rej","initResolve","initReject","storageAdapter","sessionId","aws_appsync_graphqlEndpoint","processSyncExpressions","sync","conflictHandler","errorHandler","authModeStrategy","connectivityMonitor","fullSyncIntervalInMilliseconds","fullSyncInterval","subscribe","data","readyType","SYNC_ENGINE_SYNC_QUERIES_READY","SYNC_ENGINE_STORAGE_SUBSCRIBED","dispatch","event","config","Running","catch","handleAddProcError","identifierOrCriteria","paginationProducer","pagination","processPagination","keyFields","queryByPkWithCompositeKeyPresent","predicate","createFromFlatEqualities","createForPk","seedPredicate","fetch","returnOne","condition","updatedPatchesTuple","initPatchesTuple","patchesTuple","modelMeta","nonHasManyRelationships","r","nonHasManyRelationships_1","nonHasManyRelationships_1_1","queryObject","createRemoteQueryObject","remoteDefinition","related","producedCondition","toStoragePredicate","saved","savedModel","setConflictHandler","configDataStore","conflictHandlerIsDefault","setErrorHandler","errorHandlerIsDefault","modelOrConstructor","deleteByPkWithCompositeKeyPresent","isValidPredicate","deleted","pkPredicate","observe","executivePredicate","modelConstructor_1","observeWithObjectLiteral","objectLiteral","buildIdPredicate","seed","observer","isOpen","opType","primaryKeysAndValues","freshElement","matches","complete","addCleaner","unsubscribe","observeQuery","criteria","options","items","itemsChanged","deletedItemIds","handle","generateAndEmitSnapshot","snapshot","generateSnapshot","emitSnapshot","limitTimerRace","callback","maxInterval","sort","sortOptions","itemModelDefinition","idOrPk","isSynced","getModelSyncedStatus","syncPageSize","err_1","itemsArray","sortItems","itemsToSort","sortPredicates","getPredicates","compareFn","hubCallback","payload","SYNC_ENGINE_MODEL_SYNCED","remove","listen","configure","configAuthModeStrategyType","authModeStrategyType","configConflictHandler","configErrorHandler","configMaxRecordsToSync","maxRecordsToSync","configSyncPageSize","configFullSyncInterval","configSyncExpressions","syncExpressions","configAuthProviders","authProviders","configStorageAdapter","configFromAmplify","__rest","DEFAULT","MULTI_AUTH","retrieveSessionId","getModuleName","operation","handler","startsWith","Clearing","close","closed","stop","open","Stopping","sortPredicate","createFromExisting","all","syncExpression","conditionProducer","unwrapPromise","weakMapFromEntries","error_1","TypeError","reduce","name_2","sessionStorage","getItem","appSyncUrl","appSyncId","register","DataStoreClass"],"sources":["/Users/yannellym/Desktop/iwantapet/node_modules/@aws-amplify/datastore/src/datastore/datastore.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { InternalAPI } from '@aws-amplify/api/internals';\nimport { Auth } from '@aws-amplify/auth';\nimport { Cache } from '@aws-amplify/cache';\nimport {\n\tAmplify,\n\tConsoleLogger as Logger,\n\tHub,\n\tbrowserOrNode,\n\tBackgroundProcessManager,\n} from '@aws-amplify/core';\nimport {\n\tDraft,\n\timmerable,\n\tproduce,\n\tsetAutoFreeze,\n\tenablePatches,\n\tPatch,\n} from 'immer';\nimport { v4 as uuid4 } from 'uuid';\nimport Observable, { ZenObservable } from 'zen-observable-ts';\nimport { defaultAuthStrategy, multiAuthStrategy } from '../authModeStrategies';\nimport {\n\tisPredicatesAll,\n\tModelPredicateCreator,\n\tModelSortPredicateCreator,\n\tPredicateAll,\n} from '../predicates';\nimport { Adapter } from '../storage/adapter';\nimport { ExclusiveStorage as Storage } from '../storage/storage';\nimport { ModelRelationship } from '../storage/relationship';\nimport { ControlMessage, SyncEngine } from '../sync';\nimport {\n\tAuthModeStrategy,\n\tConflictHandler,\n\tDataStoreConfig,\n\tGraphQLScalarType,\n\tInternalSchema,\n\tisGraphQLScalarType,\n\tisSchemaModelWithAttributes,\n\tModelFieldType,\n\tModelInit,\n\tModelInstanceMetadata,\n\tModelPredicate,\n\tModelField,\n\tSortPredicate,\n\tMutableModel,\n\tNamespaceResolver,\n\tNonModelTypeConstructor,\n\tProducerPaginationInput,\n\tPaginationInput,\n\tPersistentModel,\n\tPersistentModelConstructor,\n\tProducerModelPredicate,\n\tSchema,\n\tSchemaModel,\n\tSchemaNamespace,\n\tSchemaNonModel,\n\tSubscriptionMessage,\n\tDataStoreSnapshot,\n\tSyncConflict,\n\tSyncError,\n\tTypeConstructorMap,\n\tErrorHandler,\n\tSyncExpression,\n\tAuthModeStrategyType,\n\tisNonModelFieldType,\n\tisModelFieldType,\n\tObserveQueryOptions,\n\tManagedIdentifier,\n\tPersistentModelMetaData,\n\tIdentifierFieldOrIdentifierObject,\n\tisIdentifierObject,\n\tAmplifyContext,\n\tisFieldAssociation,\n\tRecursiveModelPredicateExtender,\n\tModelPredicateExtender,\n} from '../types';\n// tslint:disable:no-duplicate-imports\nimport type { __modelMeta__ } from '../types';\n\nimport {\n\tDATASTORE,\n\terrorMessages,\n\testablishRelationAndKeys,\n\tisModelConstructor,\n\tmonotonicUlidFactory,\n\tNAMESPACES,\n\tSTORAGE,\n\tSYNC,\n\tUSER,\n\tisNullOrUndefined,\n\tregisterNonModelClass,\n\tsortCompareFunction,\n\tDeferredCallbackResolver,\n\tinMemoryPagination,\n\textractPrimaryKeyFieldNames,\n\textractPrimaryKeysAndValues,\n\tisIdManaged,\n\tisIdOptionallyManaged,\n\tmergePatches,\n\tgetTimestampFields,\n} from '../util';\nimport {\n\trecursivePredicateFor,\n\tpredicateFor,\n\tGroupCondition,\n\tinternals,\n} from '../predicates/next';\nimport { getIdentifierValue } from '../sync/utils';\nimport DataStoreConnectivity from '../sync/datastoreConnectivity';\n\nsetAutoFreeze(true);\nenablePatches();\n\nconst logger = new Logger('DataStore');\n\nconst ulid = monotonicUlidFactory(Date.now());\nconst { isNode } = browserOrNode();\n\ntype SettingMetaData = {\n\tidentifier: ManagedIdentifier<Setting, 'id'>;\n\treadOnlyFields: never;\n};\ndeclare class Setting {\n\tpublic readonly [__modelMeta__]: SettingMetaData;\n\tconstructor(init: ModelInit<Setting, SettingMetaData>);\n\tstatic copyOf(\n\t\tsrc: Setting,\n\t\tmutator: (draft: MutableModel<Setting, SettingMetaData>) => void | Setting\n\t): Setting;\n\tpublic readonly id: string;\n\tpublic readonly key: string;\n\tpublic readonly value: string;\n}\n\nconst SETTING_SCHEMA_VERSION = 'schemaVersion';\n\nlet schema: InternalSchema;\nconst modelNamespaceMap = new WeakMap<\n\tPersistentModelConstructor<any>,\n\tstring\n>();\n\n/**\n * Stores data for crafting the correct update mutation input for a model.\n *\n * - `Patch[]` - array of changed fields and metadata.\n * - `PersistentModel` - the source model, used for diffing object-type fields.\n */\nconst modelPatchesMap = new WeakMap<\n\tPersistentModel,\n\t[Patch[], PersistentModel]\n>();\n\nconst getModelDefinition = (\n\tmodelConstructor: PersistentModelConstructor<any>\n) => {\n\tconst namespace = modelNamespaceMap.get(modelConstructor)!;\n\tconst definition = namespace\n\t\t? schema.namespaces[namespace].models[modelConstructor.name]\n\t\t: undefined;\n\n\treturn definition;\n};\n\n/**\n * Determines whether the given object is a Model Constructor that DataStore can\n * safely use to construct objects and discover related metadata.\n *\n * @param obj The object to test.\n */\nconst isValidModelConstructor = <T extends PersistentModel>(\n\tobj: any\n): obj is PersistentModelConstructor<T> => {\n\treturn isModelConstructor(obj) && modelNamespaceMap.has(obj);\n};\n\nconst namespaceResolver: NamespaceResolver = modelConstructor => {\n\tconst resolver = modelNamespaceMap.get(modelConstructor);\n\tif (!resolver) {\n\t\tthrow new Error(\n\t\t\t`Namespace Resolver for '${modelConstructor.name}' not found! This is probably a bug in '@amplify-js/datastore'.`\n\t\t);\n\t}\n\treturn resolver;\n};\n\n/**\n * Creates a predicate without any conditions that can be passed to customer\n * code to have conditions added to it.\n *\n * For example, in this query:\n *\n * ```ts\n * await DataStore.query(\n * \tModel,\n * \titem => item.field.eq('value')\n * );\n * ```\n *\n * `buildSeedPredicate(Model)` is used to create `item`, which is passed to the\n * predicate function, which in turn uses that \"seed\" predicate (`item`) to build\n * a predicate tree.\n *\n * @param modelConstructor The model the predicate will query.\n */\nconst buildSeedPredicate = <T extends PersistentModel>(\n\tmodelConstructor: PersistentModelConstructor<T>\n) => {\n\tif (!modelConstructor) throw new Error('Missing modelConstructor');\n\n\tconst modelSchema = getModelDefinition(\n\t\tmodelConstructor as PersistentModelConstructor<T>\n\t);\n\tif (!modelSchema) throw new Error('Missing modelSchema');\n\n\tconst pks = extractPrimaryKeyFieldNames(modelSchema);\n\tif (!pks) throw new Error('Could not determine PK');\n\n\treturn recursivePredicateFor<T>({\n\t\tbuilder: modelConstructor as PersistentModelConstructor<T>,\n\t\tschema: modelSchema,\n\t\tpkField: pks,\n\t});\n};\n\n// exporting syncClasses for testing outbox.test.ts\nexport let syncClasses: TypeConstructorMap;\nlet userClasses: TypeConstructorMap;\nlet dataStoreClasses: TypeConstructorMap;\nlet storageClasses: TypeConstructorMap;\n\n/**\n * Maps a model to its related models for memoization/immutability.\n */\nconst modelInstanceAssociationsMap = new WeakMap<PersistentModel, object>();\n\n/**\n * Describes whether and to what a model is attached for lazy loading purposes.\n */\nenum ModelAttachment {\n\t/**\n\t * Model doesn't lazy load from any data source.\n\t *\n\t * Related entity properties provided at instantiation are returned\n\t * via the respective lazy interfaces when their properties are invoked.\n\t */\n\tDetached = 'Detached',\n\n\t/**\n\t * Model lazy loads from the global DataStore.\n\t */\n\tDataStore = 'DataStore',\n\n\t/**\n\t * Demonstrative. Not yet implemented.\n\t */\n\tAPI = 'API',\n}\n\n/**\n * Tells us which data source a model is attached to (lazy loads from).\n *\n * If `Deatched`, the model's lazy properties will only ever return properties\n * from memory provided at construction time.\n */\nconst attachedModelInstances = new WeakMap<PersistentModel, ModelAttachment>();\n\n/**\n * Registers a model instance against a data source (DataStore, API, or\n * Detached/None).\n *\n * The API option is demonstrative. Lazy loading against API is not yet\n * implemented.\n *\n * @param result A model instance or array of instances\n * @param attachment A ModelAttachment data source\n * @returns passes the `result` back through after attachment\n */\nexport function attached<T extends PersistentModel | PersistentModel[]>(\n\tresult: T,\n\tattachment: ModelAttachment\n): T {\n\tif (Array.isArray(result)) {\n\t\tresult.map(record => attached(record, attachment)) as T;\n\t} else {\n\t\tresult && attachedModelInstances.set(result, attachment);\n\t}\n\treturn result;\n}\n\n/**\n * Determines what source a model instance should lazy load from.\n *\n * If the instace was never explicitly registered, it is detached by default.\n *\n * @param instance A model instance\n */\nexport const getAttachment = (instance: PersistentModel) => {\n\treturn attachedModelInstances.has(instance)\n\t\t? attachedModelInstances.get(instance)\n\t\t: ModelAttachment.Detached;\n};\n\nconst initSchema = (userSchema: Schema) => {\n\tif (schema !== undefined) {\n\t\tconsole.warn('The schema has already been initialized');\n\n\t\treturn userClasses;\n\t}\n\n\tlogger.log('validating schema', { schema: userSchema });\n\n\tcheckSchemaCodegenVersion(userSchema.codegenVersion);\n\n\tconst internalUserNamespace: SchemaNamespace = {\n\t\tname: USER,\n\t\t...userSchema,\n\t};\n\n\tlogger.log('DataStore', 'Init models');\n\tuserClasses = createTypeClasses(internalUserNamespace);\n\tlogger.log('DataStore', 'Models initialized');\n\n\tconst dataStoreNamespace = getNamespace();\n\tconst storageNamespace = Storage.getNamespace();\n\tconst syncNamespace = SyncEngine.getNamespace();\n\n\tdataStoreClasses = createTypeClasses(dataStoreNamespace);\n\tstorageClasses = createTypeClasses(storageNamespace);\n\tsyncClasses = createTypeClasses(syncNamespace);\n\n\tschema = {\n\t\tnamespaces: {\n\t\t\t[dataStoreNamespace.name]: dataStoreNamespace,\n\t\t\t[internalUserNamespace.name]: internalUserNamespace,\n\t\t\t[storageNamespace.name]: storageNamespace,\n\t\t\t[syncNamespace.name]: syncNamespace,\n\t\t},\n\t\tversion: userSchema.version,\n\t\tcodegenVersion: userSchema.codegenVersion,\n\t};\n\n\tObject.keys(schema.namespaces).forEach(namespace => {\n\t\tconst [relations, keys] = establishRelationAndKeys(\n\t\t\tschema.namespaces[namespace]\n\t\t);\n\n\t\tschema.namespaces[namespace].relationships = relations;\n\t\tschema.namespaces[namespace].keys = keys;\n\n\t\tconst modelAssociations = new Map<string, string[]>();\n\n\t\tObject.values(schema.namespaces[namespace].models).forEach(model => {\n\t\t\tconst connectedModels: string[] = [];\n\n\t\t\tObject.values(model.fields)\n\t\t\t\t.filter(\n\t\t\t\t\tfield =>\n\t\t\t\t\t\tfield.association &&\n\t\t\t\t\t\tfield.association.connectionType === 'BELONGS_TO' &&\n\t\t\t\t\t\t(<ModelFieldType>field.type).model !== model.name\n\t\t\t\t)\n\t\t\t\t.forEach(field =>\n\t\t\t\t\tconnectedModels.push((<ModelFieldType>field.type).model)\n\t\t\t\t);\n\n\t\t\tmodelAssociations.set(model.name, connectedModels);\n\n\t\t\t// Precompute model info (such as pk fields) so that downstream schema consumers\n\t\t\t// (such as predicate builders) don't have to reach back into \"DataStore\" space\n\t\t\t// to go looking for it.\n\t\t\tObject.values(model.fields).forEach(field => {\n\t\t\t\tconst relatedModel = userClasses[(<ModelFieldType>field.type).model];\n\t\t\t\tif (isModelConstructor(relatedModel)) {\n\t\t\t\t\tObject.defineProperty(field.type, 'modelConstructor', {\n\t\t\t\t\t\tget: () => {\n\t\t\t\t\t\t\tconst relatedModelDefinition = getModelDefinition(relatedModel);\n\t\t\t\t\t\t\tif (!relatedModelDefinition)\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t`Could not find model definition for ${relatedModel.name}`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tbuilder: relatedModel,\n\t\t\t\t\t\t\t\tschema: relatedModelDefinition,\n\t\t\t\t\t\t\t\tpkField: extractPrimaryKeyFieldNames(relatedModelDefinition),\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// compatibility with legacy/pre-PK codegen for lazy loading to inject\n\t\t\t// index fields into the model definition.\n\t\t\t// definition.cloudFields = { ...definition.fields };\n\n\t\t\tconst indexes =\n\t\t\t\tschema.namespaces[namespace].relationships![model.name].indexes;\n\n\t\t\tconst indexFields = new Set<string>();\n\t\t\tfor (const index of indexes) {\n\t\t\t\tfor (const indexField of index[1]) {\n\t\t\t\t\tindexFields.add(indexField);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmodel.allFields = {\n\t\t\t\t...Object.fromEntries(\n\t\t\t\t\t[...indexFields.values()].map(name => [\n\t\t\t\t\t\tname,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\ttype: 'ID',\n\t\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t\t},\n\t\t\t\t\t])\n\t\t\t\t),\n\t\t\t\t...model.fields,\n\t\t\t};\n\t\t});\n\n\t\tconst result = new Map<string, string[]>();\n\n\t\tlet count = 1000;\n\t\twhile (true && count > 0) {\n\t\t\tif (modelAssociations.size === 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount--;\n\t\t\tif (count === 0) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Models are not topologically sortable. Please verify your schema.'\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tfor (const modelName of Array.from(modelAssociations.keys())) {\n\t\t\t\tconst parents = modelAssociations.get(modelName);\n\n\t\t\t\tif (parents?.every(x => result.has(x))) {\n\t\t\t\t\tresult.set(modelName, parents);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tArray.from(result.keys()).forEach(x => modelAssociations.delete(x));\n\t\t}\n\n\t\tschema.namespaces[namespace].modelTopologicalOrdering = result;\n\t});\n\n\treturn userClasses;\n};\n\n/**\n * Throws an exception if the schema has *not* been initialized\n * by `initSchema()`.\n *\n * **To be called before trying to access schema.**\n *\n * Currently this only needs to be called in `start()` and `clear()` because\n * all other functions will call start first.\n */\nconst checkSchemaInitialized = () => {\n\tif (schema === undefined) {\n\t\tconst message =\n\t\t\t'Schema is not initialized. DataStore will not function as expected. This could happen if you have multiple versions of DataStore installed. Please see https://docs.amplify.aws/lib/troubleshooting/upgrading/q/platform/js/#check-for-duplicate-versions';\n\t\tlogger.error(message);\n\t\tthrow new Error(message);\n\t}\n};\n\n/**\n * Throws an exception if the schema is using a codegen version that is not supported.\n *\n * Set the supported version by setting majorVersion and minorVersion\n * This functions similar to ^ version range.\n * The tested codegenVersion major version must exactly match the set majorVersion\n * The tested codegenVersion minor version must be gt or equal to the set minorVersion\n * Example: For a min supported version of 5.4.0 set majorVersion = 5 and minorVersion = 4\n *\n * This regex will not work when setting a supported range with minor version\n * of 2 or more digits.\n * i.e. minorVersion = 10 will not work\n * The regex will work for testing a codegenVersion with multi digit minor\n * versions as long as the minimum minorVersion is single digit.\n * i.e. codegenVersion = 5.30.1, majorVersion = 5, minorVersion = 4 PASSES\n *\n * @param codegenVersion schema codegenVersion\n */\nconst checkSchemaCodegenVersion = (codegenVersion: string) => {\n\tconst majorVersion = 3;\n\tconst minorVersion = 2;\n\tlet isValid = false;\n\n\ttry {\n\t\tconst versionParts = codegenVersion.split('.');\n\t\tconst [major, minor, patch, patchrevision] = versionParts;\n\t\tisValid = Number(major) === majorVersion && Number(minor) >= minorVersion;\n\t} catch (err) {\n\t\tconsole.log(`Error parsing codegen version: ${codegenVersion}\\n${err}`);\n\t}\n\n\tif (!isValid) {\n\t\tconst message =\n\t\t\t`Models were generated with an unsupported version of codegen. Codegen artifacts are from ${\n\t\t\t\tcodegenVersion || 'an unknown version'\n\t\t\t}, whereas ^${majorVersion}.${minorVersion}.0 is required. ` +\n\t\t\t\"Update to the latest CLI and run 'amplify codegen models'.\";\n\t\tlogger.error(message);\n\t\tthrow new Error(message);\n\t}\n};\n\nconst createTypeClasses: (\n\tnamespace: SchemaNamespace\n) => TypeConstructorMap = namespace => {\n\tconst classes: TypeConstructorMap = {};\n\n\tObject.entries(namespace.models).forEach(([modelName, modelDefinition]) => {\n\t\tconst clazz = createModelClass(modelDefinition);\n\t\tclasses[modelName] = clazz;\n\n\t\tmodelNamespaceMap.set(clazz, namespace.name);\n\t});\n\n\tObject.entries(namespace.nonModels || {}).forEach(\n\t\t([typeName, typeDefinition]) => {\n\t\t\tconst clazz = createNonModelClass(typeDefinition);\n\t\t\tclasses[typeName] = clazz;\n\t\t}\n\t);\n\n\treturn classes;\n};\n\n/**\n * Constructs a model and records it with its metadata in a weakset. Allows for\n * the separate storage of core model fields and Amplify/DataStore metadata\n * fields that the customer app does not want exposed.\n *\n * @param modelConstructor The model constructor.\n * @param init Init data that would normally be passed to the constructor.\n * @returns The initialized model.\n */\nexport declare type ModelInstanceCreator = typeof modelInstanceCreator;\n\n/**\n * Collection of instantiated models to allow storage of metadata apart from\n * the model visible to the consuming app -- in case the app doesn't have\n * metadata fields (_version, _deleted, etc.) exposed on the model itself.\n */\nconst instancesMetadata = new WeakSet<ModelInit<any, any>>();\n\nfunction modelInstanceCreator<T extends PersistentModel>(\n\tmodelConstructor: PersistentModelConstructor<T>,\n\tinit: Partial<T>\n): T {\n\tinstancesMetadata.add(init);\n\n\treturn new modelConstructor(<ModelInit<T, PersistentModelMetaData<T>>>init);\n}\n\nconst validateModelFields =\n\t(modelDefinition: SchemaModel | SchemaNonModel) => (k: string, v: any) => {\n\t\tconst fieldDefinition = modelDefinition.fields[k];\n\n\t\tif (fieldDefinition !== undefined) {\n\t\t\tconst { type, isRequired, isArrayNullable, name, isArray } =\n\t\t\t\tfieldDefinition;\n\n\t\t\tconst timestamps = isSchemaModelWithAttributes(modelDefinition)\n\t\t\t\t? getTimestampFields(modelDefinition)\n\t\t\t\t: {};\n\t\t\tconst isTimestampField = !!timestamps[name];\n\n\t\t\tif (\n\t\t\t\t((!isArray && isRequired) || (isArray && !isArrayNullable)) &&\n\t\t\t\t!isTimestampField &&\n\t\t\t\t(v === null || v === undefined)\n\t\t\t) {\n\t\t\t\tthrow new Error(`Field ${name} is required`);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tisSchemaModelWithAttributes(modelDefinition) &&\n\t\t\t\t!isIdManaged(modelDefinition)\n\t\t\t) {\n\t\t\t\tconst keys = extractPrimaryKeyFieldNames(modelDefinition);\n\t\t\t\tif (keys.includes(k) && v === '') {\n\t\t\t\t\tlogger.error(errorMessages.idEmptyString, { k, value: v });\n\t\t\t\t\tthrow new Error(errorMessages.idEmptyString);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isGraphQLScalarType(type)) {\n\t\t\t\tconst jsType = GraphQLScalarType.getJSType(type);\n\t\t\t\tconst validateScalar = GraphQLScalarType.getValidationFunction(type);\n\n\t\t\t\tif (type === 'AWSJSON') {\n\t\t\t\t\tif (typeof v === jsType) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof v === 'string') {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tJSON.parse(v);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tthrow new Error(`Field ${name} is an invalid JSON object. ${v}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (isArray) {\n\t\t\t\t\tlet errorTypeText: string = jsType;\n\t\t\t\t\tif (!isRequired) {\n\t\t\t\t\t\terrorTypeText = `${jsType} | null | undefined`;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!Array.isArray(v) && !isArrayNullable) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Field ${name} should be of type [${errorTypeText}], ${typeof v} received. ${v}`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\t!isNullOrUndefined(v) &&\n\t\t\t\t\t\t(<[]>v).some(e =>\n\t\t\t\t\t\t\tisNullOrUndefined(e) ? isRequired : typeof e !== jsType\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst elemTypes = (<[]>v)\n\t\t\t\t\t\t\t.map(e => (e === null ? 'null' : typeof e))\n\t\t\t\t\t\t\t.join(',');\n\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`All elements in the ${name} array should be of type ${errorTypeText}, [${elemTypes}] received. ${v}`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (validateScalar && !isNullOrUndefined(v)) {\n\t\t\t\t\t\tconst validationStatus = (<[]>v).map(e => {\n\t\t\t\t\t\t\tif (!isNullOrUndefined(e)) {\n\t\t\t\t\t\t\t\treturn validateScalar(e);\n\t\t\t\t\t\t\t} else if (isNullOrUndefined(e) && !isRequired) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (!validationStatus.every(s => s)) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`All elements in the ${name} array should be of type ${type}, validation failed for one or more elements. ${v}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (!isRequired && v === undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (typeof v !== jsType && v !== null) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Field ${name} should be of type ${jsType}, ${typeof v} received. ${v}`\n\t\t\t\t\t);\n\t\t\t\t} else if (\n\t\t\t\t\t!isNullOrUndefined(v) &&\n\t\t\t\t\tvalidateScalar &&\n\t\t\t\t\t!validateScalar(v as never) // TODO: why never, TS ... why ...\n\t\t\t\t) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Field ${name} should be of type ${type}, validation failed. ${v}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else if (isNonModelFieldType(type)) {\n\t\t\t\t// do not check non model fields if undefined or null\n\t\t\t\tif (!isNullOrUndefined(v)) {\n\t\t\t\t\tconst subNonModelDefinition =\n\t\t\t\t\t\tschema.namespaces.user.nonModels![type.nonModel];\n\t\t\t\t\tconst modelValidator = validateModelFields(subNonModelDefinition);\n\n\t\t\t\t\tif (isArray) {\n\t\t\t\t\t\tlet errorTypeText: string = type.nonModel;\n\t\t\t\t\t\tif (!isRequired) {\n\t\t\t\t\t\t\terrorTypeText = `${type.nonModel} | null | undefined`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!Array.isArray(v)) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Field ${name} should be of type [${errorTypeText}], ${typeof v} received. ${v}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tv.forEach(item => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t(isNullOrUndefined(item) && isRequired) ||\n\t\t\t\t\t\t\t\t(typeof item !== 'object' && typeof item !== 'undefined')\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t`All elements in the ${name} array should be of type ${\n\t\t\t\t\t\t\t\t\t\ttype.nonModel\n\t\t\t\t\t\t\t\t\t}, [${typeof item}] received. ${item}`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!isNullOrUndefined(item)) {\n\t\t\t\t\t\t\t\tObject.keys(subNonModelDefinition.fields).forEach(subKey => {\n\t\t\t\t\t\t\t\t\tmodelValidator(subKey, item[subKey]);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (typeof v !== 'object') {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Field ${name} should be of type ${\n\t\t\t\t\t\t\t\t\ttype.nonModel\n\t\t\t\t\t\t\t\t}, ${typeof v} recieved. ${v}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tObject.keys(subNonModelDefinition.fields).forEach(subKey => {\n\t\t\t\t\t\t\tmodelValidator(subKey, v[subKey]);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\nconst castInstanceType = (\n\tmodelDefinition: SchemaModel | SchemaNonModel,\n\tk: string,\n\tv: any\n) => {\n\tconst { isArray, type } = modelDefinition.fields[k] || {};\n\t// attempt to parse stringified JSON\n\tif (\n\t\ttypeof v === 'string' &&\n\t\t(isArray ||\n\t\t\ttype === 'AWSJSON' ||\n\t\t\tisNonModelFieldType(type) ||\n\t\t\tisModelFieldType(type))\n\t) {\n\t\ttry {\n\t\t\treturn JSON.parse(v);\n\t\t} catch {\n\t\t\t// if JSON is invalid, don't throw and let modelValidator handle it\n\t\t}\n\t}\n\n\t// cast from numeric representation of boolean to JS boolean\n\tif (typeof v === 'number' && type === 'Boolean') {\n\t\treturn Boolean(v);\n\t}\n\n\treturn v;\n};\n\n/**\n * Records the patches (as if against an empty object) used to initialize\n * an instance of a Model. This can be used for determining which fields to\n * send to the cloud durnig a CREATE mutation.\n */\nconst initPatches = new WeakMap<PersistentModel, Patch[]>();\n\n/**\n * Attempts to apply type-aware, casted field values from a given `init`\n * object to the given `draft`.\n *\n * @param init The initialization object to extract field values from.\n * @param modelDefinition The definition describing the target object shape.\n * @param draft The draft to apply field values to.\n */\nconst initializeInstance = <T extends PersistentModel>(\n\tinit: ModelInit<T>,\n\tmodelDefinition: SchemaModel | SchemaNonModel,\n\tdraft: Draft<T & ModelInstanceMetadata>\n) => {\n\tconst modelValidator = validateModelFields(modelDefinition);\n\tObject.entries(init).forEach(([k, v]) => {\n\t\tconst parsedValue = castInstanceType(modelDefinition, k, v);\n\n\t\tmodelValidator(k, parsedValue);\n\t\t(<any>draft)[k] = parsedValue;\n\t});\n};\n\n/**\n * Updates a draft to standardize its customer-defined fields so that they are\n * consistent with the data as it would look after having been synchronized from\n * Cloud storage.\n *\n * The exceptions to this are:\n *\n * 1. Non-schema/Internal [sync] metadata fields.\n * 2. Cloud-managed fields, which are `null` until set by cloud storage.\n *\n * This function should be expanded if/when deviations between canonical Cloud\n * storage data and locally managed data are found. For now, the known areas\n * that require normalization are:\n *\n * 1. Ensuring all non-metadata fields are *defined*. (I.e., turn `undefined` -> `null`.)\n *\n * @param modelDefinition Definition for the draft. Used to discover all fields.\n * @param draft The instance draft to apply normalizations to.\n */\nconst normalize = <T extends PersistentModel>(\n\tmodelDefinition: SchemaModel | SchemaNonModel,\n\tdraft: Draft<T>\n) => {\n\tfor (const k of Object.keys(modelDefinition.fields)) {\n\t\tif (draft[k] === undefined) (<any>draft)[k] = null;\n\t}\n};\n\nconst createModelClass = <T extends PersistentModel>(\n\tmodelDefinition: SchemaModel\n) => {\n\tconst clazz = <PersistentModelConstructor<T>>(<unknown>class Model {\n\t\tconstructor(init: ModelInit<T>) {\n\t\t\t// we create a base instance first so we can distinguish which fields were explicitly\n\t\t\t// set by customer code versus those set by normalization. only those fields\n\t\t\t// which are explicitly set by customers should be part of create mutations.\n\t\t\tlet patches: Patch[] = [];\n\t\t\tconst baseInstance = produce(\n\t\t\t\tthis,\n\t\t\t\t(draft: Draft<T & ModelInstanceMetadata>) => {\n\t\t\t\t\tinitializeInstance(init, modelDefinition, draft);\n\n\t\t\t\t\t// model is initialized inside a DataStore component (e.g. by Sync Engine, Storage Engine, etc.)\n\t\t\t\t\tconst isInternallyInitialized = instancesMetadata.has(init);\n\n\t\t\t\t\tconst modelInstanceMetadata: ModelInstanceMetadata =\n\t\t\t\t\t\tisInternallyInitialized\n\t\t\t\t\t\t\t? <ModelInstanceMetadata>(<unknown>init)\n\t\t\t\t\t\t\t: <ModelInstanceMetadata>{};\n\n\t\t\t\t\ttype ModelWithIDIdentifier = { id: string };\n\n\t\t\t\t\tconst { id: _id } =\n\t\t\t\t\t\tmodelInstanceMetadata as unknown as ModelWithIDIdentifier;\n\n\t\t\t\t\tif (isIdManaged(modelDefinition)) {\n\t\t\t\t\t\tconst isInternalModel = _id !== null && _id !== undefined;\n\n\t\t\t\t\t\tconst id = isInternalModel\n\t\t\t\t\t\t\t? _id\n\t\t\t\t\t\t\t: modelDefinition.syncable\n\t\t\t\t\t\t\t? uuid4()\n\t\t\t\t\t\t\t: ulid();\n\n\t\t\t\t\t\t(<ModelWithIDIdentifier>(<unknown>draft)).id = id;\n\t\t\t\t\t} else if (isIdOptionallyManaged(modelDefinition)) {\n\t\t\t\t\t\t// only auto-populate if the id was not provided\n\t\t\t\t\t\t(<ModelWithIDIdentifier>(<unknown>draft)).id = draft.id || uuid4();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!isInternallyInitialized) {\n\t\t\t\t\t\tcheckReadOnlyPropertyOnCreate(draft, modelDefinition);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst { _version, _lastChangedAt, _deleted } = modelInstanceMetadata;\n\n\t\t\t\t\tif (modelDefinition.syncable) {\n\t\t\t\t\t\tdraft._version = _version;\n\t\t\t\t\t\tdraft._lastChangedAt = _lastChangedAt;\n\t\t\t\t\t\tdraft._deleted = _deleted;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tp => (patches = p)\n\t\t\t);\n\n\t\t\t// now that we have a list of patches that encapsulate the explicit, customer-provided\n\t\t\t// fields, we can normalize. patches from normalization are ignored, because the changes\n\t\t\t// are only create to provide a consistent view of the data for fields pre/post sync\n\t\t\t// where possible. (not all fields can be normalized pre-sync, because they're generally\n\t\t\t// \"cloud managed\" fields, like createdAt and updatedAt.)\n\t\t\tconst normalized = produce(\n\t\t\t\tbaseInstance,\n\t\t\t\t(draft: Draft<T & ModelInstanceMetadata>) =>\n\t\t\t\t\tnormalize(modelDefinition, draft)\n\t\t\t);\n\n\t\t\tinitPatches.set(normalized, patches);\n\n\t\t\treturn normalized;\n\t\t}\n\n\t\tstatic copyOf(source: T, fn: (draft: MutableModel<T>) => T) {\n\t\t\tconst modelConstructor = Object.getPrototypeOf(source || {}).constructor;\n\t\t\tif (!isValidModelConstructor(modelConstructor)) {\n\t\t\t\tconst msg = 'The source object is not a valid model';\n\t\t\t\tlogger.error(msg, { source });\n\t\t\t\tthrow new Error(msg);\n\t\t\t}\n\n\t\t\tlet patches: Patch[] = [];\n\t\t\tconst model = produce(\n\t\t\t\tsource,\n\t\t\t\tdraft => {\n\t\t\t\t\tfn(<MutableModel<T>>draft);\n\n\t\t\t\t\tconst keyNames = extractPrimaryKeyFieldNames(modelDefinition);\n\t\t\t\t\t// Keys are immutable\n\t\t\t\t\tkeyNames.forEach(key => {\n\t\t\t\t\t\tif (draft[key] !== source[key]) {\n\t\t\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\t\t`copyOf() does not update PK fields. The '${key}' update is being ignored.`,\n\t\t\t\t\t\t\t\t{ source }\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t(draft as Object)[key] = source[key];\n\t\t\t\t\t});\n\n\t\t\t\t\tconst modelValidator = validateModelFields(modelDefinition);\n\t\t\t\t\tObject.entries(draft).forEach(([k, v]) => {\n\t\t\t\t\t\tconst parsedValue = castInstanceType(modelDefinition, k, v);\n\n\t\t\t\t\t\tmodelValidator(k, parsedValue);\n\t\t\t\t\t});\n\n\t\t\t\t\tnormalize(modelDefinition, draft);\n\t\t\t\t},\n\t\t\t\tp => (patches = p)\n\t\t\t);\n\n\t\t\tconst hasExistingPatches = modelPatchesMap.has(source);\n\n\t\t\tif (patches.length || hasExistingPatches) {\n\t\t\t\tif (hasExistingPatches) {\n\t\t\t\t\tconst [existingPatches, existingSource] =\n\t\t\t\t\t\tmodelPatchesMap.get(source)!;\n\t\t\t\t\tconst mergedPatches = mergePatches(\n\t\t\t\t\t\texistingSource,\n\t\t\t\t\t\texistingPatches,\n\t\t\t\t\t\tpatches\n\t\t\t\t\t);\n\t\t\t\t\tmodelPatchesMap.set(model, [mergedPatches, existingSource]);\n\t\t\t\t\tcheckReadOnlyPropertyOnUpdate(mergedPatches, modelDefinition);\n\t\t\t\t} else {\n\t\t\t\t\tmodelPatchesMap.set(model, [patches, source]);\n\t\t\t\t\tcheckReadOnlyPropertyOnUpdate(patches, modelDefinition);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// always register patches when performing a copyOf, even if the\n\t\t\t\t// patches list is empty. this allows `save()` to recognize when an\n\t\t\t\t// instance is the result of a `copyOf()`. without more significant\n\t\t\t\t// refactoring, this is the only way for `save()` to know which\n\t\t\t\t// diffs (patches) are relevant for `storage` to use in building\n\t\t\t\t// the list of \"changed\" fields for mutations.\n\t\t\t\tmodelPatchesMap.set(model, [[], source]);\n\t\t\t}\n\n\t\t\treturn attached(model, ModelAttachment.DataStore);\n\t\t}\n\n\t\t// \"private\" method (that's hidden via `Setting`) for `withSSRContext` to use\n\t\t// to gain access to `modelInstanceCreator` and `clazz` for persisting IDs from server to client.\n\t\tstatic fromJSON(json: T | T[]) {\n\t\t\tif (Array.isArray(json)) {\n\t\t\t\treturn json.map(init => this.fromJSON(init));\n\t\t\t}\n\n\t\t\tconst instance = modelInstanceCreator(clazz, json);\n\n\t\t\tconst modelValidator = validateModelFields(modelDefinition);\n\n\t\t\tObject.entries(instance).forEach(([k, v]) => {\n\t\t\t\tmodelValidator(k, v);\n\t\t\t});\n\n\t\t\treturn attached(instance, ModelAttachment.DataStore);\n\t\t}\n\t});\n\n\tclazz[immerable] = true;\n\n\tObject.defineProperty(clazz, 'name', { value: modelDefinition.name });\n\n\t// Add getters/setters for relationship fields.\n\t//  getter - for lazy loading\n\t//  setter - for FK management\n\tconst allModelRelationships = ModelRelationship.allFrom({\n\t\tbuilder: clazz,\n\t\tschema: modelDefinition,\n\t\tpkField: extractPrimaryKeyFieldNames(modelDefinition),\n\t});\n\tfor (const relationship of allModelRelationships) {\n\t\tconst field = relationship.field;\n\n\t\tObject.defineProperty(clazz.prototype, modelDefinition.fields[field].name, {\n\t\t\tset(model: T | undefined | null) {\n\t\t\t\tif (!(typeof model === 'object' || typeof model === 'undefined'))\n\t\t\t\t\treturn;\n\n\t\t\t\t// if model is undefined or null, the connection should be removed\n\t\t\t\tif (model) {\n\t\t\t\t\t// Avoid validation error when processing AppSync response with nested\n\t\t\t\t\t// selection set. Nested entitites lack version field and can not be validated\n\t\t\t\t\t// TODO: explore a more reliable method to solve this\n\t\t\t\t\tif (model.hasOwnProperty('_version')) {\n\t\t\t\t\t\tconst modelConstructor = Object.getPrototypeOf(model || {})\n\t\t\t\t\t\t\t.constructor as PersistentModelConstructor<T>;\n\n\t\t\t\t\t\tif (!isValidModelConstructor(modelConstructor)) {\n\t\t\t\t\t\t\tconst msg = `Value passed to ${modelDefinition.name}.${field} is not a valid instance of a model`;\n\t\t\t\t\t\t\tlogger.error(msg, { model });\n\n\t\t\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tmodelConstructor.name.toLowerCase() !==\n\t\t\t\t\t\t\trelationship.remoteModelConstructor.name.toLowerCase()\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst msg = `Value passed to ${modelDefinition.name}.${field} is not an instance of ${relationship.remoteModelConstructor.name}`;\n\t\t\t\t\t\t\tlogger.error(msg, { model });\n\n\t\t\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if the relationship can be managed automagically, set the FK's\n\t\t\t\tif (relationship.isComplete) {\n\t\t\t\t\tfor (let i = 0; i < relationship.localJoinFields.length; i++) {\n\t\t\t\t\t\tthis[relationship.localJoinFields[i]] =\n\t\t\t\t\t\t\tmodel?.[relationship.remoteJoinFields[i]];\n\t\t\t\t\t}\n\t\t\t\t\tconst instanceMemos = modelInstanceAssociationsMap.has(this)\n\t\t\t\t\t\t? modelInstanceAssociationsMap.get(this)!\n\t\t\t\t\t\t: modelInstanceAssociationsMap.set(this, {}).get(this)!;\n\t\t\t\t\tinstanceMemos[field] = model || undefined;\n\t\t\t\t}\n\t\t\t},\n\t\t\tget() {\n\t\t\t\t/**\n\t\t\t\t * Bucket for holding related models instances specific to `this` instance.\n\t\t\t\t */\n\t\t\t\tconst instanceMemos = modelInstanceAssociationsMap.has(this)\n\t\t\t\t\t? modelInstanceAssociationsMap.get(this)!\n\t\t\t\t\t: modelInstanceAssociationsMap.set(this, {}).get(this)!;\n\n\t\t\t\t// if the memos already has a result for this field, we'll use it.\n\t\t\t\t// there is no \"cache\" invalidation of any kind; memos are permanent to\n\t\t\t\t// keep an immutable perception of the instance.\n\t\t\t\tif (!instanceMemos.hasOwnProperty(field)) {\n\t\t\t\t\t// before we populate the memo, we need to know where to look for relatives.\n\t\t\t\t\t// today, this only supports DataStore. Models aren't managed elsewhere in Amplify.\n\t\t\t\t\tif (getAttachment(this) === ModelAttachment.DataStore) {\n\t\t\t\t\t\t// when we fetch the results using a query constructed under the guidance\n\t\t\t\t\t\t// of the relationship metadata, we DO NOT AWAIT resolution. we want to\n\t\t\t\t\t\t// drop the promise into the memo's synchronously, eliminating the chance\n\t\t\t\t\t\t// for a race.\n\t\t\t\t\t\tconst resultPromise = instance.query(\n\t\t\t\t\t\t\trelationship.remoteModelConstructor as PersistentModelConstructor<T>,\n\t\t\t\t\t\t\tbase =>\n\t\t\t\t\t\t\t\tbase.and(q => {\n\t\t\t\t\t\t\t\t\treturn relationship.remoteJoinFields.map((field, index) => {\n\t\t\t\t\t\t\t\t\t\t// TODO: anything we can use instead of `any` here?\n\t\t\t\t\t\t\t\t\t\treturn (q[field] as T[typeof field]).eq(\n\t\t\t\t\t\t\t\t\t\t\tthis[relationship.localJoinFields[index]]\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// results in hand, how we return them to the caller depends on the relationship type.\n\t\t\t\t\t\tif (relationship.type === 'HAS_MANY') {\n\t\t\t\t\t\t\t// collections should support async iteration, even though we don't\n\t\t\t\t\t\t\t// leverage it fully [yet].\n\t\t\t\t\t\t\tinstanceMemos[field] = new AsyncCollection(resultPromise);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// non-collections should only ever return 1 value *or nothing*.\n\t\t\t\t\t\t\t// if we have more than 1 record, something's amiss. it's not our job\n\t\t\t\t\t\t\t// pick a result for the customer. it's our job to say \"something's wrong.\"\n\t\t\t\t\t\t\tinstanceMemos[field] = resultPromise.then(rows => {\n\t\t\t\t\t\t\t\tif (rows.length > 1) {\n\t\t\t\t\t\t\t\t\t// should never happen for a HAS_ONE or BELONGS_TO.\n\t\t\t\t\t\t\t\t\tconst err = new Error(`\n\t\t\t\t\t\t\t\t\tData integrity error.\n\t\t\t\t\t\t\t\t\tToo many records found for a HAS_ONE/BELONGS_TO field '${modelDefinition.name}.${field}'\n\t\t\t\t\t\t\t\t`);\n\t\t\t\t\t\t\t\t\tconsole.error(err);\n\t\t\t\t\t\t\t\t\tthrow err;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn rows[0];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (getAttachment(this) === ModelAttachment.API) {\n\t\t\t\t\t\tthrow new Error('Lazy loading from API is not yet supported!');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (relationship.type === 'HAS_MANY') {\n\t\t\t\t\t\t\treturn new AsyncCollection([]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn Promise.resolve(undefined);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn instanceMemos[field];\n\t\t\t},\n\t\t});\n\t}\n\n\treturn clazz;\n};\n\n/**\n * An eventually loaded related model instance.\n */\nexport class AsyncItem<T> extends Promise<T> {}\n\n/**\n * A collection of related model instances.\n *\n * This collection can be async-iterated or turned directly into an array using `toArray()`.\n */\nexport class AsyncCollection<T> implements AsyncIterable<T> {\n\tprivate values: Array<any> | Promise<Array<any>>;\n\n\tconstructor(values: Array<any> | Promise<Array<any>>) {\n\t\tthis.values = values;\n\t}\n\n\t/**\n\t * Facilitates async iteration.\n\t *\n\t * ```ts\n\t * for await (const item of collection) {\n\t *   handle(item)\n\t * }\n\t * ```\n\t *\n\t * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of\n\t */\n\t[Symbol.asyncIterator](): AsyncIterator<T> {\n\t\tlet values;\n\t\tlet index = 0;\n\t\treturn {\n\t\t\tnext: async () => {\n\t\t\t\tif (!values) values = await this.values;\n\t\t\t\tif (index < values.length) {\n\t\t\t\t\tconst result = {\n\t\t\t\t\t\tvalue: values[index],\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t};\n\t\t\t\t\tindex++;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tvalue: null,\n\t\t\t\t\tdone: true,\n\t\t\t\t};\n\t\t\t},\n\t\t};\n\t}\n\n\t/**\n\t * Turns the collection into an array, up to the amount specified in `max` param.\n\t *\n\t * ```ts\n\t * const all = await collection.toArray();\n\t * const first100 = await collection.toArray({max: 100});\n\t * ```\n\t */\n\tasync toArray({\n\t\tmax = Number.MAX_SAFE_INTEGER,\n\t}: { max?: number } = {}): Promise<T[]> {\n\t\tconst output: T[] = [];\n\t\tlet i = 0;\n\t\tfor await (const element of this) {\n\t\t\tif (i < max) {\n\t\t\t\toutput.push(element);\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n}\n\nconst checkReadOnlyPropertyOnCreate = <T extends PersistentModel>(\n\tdraft: T,\n\tmodelDefinition: SchemaModel\n) => {\n\tconst modelKeys = Object.keys(draft);\n\tconst { fields } = modelDefinition;\n\n\tmodelKeys.forEach(key => {\n\t\tif (fields[key] && fields[key].isReadOnly) {\n\t\t\tthrow new Error(`${key} is read-only.`);\n\t\t}\n\t});\n};\n\nconst checkReadOnlyPropertyOnUpdate = (\n\tpatches: Patch[],\n\tmodelDefinition: SchemaModel\n) => {\n\tconst patchArray = patches.map(p => [p.path[0], p.value]);\n\tconst { fields } = modelDefinition;\n\n\tpatchArray.forEach(([key, val]) => {\n\t\tif (!val || !fields[key]) return;\n\n\t\tif (fields[key].isReadOnly) {\n\t\t\tthrow new Error(`${key} is read-only.`);\n\t\t}\n\t});\n};\n\nconst createNonModelClass = <T extends PersistentModel>(\n\ttypeDefinition: SchemaNonModel\n) => {\n\tconst clazz = <NonModelTypeConstructor<T>>(<unknown>class Model {\n\t\tconstructor(init: ModelInit<T>) {\n\t\t\tconst instance = produce(\n\t\t\t\tthis,\n\t\t\t\t(draft: Draft<T & ModelInstanceMetadata>) => {\n\t\t\t\t\tinitializeInstance(init, typeDefinition, draft);\n\t\t\t\t}\n\t\t\t);\n\n\t\t\treturn instance;\n\t\t}\n\t});\n\n\tclazz[immerable] = true;\n\n\tObject.defineProperty(clazz, 'name', { value: typeDefinition.name });\n\n\tregisterNonModelClass(clazz);\n\n\treturn clazz;\n};\n\nfunction isQueryOne(obj: any): obj is string {\n\treturn typeof obj === 'string';\n}\n\nfunction defaultConflictHandler(conflictData: SyncConflict): PersistentModel {\n\tconst { localModel, modelConstructor, remoteModel } = conflictData;\n\tconst { _version } = remoteModel;\n\treturn modelInstanceCreator(modelConstructor, { ...localModel, _version });\n}\n\nfunction defaultErrorHandler(error: SyncError<PersistentModel>): void {\n\tlogger.warn(error);\n}\n\nfunction getModelConstructorByModelName(\n\tnamespaceName: NAMESPACES,\n\tmodelName: string\n): PersistentModelConstructor<any> {\n\tlet result: PersistentModelConstructor<any> | NonModelTypeConstructor<any>;\n\n\tswitch (namespaceName) {\n\t\tcase DATASTORE:\n\t\t\tresult = dataStoreClasses[modelName];\n\t\t\tbreak;\n\t\tcase USER:\n\t\t\tresult = userClasses[modelName];\n\t\t\tbreak;\n\t\tcase SYNC:\n\t\t\tresult = syncClasses[modelName];\n\t\t\tbreak;\n\t\tcase STORAGE:\n\t\t\tresult = storageClasses[modelName];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new Error(`Invalid namespace: ${namespaceName}`);\n\t}\n\n\tif (isValidModelConstructor(result)) {\n\t\treturn result;\n\t} else {\n\t\tconst msg = `Model name is not valid for namespace. modelName: ${modelName}, namespace: ${namespaceName}`;\n\t\tlogger.error(msg);\n\n\t\tthrow new Error(msg);\n\t}\n}\n\n/**\n * Queries the DataStore metadata tables to see if they are the expected\n * version. If not, clobbers the whole DB. If so, leaves them alone.\n * Otherwise, simply writes the schema version.\n *\n * SIDE EFFECT:\n * 1. Creates a transaction\n * 1. Updates data.\n *\n * @param storage Storage adapter containing the metadata.\n * @param version The expected schema version.\n */\nasync function checkSchemaVersion(\n\tstorage: Storage,\n\tversion: string\n): Promise<void> {\n\tconst Setting =\n\t\tdataStoreClasses.Setting as PersistentModelConstructor<Setting>;\n\n\tconst modelDefinition = schema.namespaces[DATASTORE].models.Setting;\n\n\tawait storage.runExclusive(async s => {\n\t\tconst [schemaVersionSetting] = await s.query(\n\t\t\tSetting,\n\t\t\tModelPredicateCreator.createFromAST(modelDefinition, {\n\t\t\t\tand: { key: { eq: SETTING_SCHEMA_VERSION } },\n\t\t\t}),\n\t\t\t{ page: 0, limit: 1 }\n\t\t);\n\n\t\tif (\n\t\t\tschemaVersionSetting !== undefined &&\n\t\t\tschemaVersionSetting.value !== undefined\n\t\t) {\n\t\t\tconst storedValue = JSON.parse(schemaVersionSetting.value);\n\n\t\t\tif (storedValue !== version) {\n\t\t\t\tawait s.clear(false);\n\t\t\t}\n\t\t} else {\n\t\t\tawait s.save(\n\t\t\t\tmodelInstanceCreator(Setting, {\n\t\t\t\t\tkey: SETTING_SCHEMA_VERSION,\n\t\t\t\t\tvalue: JSON.stringify(version),\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t});\n}\n\nlet syncSubscription: ZenObservable.Subscription;\n\nfunction getNamespace(): SchemaNamespace {\n\tconst namespace: SchemaNamespace = {\n\t\tname: DATASTORE,\n\t\trelationships: {},\n\t\tenums: {},\n\t\tnonModels: {},\n\t\tmodels: {\n\t\t\tSetting: {\n\t\t\t\tname: 'Setting',\n\t\t\t\tpluralName: 'Settings',\n\t\t\t\tsyncable: false,\n\t\t\t\tfields: {\n\t\t\t\t\tid: {\n\t\t\t\t\t\tname: 'id',\n\t\t\t\t\t\ttype: 'ID',\n\t\t\t\t\t\tisRequired: true,\n\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t},\n\t\t\t\t\tkey: {\n\t\t\t\t\t\tname: 'key',\n\t\t\t\t\t\ttype: 'String',\n\t\t\t\t\t\tisRequired: true,\n\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t},\n\t\t\t\t\tvalue: {\n\t\t\t\t\t\tname: 'value',\n\t\t\t\t\t\ttype: 'String',\n\t\t\t\t\t\tisRequired: true,\n\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t};\n\n\treturn namespace;\n}\n\nenum DataStoreState {\n\tNotRunning = 'Not Running',\n\tStarting = 'Starting',\n\tRunning = 'Running',\n\tStopping = 'Stopping',\n\tClearing = 'Clearing',\n}\n\n// TODO: How can we get rid of the non-null assertions?\n// https://github.com/aws-amplify/amplify-js/pull/10477/files#r1007363485\nclass DataStore {\n\t// reference to configured category instances. Used for preserving SSR context\n\tprivate Auth = Auth;\n\tprivate InternalAPI = InternalAPI;\n\tprivate Cache = Cache;\n\n\t// Non-null assertions (bang operator) have been added to most of these properties\n\t// to make TS happy. These properties are all expected to be set immediately after\n\t// construction.\n\n\t// TODO: Refactor to use proper DI if possible. If not possible, change these to\n\t// optionals and implement conditional checks throughout. Rinse/repeat on all\n\t// sync engine processors, storage engine, adapters, etc..\n\n\tprivate amplifyConfig: Record<string, any> = {};\n\tprivate authModeStrategy!: AuthModeStrategy;\n\tprivate conflictHandler!: ConflictHandler;\n\tprivate errorHandler!: (error: SyncError<PersistentModel>) => void;\n\tprivate fullSyncInterval!: number;\n\tprivate initialized?: Promise<void>;\n\tprivate initReject!: Function;\n\tprivate initResolve!: Function;\n\tprivate maxRecordsToSync!: number;\n\tprivate storage?: Storage;\n\tprivate sync?: SyncEngine;\n\tprivate syncPageSize!: number;\n\tprivate syncExpressions!: SyncExpression[];\n\tprivate syncPredicates: WeakMap<SchemaModel, ModelPredicate<any> | null> =\n\t\tnew WeakMap<SchemaModel, ModelPredicate<any>>();\n\tprivate sessionId?: string;\n\tprivate storageAdapter!: Adapter;\n\t// object that gets passed to descendent classes. Allows us to pass these down by reference\n\tprivate amplifyContext: AmplifyContext = {\n\t\tAuth: this.Auth,\n\t\tInternalAPI: this.InternalAPI,\n\t\tCache: this.Cache,\n\t};\n\tprivate connectivityMonitor?: DataStoreConnectivity;\n\n\t/**\n\t * **IMPORTANT!**\n\t *\n\t * Accumulator for background things that can **and MUST** be called when\n\t * DataStore stops.\n\t *\n\t * These jobs **MUST** be *idempotent promises* that resolve ONLY\n\t * once the intended jobs are completely finished and/or otherwise destroyed\n\t * and cleaned up with ZERO outstanding:\n\t *\n\t * 1. side effects (e.g., state changes)\n\t * 1. callbacks\n\t * 1. subscriptions\n\t * 1. calls to storage\n\t * 1. *etc.*\n\t *\n\t * Methods that create pending promises, subscriptions, callbacks, or any\n\t * type of side effect **MUST** be registered with the manager. And, a new\n\t * manager must be created after each `exit()`.\n\t *\n\t * Failure to comply will put DataStore into a highly unpredictable state\n\t * when it needs to stop or clear -- which occurs when restarting with new\n\t * sync expressions, during testing, and potentially during app code\n\t * recovery handling, etc..\n\t *\n\t * It is up to the discretion of each disposer whether to wait for job\n\t * completion or to cancel operations and issue failures *as long as the\n\t * disposer returns in a reasonable amount of time.*\n\t *\n\t * (Reasonable = *seconds*, not minutes.)\n\t */\n\tprivate runningProcesses = new BackgroundProcessManager();\n\n\t/**\n\t * Indicates what state DataStore is in.\n\t *\n\t * Not [yet?] used for actual state management; but for messaging\n\t * when errors occur, to help troubleshoot.\n\t */\n\tprivate state: DataStoreState = DataStoreState.NotRunning;\n\n\tgetModuleName() {\n\t\treturn 'DataStore';\n\t}\n\n\t/**\n\t * Builds a function to capture `BackgroundManagerNotOpenError`'s to produce friendlier,\n\t * more instructive errors for customers.\n\t *\n\t * @param operation The name of the operation (usually a Datastore method) the customer\n\t * tried to call.\n\t */\n\thandleAddProcError(operation: string) {\n\t\t/**\n\t\t * If the tested error is a `BackgroundManagerNotOpenError`, it will be captured\n\t\t * and replaced with a friendlier message that instructs the App Developer.\n\t\t *\n\t\t * @param err An error to test.\n\t\t */\n\t\tconst handler = (err: Error) => {\n\t\t\tif (err.message.startsWith('BackgroundManagerNotOpenError')) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t[\n\t\t\t\t\t\t`DataStoreStateError: Tried to execute \\`${operation}\\` while DataStore was \"${this.state}\".`,\n\t\t\t\t\t\t`This can only be done while DataStore is \"Started\" or \"Stopped\". To remedy:`,\n\t\t\t\t\t\t'Ensure all calls to `stop()` and `clear()` have completed first.',\n\t\t\t\t\t\t'If this is not possible, retry the operation until it succeeds.',\n\t\t\t\t\t].join('\\n')\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t};\n\n\t\treturn handler;\n\t}\n\n\t/**\n\t * If not already done:\n\t * 1. Attaches and initializes storage.\n\t * 2. Loads the schema and records metadata.\n\t * 3. If `this.amplifyConfig.aws_appsync_graphqlEndpoint` contains a URL,\n\t * attaches a sync engine, starts it, and subscribes.\n\t */\n\tstart = async (): Promise<void> => {\n\t\treturn this.runningProcesses\n\t\t\t.add(async () => {\n\t\t\t\tthis.state = DataStoreState.Starting;\n\t\t\t\tif (this.initialized === undefined) {\n\t\t\t\t\tlogger.debug('Starting DataStore');\n\t\t\t\t\tthis.initialized = new Promise((res, rej) => {\n\t\t\t\t\t\tthis.initResolve = res;\n\t\t\t\t\t\tthis.initReject = rej;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tawait this.initialized;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.storage = new Storage(\n\t\t\t\t\tschema,\n\t\t\t\t\tnamespaceResolver,\n\t\t\t\t\tgetModelConstructorByModelName,\n\t\t\t\t\tmodelInstanceCreator,\n\t\t\t\t\tthis.storageAdapter,\n\t\t\t\t\tthis.sessionId\n\t\t\t\t);\n\n\t\t\t\tawait this.storage.init();\n\t\t\t\tcheckSchemaInitialized();\n\t\t\t\tawait checkSchemaVersion(this.storage, schema.version);\n\t\t\t\tconst { aws_appsync_graphqlEndpoint } = this.amplifyConfig;\n\n\t\t\t\tif (aws_appsync_graphqlEndpoint) {\n\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t'GraphQL endpoint available',\n\t\t\t\t\t\taws_appsync_graphqlEndpoint\n\t\t\t\t\t);\n\n\t\t\t\t\tthis.syncPredicates = await this.processSyncExpressions();\n\n\t\t\t\t\tthis.sync = new SyncEngine(\n\t\t\t\t\t\tschema,\n\t\t\t\t\t\tnamespaceResolver,\n\t\t\t\t\t\tsyncClasses,\n\t\t\t\t\t\tuserClasses,\n\t\t\t\t\t\tthis.storage,\n\t\t\t\t\t\tmodelInstanceCreator,\n\t\t\t\t\t\tthis.conflictHandler,\n\t\t\t\t\t\tthis.errorHandler,\n\t\t\t\t\t\tthis.syncPredicates,\n\t\t\t\t\t\tthis.amplifyConfig,\n\t\t\t\t\t\tthis.authModeStrategy,\n\t\t\t\t\t\tthis.amplifyContext,\n\t\t\t\t\t\tthis.connectivityMonitor\n\t\t\t\t\t);\n\n\t\t\t\t\tconst fullSyncIntervalInMilliseconds =\n\t\t\t\t\t\tthis.fullSyncInterval * 1000 * 60; // fullSyncInterval from param is in minutes\n\t\t\t\t\tsyncSubscription = this.sync\n\t\t\t\t\t\t.start({ fullSyncInterval: fullSyncIntervalInMilliseconds })\n\t\t\t\t\t\t.subscribe({\n\t\t\t\t\t\t\tnext: ({ type, data }) => {\n\t\t\t\t\t\t\t\t// In Node, we need to wait for queries to be synced to prevent returning empty arrays.\n\t\t\t\t\t\t\t\t// In the Browser, we can begin returning data once subscriptions are in place.\n\t\t\t\t\t\t\t\tconst readyType = isNode\n\t\t\t\t\t\t\t\t\t? ControlMessage.SYNC_ENGINE_SYNC_QUERIES_READY\n\t\t\t\t\t\t\t\t\t: ControlMessage.SYNC_ENGINE_STORAGE_SUBSCRIBED;\n\n\t\t\t\t\t\t\t\tif (type === readyType) {\n\t\t\t\t\t\t\t\t\tthis.initResolve();\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tHub.dispatch('datastore', {\n\t\t\t\t\t\t\t\t\tevent: type,\n\t\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\terror: err => {\n\t\t\t\t\t\t\t\tlogger.warn('Sync error', err);\n\t\t\t\t\t\t\t\tthis.initReject();\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\"Data won't be synchronized. No GraphQL endpoint configured. Did you forget `Amplify.configure(awsconfig)`?\",\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconfig: this.amplifyConfig,\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t\tthis.initResolve();\n\t\t\t\t}\n\n\t\t\t\tawait this.initialized;\n\t\t\t\tthis.state = DataStoreState.Running;\n\t\t\t}, 'datastore start')\n\t\t\t.catch(this.handleAddProcError('DataStore.start()'));\n\t};\n\n\tquery: {\n\t\t<T extends PersistentModel>(\n\t\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\t\tidentifier: IdentifierFieldOrIdentifierObject<\n\t\t\t\tT,\n\t\t\t\tPersistentModelMetaData<T>\n\t\t\t>\n\t\t): Promise<T | undefined>;\n\t\t<T extends PersistentModel>(\n\t\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\t\tcriteria?:\n\t\t\t\t| RecursiveModelPredicateExtender<T>\n\t\t\t\t| typeof PredicateAll\n\t\t\t\t| null,\n\t\t\tpaginationProducer?: ProducerPaginationInput<T>\n\t\t): Promise<T[]>;\n\t} = async <T extends PersistentModel>(\n\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\tidentifierOrCriteria?:\n\t\t\t| IdentifierFieldOrIdentifierObject<T, PersistentModelMetaData<T>>\n\t\t\t| RecursiveModelPredicateExtender<T>\n\t\t\t| typeof PredicateAll\n\t\t\t| null,\n\t\tpaginationProducer?: ProducerPaginationInput<T>\n\t): Promise<T | T[] | undefined> => {\n\t\treturn this.runningProcesses\n\t\t\t.add(async () => {\n\t\t\t\tawait this.start();\n\n\t\t\t\tlet result: T[];\n\n\t\t\t\tif (!this.storage) {\n\t\t\t\t\tthrow new Error('No storage to query');\n\t\t\t\t}\n\n\t\t\t\t//#region Input validation\n\n\t\t\t\tif (!isValidModelConstructor(modelConstructor)) {\n\t\t\t\t\tconst msg = 'Constructor is not for a valid model';\n\t\t\t\t\tlogger.error(msg, { modelConstructor });\n\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t}\n\n\t\t\t\tif (typeof identifierOrCriteria === 'string') {\n\t\t\t\t\tif (paginationProducer !== undefined) {\n\t\t\t\t\t\tlogger.warn('Pagination is ignored when querying by id');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst modelDefinition = getModelDefinition(modelConstructor);\n\t\t\t\tif (!modelDefinition) {\n\t\t\t\t\tthrow new Error('Invalid model definition provided!');\n\t\t\t\t}\n\n\t\t\t\tconst pagination = this.processPagination(\n\t\t\t\t\tmodelDefinition,\n\t\t\t\t\tpaginationProducer\n\t\t\t\t);\n\n\t\t\t\tconst keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n\n\t\t\t\tif (isQueryOne(identifierOrCriteria)) {\n\t\t\t\t\tif (keyFields.length > 1) {\n\t\t\t\t\t\tconst msg = errorMessages.queryByPkWithCompositeKeyPresent;\n\t\t\t\t\t\tlogger.error(msg, { keyFields });\n\n\t\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst predicate = ModelPredicateCreator.createFromFlatEqualities<T>(\n\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\t{ [keyFields[0]]: identifierOrCriteria }\n\t\t\t\t\t);\n\n\t\t\t\t\tresult = await this.storage.query<T>(\n\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\tpredicate,\n\t\t\t\t\t\tpagination\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t// Object is being queried using object literal syntax\n\t\t\t\t\tif (isIdentifierObject(<T>identifierOrCriteria, modelDefinition)) {\n\t\t\t\t\t\tconst predicate = ModelPredicateCreator.createForPk<T>(\n\t\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\t\t<T>identifierOrCriteria\n\t\t\t\t\t\t);\n\t\t\t\t\t\tresult = await this.storage.query<T>(\n\t\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\t\tpredicate,\n\t\t\t\t\t\t\tpagination\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (\n\t\t\t\t\t\t!identifierOrCriteria ||\n\t\t\t\t\t\tisPredicatesAll(identifierOrCriteria)\n\t\t\t\t\t) {\n\t\t\t\t\t\tresult = await this.storage?.query<T>(\n\t\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\tpagination\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst seedPredicate = recursivePredicateFor<T>({\n\t\t\t\t\t\t\tbuilder: modelConstructor,\n\t\t\t\t\t\t\tschema: modelDefinition,\n\t\t\t\t\t\t\tpkField: extractPrimaryKeyFieldNames(modelDefinition),\n\t\t\t\t\t\t});\n\t\t\t\t\t\tconst predicate = internals(\n\t\t\t\t\t\t\t(identifierOrCriteria as RecursiveModelPredicateExtender<T>)(\n\t\t\t\t\t\t\t\tseedPredicate\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tresult = (await predicate.fetch(this.storage)) as T[];\n\t\t\t\t\t\tresult = inMemoryPagination(result, pagination);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//#endregion\n\n\t\t\t\tconst returnOne =\n\t\t\t\t\tisQueryOne(identifierOrCriteria) ||\n\t\t\t\t\tisIdentifierObject(identifierOrCriteria, modelDefinition);\n\n\t\t\t\treturn attached(\n\t\t\t\t\treturnOne ? result[0] : result,\n\t\t\t\t\tModelAttachment.DataStore\n\t\t\t\t);\n\t\t\t}, 'datastore query')\n\t\t\t.catch(this.handleAddProcError('DataStore.query()'));\n\t};\n\n\tsave = async <T extends PersistentModel>(\n\t\tmodel: T,\n\t\tcondition?: ModelPredicateExtender<T>\n\t): Promise<T> => {\n\t\treturn this.runningProcesses\n\t\t\t.add(async () => {\n\t\t\t\tawait this.start();\n\n\t\t\t\tif (!this.storage) {\n\t\t\t\t\tthrow new Error('No storage to save to');\n\t\t\t\t}\n\n\t\t\t\t// Immer patches for constructing a correct update mutation input\n\t\t\t\t// Allows us to only include changed fields for updates\n\t\t\t\tconst updatedPatchesTuple = modelPatchesMap.get(model);\n\n\t\t\t\t// Immer patches for initial object construction. These are used if\n\t\t\t\t// there are no `update` patches under the assumption we're performing\n\t\t\t\t// a CREATE and wish to send only explicitly specified fields to the cloud.\n\t\t\t\tconst initPatchesTuple = initPatches.has(model)\n\t\t\t\t\t? ([initPatches.get(model)!, {}] as [\n\t\t\t\t\t\t\tPatch[],\n\t\t\t\t\t\t\tReadonly<Record<string, any>>\n\t\t\t\t\t  ])\n\t\t\t\t\t: undefined;\n\n\t\t\t\t// favor update patches over init/create patches, because init patches\n\t\t\t\t// are ALWAYS present, whereas update patches are only present if copyOf\n\t\t\t\t// was used to create the instance.\n\t\t\t\tconst patchesTuple:\n\t\t\t\t\t| [Patch[], Readonly<Record<string, any>>]\n\t\t\t\t\t| undefined = updatedPatchesTuple || initPatchesTuple;\n\n\t\t\t\tconst modelConstructor: PersistentModelConstructor<T> | undefined =\n\t\t\t\t\tmodel ? <PersistentModelConstructor<T>>model.constructor : undefined;\n\n\t\t\t\tif (!isValidModelConstructor(modelConstructor)) {\n\t\t\t\t\tconst msg = 'Object is not an instance of a valid model';\n\t\t\t\t\tlogger.error(msg, { model });\n\n\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t}\n\n\t\t\t\tconst modelDefinition = getModelDefinition(modelConstructor);\n\t\t\t\tif (!modelDefinition) {\n\t\t\t\t\tthrow new Error('Model Definition could not be found for model');\n\t\t\t\t}\n\n\t\t\t\tconst modelMeta = {\n\t\t\t\t\tbuilder: modelConstructor as PersistentModelConstructor<T>,\n\t\t\t\t\tschema: modelDefinition,\n\t\t\t\t\tpkField: extractPrimaryKeyFieldNames(modelDefinition),\n\t\t\t\t};\n\n\t\t\t\tawait this.storage.runExclusive(async s => {\n\t\t\t\t\t// no enforcement for HAS_MANY on save, because the ~related~ entities\n\t\t\t\t\t// hold the FK in that case.\n\t\t\t\t\tconst nonHasManyRelationships = ModelRelationship.allFrom(\n\t\t\t\t\t\tmodelMeta\n\t\t\t\t\t).filter(r => r.type === 'BELONGS_TO');\n\t\t\t\t\tfor (const relationship of nonHasManyRelationships) {\n\t\t\t\t\t\tconst queryObject = relationship.createRemoteQueryObject(model);\n\t\t\t\t\t\tif (queryObject !== null) {\n\t\t\t\t\t\t\tconst related = await s.query(\n\t\t\t\t\t\t\t\trelationship.remoteModelConstructor,\n\t\t\t\t\t\t\t\tModelPredicateCreator.createFromFlatEqualities(\n\t\t\t\t\t\t\t\t\trelationship.remoteDefinition!,\n\t\t\t\t\t\t\t\t\tqueryObject\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (related.length === 0) {\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t`Data integrity error. You tried to save a ${\n\t\t\t\t\t\t\t\t\t\t\tmodelDefinition.name\n\t\t\t\t\t\t\t\t\t\t} (${JSON.stringify(model)})`,\n\t\t\t\t\t\t\t\t\t\t`but the instance assigned to the \"${relationship.field}\" property`,\n\t\t\t\t\t\t\t\t\t\t`does not exist in the local database. If you're trying to create the related`,\n\t\t\t\t\t\t\t\t\t\t`\"${relationship.remoteDefinition?.name}\", you must save it independently first.`,\n\t\t\t\t\t\t\t\t\t].join(' ')\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tconst producedCondition = condition\n\t\t\t\t\t? internals(\n\t\t\t\t\t\t\tcondition(predicateFor(modelMeta))\n\t\t\t\t\t  ).toStoragePredicate<T>()\n\t\t\t\t\t: undefined;\n\n\t\t\t\tconst [savedModel] = await this.storage.runExclusive(async s => {\n\t\t\t\t\tconst saved = await s.save(\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tproducedCondition,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tpatchesTuple\n\t\t\t\t\t);\n\t\t\t\t\treturn s.query<T>(\n\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\tModelPredicateCreator.createForPk(modelDefinition, model)\n\t\t\t\t\t);\n\t\t\t\t});\n\n\t\t\t\treturn attached(savedModel, ModelAttachment.DataStore);\n\t\t\t}, 'datastore save')\n\t\t\t.catch(this.handleAddProcError('DataStore.save()'));\n\t};\n\n\tsetConflictHandler = (config: DataStoreConfig): ConflictHandler => {\n\t\tconst { DataStore: configDataStore } = config;\n\n\t\tconst conflictHandlerIsDefault: () => boolean = () =>\n\t\t\tthis.conflictHandler === defaultConflictHandler;\n\n\t\tif (configDataStore && configDataStore.conflictHandler) {\n\t\t\treturn configDataStore.conflictHandler;\n\t\t}\n\t\tif (conflictHandlerIsDefault() && config.conflictHandler) {\n\t\t\treturn config.conflictHandler;\n\t\t}\n\n\t\treturn this.conflictHandler || defaultConflictHandler;\n\t};\n\n\tsetErrorHandler = (config: DataStoreConfig): ErrorHandler => {\n\t\tconst { DataStore: configDataStore } = config;\n\n\t\tconst errorHandlerIsDefault: () => boolean = () =>\n\t\t\tthis.errorHandler === defaultErrorHandler;\n\n\t\tif (configDataStore && configDataStore.errorHandler) {\n\t\t\treturn configDataStore.errorHandler;\n\t\t}\n\t\tif (errorHandlerIsDefault() && config.errorHandler) {\n\t\t\treturn config.errorHandler;\n\t\t}\n\n\t\treturn this.errorHandler || defaultErrorHandler;\n\t};\n\n\tdelete: {\n\t\t<T extends PersistentModel>(\n\t\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\t\tidentifier: IdentifierFieldOrIdentifierObject<\n\t\t\t\tT,\n\t\t\t\tPersistentModelMetaData<T>\n\t\t\t>\n\t\t): Promise<T[]>;\n\t\t<T extends PersistentModel>(\n\t\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\t\tcondition: ModelPredicateExtender<T> | typeof PredicateAll\n\t\t): Promise<T[]>;\n\t\t<T extends PersistentModel>(\n\t\t\tmodel: T,\n\t\t\tcondition?: ModelPredicateExtender<T>\n\t\t): Promise<T>;\n\t} = async <T extends PersistentModel>(\n\t\tmodelOrConstructor: T | PersistentModelConstructor<T>,\n\t\tidentifierOrCriteria?:\n\t\t\t| IdentifierFieldOrIdentifierObject<T, PersistentModelMetaData<T>>\n\t\t\t| ModelPredicateExtender<T>\n\t\t\t| typeof PredicateAll\n\t): Promise<T | T[]> => {\n\t\treturn this.runningProcesses\n\t\t\t.add(async () => {\n\t\t\t\tawait this.start();\n\n\t\t\t\tif (!this.storage) {\n\t\t\t\t\tthrow new Error('No storage to delete from');\n\t\t\t\t}\n\n\t\t\t\tlet condition: ModelPredicate<T> | undefined;\n\n\t\t\t\tif (!modelOrConstructor) {\n\t\t\t\t\tconst msg = 'Model or Model Constructor required';\n\t\t\t\t\tlogger.error(msg, { modelOrConstructor });\n\n\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t}\n\n\t\t\t\tif (isValidModelConstructor<T>(modelOrConstructor)) {\n\t\t\t\t\tconst modelConstructor = modelOrConstructor;\n\n\t\t\t\t\tif (!identifierOrCriteria) {\n\t\t\t\t\t\tconst msg =\n\t\t\t\t\t\t\t'Id to delete or criteria required. Do you want to delete all? Pass Predicates.ALL';\n\t\t\t\t\t\tlogger.error(msg, { identifierOrCriteria });\n\n\t\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst modelDefinition = getModelDefinition(modelConstructor);\n\n\t\t\t\t\tif (!modelDefinition) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Could not find model definition for modelConstructor.'\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (typeof identifierOrCriteria === 'string') {\n\t\t\t\t\t\tconst keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n\n\t\t\t\t\t\tif (keyFields.length > 1) {\n\t\t\t\t\t\t\tconst msg = errorMessages.deleteByPkWithCompositeKeyPresent;\n\t\t\t\t\t\t\tlogger.error(msg, { keyFields });\n\n\t\t\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcondition = ModelPredicateCreator.createFromFlatEqualities<T>(\n\t\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\t\t{ [keyFields[0]]: identifierOrCriteria }\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (isIdentifierObject(identifierOrCriteria, modelDefinition)) {\n\t\t\t\t\t\t\tcondition = ModelPredicateCreator.createForPk<T>(\n\t\t\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\t\t\t<T>identifierOrCriteria\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcondition = internals(\n\t\t\t\t\t\t\t\t(identifierOrCriteria as ModelPredicateExtender<T>)(\n\t\t\t\t\t\t\t\t\tpredicateFor({\n\t\t\t\t\t\t\t\t\t\tbuilder: modelConstructor as PersistentModelConstructor<T>,\n\t\t\t\t\t\t\t\t\t\tschema: modelDefinition,\n\t\t\t\t\t\t\t\t\t\tpkField: extractPrimaryKeyFieldNames(modelDefinition),\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t).toStoragePredicate<T>();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!condition ||\n\t\t\t\t\t\t\t!ModelPredicateCreator.isValidPredicate(condition)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst msg =\n\t\t\t\t\t\t\t\t'Criteria required. Do you want to delete all? Pass Predicates.ALL';\n\t\t\t\t\t\t\tlogger.error(msg, { condition });\n\n\t\t\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst [deleted] = await this.storage.delete(\n\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\tcondition\n\t\t\t\t\t);\n\n\t\t\t\t\treturn attached(deleted, ModelAttachment.DataStore);\n\t\t\t\t} else {\n\t\t\t\t\tconst model = modelOrConstructor;\n\t\t\t\t\tconst modelConstructor = Object.getPrototypeOf(model || {})\n\t\t\t\t\t\t.constructor as PersistentModelConstructor<T>;\n\n\t\t\t\t\tif (!isValidModelConstructor(modelConstructor)) {\n\t\t\t\t\t\tconst msg = 'Object is not an instance of a valid model';\n\t\t\t\t\t\tlogger.error(msg, { model });\n\n\t\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst modelDefinition = getModelDefinition(modelConstructor);\n\n\t\t\t\t\tif (!modelDefinition) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Could not find model definition for modelConstructor.'\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst pkPredicate = ModelPredicateCreator.createForPk<T>(\n\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\tmodel\n\t\t\t\t\t);\n\n\t\t\t\t\tif (identifierOrCriteria) {\n\t\t\t\t\t\tif (typeof identifierOrCriteria !== 'function') {\n\t\t\t\t\t\t\tconst msg = 'Invalid criteria';\n\t\t\t\t\t\t\tlogger.error(msg, { identifierOrCriteria });\n\n\t\t\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcondition = internals(\n\t\t\t\t\t\t\t(identifierOrCriteria as ModelPredicateExtender<T>)(\n\t\t\t\t\t\t\t\tpredicateFor({\n\t\t\t\t\t\t\t\t\tbuilder: modelConstructor as PersistentModelConstructor<T>,\n\t\t\t\t\t\t\t\t\tschema: modelDefinition,\n\t\t\t\t\t\t\t\t\tpkField: extractPrimaryKeyFieldNames(modelDefinition),\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t).toStoragePredicate<T>();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcondition = pkPredicate;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst [[deleted]] = await this.storage.delete(model, condition);\n\n\t\t\t\t\treturn attached(deleted, ModelAttachment.DataStore);\n\t\t\t\t}\n\t\t\t}, 'datastore delete')\n\t\t\t.catch(this.handleAddProcError('DataStore.delete()'));\n\t};\n\n\tobserve: {\n\t\t(): Observable<SubscriptionMessage<PersistentModel>>;\n\n\t\t<T extends PersistentModel>(\n\t\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\t\tidentifier: string\n\t\t): Observable<SubscriptionMessage<T>>;\n\n\t\t<T extends PersistentModel>(\n\t\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\t\tcriteria?: RecursiveModelPredicateExtender<T> | typeof PredicateAll\n\t\t): Observable<SubscriptionMessage<T>>;\n\n\t\t<T extends PersistentModel>(model: T): Observable<SubscriptionMessage<T>>;\n\t} = <T extends PersistentModel>(\n\t\tmodelOrConstructor?: T | PersistentModelConstructor<T>,\n\t\tidentifierOrCriteria?:\n\t\t\t| string\n\t\t\t| RecursiveModelPredicateExtender<T>\n\t\t\t| typeof PredicateAll\n\t): Observable<SubscriptionMessage<T>> => {\n\t\tlet executivePredicate: GroupCondition;\n\n\t\tconst modelConstructor: PersistentModelConstructor<T> | undefined =\n\t\t\tmodelOrConstructor && isValidModelConstructor<T>(modelOrConstructor)\n\t\t\t\t? modelOrConstructor\n\t\t\t\t: undefined;\n\n\t\tif (modelOrConstructor && modelConstructor === undefined) {\n\t\t\tconst model = <T>modelOrConstructor;\n\t\t\tconst modelConstructor =\n\t\t\t\tmodel && (<Object>Object.getPrototypeOf(model)).constructor;\n\n\t\t\tif (isValidModelConstructor<T>(modelConstructor)) {\n\t\t\t\tif (identifierOrCriteria) {\n\t\t\t\t\tlogger.warn('idOrCriteria is ignored when using a model instance', {\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tidentifierOrCriteria,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn this.observe(modelConstructor, model.id);\n\t\t\t} else {\n\t\t\t\tconst msg =\n\t\t\t\t\t'The model is not an instance of a PersistentModelConstructor';\n\t\t\t\tlogger.error(msg, { model });\n\n\t\t\t\tthrow new Error(msg);\n\t\t\t}\n\t\t}\n\n\t\t// observe should not accept object literal syntax\n\t\tif (\n\t\t\tidentifierOrCriteria &&\n\t\t\tmodelConstructor &&\n\t\t\tisIdentifierObject(\n\t\t\t\tidentifierOrCriteria,\n\t\t\t\tgetModelDefinition(modelConstructor!)!\n\t\t\t)\n\t\t) {\n\t\t\tconst msg = errorMessages.observeWithObjectLiteral;\n\t\t\tlogger.error(msg, { objectLiteral: identifierOrCriteria });\n\n\t\t\tthrow new Error(msg);\n\t\t}\n\n\t\tif (identifierOrCriteria !== undefined && modelConstructor === undefined) {\n\t\t\tconst msg = 'Cannot provide criteria without a modelConstructor';\n\t\t\tlogger.error(msg, identifierOrCriteria);\n\t\t\tthrow new Error(msg);\n\t\t}\n\n\t\tif (modelConstructor && !isValidModelConstructor(modelConstructor)) {\n\t\t\tconst msg = 'Constructor is not for a valid model';\n\t\t\tlogger.error(msg, { modelConstructor });\n\n\t\t\tthrow new Error(msg);\n\t\t}\n\n\t\tif (modelConstructor && typeof identifierOrCriteria === 'string') {\n\t\t\tconst buildIdPredicate = seed => seed.id.eq(identifierOrCriteria);\n\t\t\texecutivePredicate = internals(\n\t\t\t\tbuildIdPredicate(buildSeedPredicate(modelConstructor))\n\t\t\t);\n\t\t} else if (modelConstructor && typeof identifierOrCriteria === 'function') {\n\t\t\texecutivePredicate = internals(\n\t\t\t\t(identifierOrCriteria as RecursiveModelPredicateExtender<T>)(\n\t\t\t\t\tbuildSeedPredicate(modelConstructor)\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\treturn new Observable<SubscriptionMessage<T>>(observer => {\n\t\t\tlet source: ZenObservable.Subscription;\n\n\t\t\tthis.runningProcesses\n\t\t\t\t.add(async () => {\n\t\t\t\t\tawait this.start();\n\n\t\t\t\t\t// Filter the events returned by Storage according to namespace,\n\t\t\t\t\t// append original element data, and subscribe to the observable\n\t\t\t\t\tsource = this.storage!.observe(modelConstructor)\n\t\t\t\t\t\t.filter(({ model }) => namespaceResolver(model) === USER)\n\t\t\t\t\t\t.subscribe({\n\t\t\t\t\t\t\tnext: item =>\n\t\t\t\t\t\t\t\tthis.runningProcesses.isOpen &&\n\t\t\t\t\t\t\t\tthis.runningProcesses.add(async () => {\n\t\t\t\t\t\t\t\t\t// the `element` doesn't necessarily contain all item details or\n\t\t\t\t\t\t\t\t\t// have related records attached consistently with that of a query()\n\t\t\t\t\t\t\t\t\t// result item. for consistency, we attach them here.\n\n\t\t\t\t\t\t\t\t\tlet message = item;\n\n\t\t\t\t\t\t\t\t\t// as long as we're not dealing with a DELETE, we need to fetch a fresh\n\t\t\t\t\t\t\t\t\t// item from storage to ensure it's fully populated.\n\t\t\t\t\t\t\t\t\tif (item.opType !== 'DELETE') {\n\t\t\t\t\t\t\t\t\t\tconst modelDefinition = getModelDefinition(item.model);\n\t\t\t\t\t\t\t\t\t\tconst keyFields = extractPrimaryKeyFieldNames(\n\t\t\t\t\t\t\t\t\t\t\tmodelDefinition!\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tconst primaryKeysAndValues = extractPrimaryKeysAndValues(\n\t\t\t\t\t\t\t\t\t\t\titem.element,\n\t\t\t\t\t\t\t\t\t\t\tkeyFields\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tconst freshElement = await this.query(\n\t\t\t\t\t\t\t\t\t\t\titem.model,\n\t\t\t\t\t\t\t\t\t\t\tprimaryKeysAndValues\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tmessage = {\n\t\t\t\t\t\t\t\t\t\t\t...message,\n\t\t\t\t\t\t\t\t\t\t\telement: freshElement as T,\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t!executivePredicate ||\n\t\t\t\t\t\t\t\t\t\t(await executivePredicate.matches(message.element))\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tobserver.next(message as SubscriptionMessage<T>);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}, 'datastore observe message handler'),\n\t\t\t\t\t\t\terror: err => observer.error(err),\n\t\t\t\t\t\t\tcomplete: () => observer.complete(),\n\t\t\t\t\t\t});\n\t\t\t\t}, 'datastore observe observable initialization')\n\t\t\t\t.catch(this.handleAddProcError('DataStore.observe()'))\n\t\t\t\t.catch(error => {\n\t\t\t\t\tobserver.error(error);\n\t\t\t\t});\n\n\t\t\t// better than no cleaner, but if the subscriber is handling the\n\t\t\t// complete() message async and not registering with the context,\n\t\t\t// this will still be problematic.\n\t\t\treturn this.runningProcesses.addCleaner(async () => {\n\t\t\t\tif (source) {\n\t\t\t\t\tsource.unsubscribe();\n\t\t\t\t}\n\t\t\t}, 'DataStore.observe() cleanup');\n\t\t});\n\t};\n\n\tobserveQuery: {\n\t\t<T extends PersistentModel>(\n\t\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\t\tcriteria?: RecursiveModelPredicateExtender<T> | typeof PredicateAll,\n\t\t\tpaginationProducer?: ObserveQueryOptions<T>\n\t\t): Observable<DataStoreSnapshot<T>>;\n\t} = <T extends PersistentModel>(\n\t\tmodel: PersistentModelConstructor<T>,\n\t\tcriteria?: RecursiveModelPredicateExtender<T> | typeof PredicateAll,\n\t\toptions?: ObserveQueryOptions<T>\n\t): Observable<DataStoreSnapshot<T>> => {\n\t\treturn new Observable<DataStoreSnapshot<T>>(observer => {\n\t\t\tconst items = new Map<string, T>();\n\t\t\tconst itemsChanged = new Map<string, T>();\n\t\t\tlet deletedItemIds: string[] = [];\n\t\t\tlet handle: ZenObservable.Subscription;\n\t\t\t// let predicate: ModelPredicate<T> | undefined;\n\t\t\tlet executivePredicate: GroupCondition | undefined;\n\n\t\t\t/**\n\t\t\t * As the name suggests, this geneates a snapshot in the form of\n\t\t\t * \t`{items: T[], isSynced: boolean}`\n\t\t\t * and sends it to the observer.\n\t\t\t *\n\t\t\t * SIDE EFFECT: The underlying generation and emission methods may touch:\n\t\t\t * `items`, `itemsChanged`, and `deletedItemIds`.\n\t\t\t *\n\t\t\t * Refer to `generateSnapshot` and `emitSnapshot` for more details.\n\t\t\t */\n\t\t\tconst generateAndEmitSnapshot = (): void => {\n\t\t\t\tconst snapshot = generateSnapshot();\n\t\t\t\temitSnapshot(snapshot);\n\t\t\t};\n\n\t\t\t// a mechanism to return data after X amount of seconds OR after the\n\t\t\t// \"limit\" (itemsChanged >= this.syncPageSize) has been reached, whichever comes first\n\t\t\tconst limitTimerRace = new DeferredCallbackResolver({\n\t\t\t\tcallback: generateAndEmitSnapshot,\n\t\t\t\terrorHandler: observer.error,\n\t\t\t\tmaxInterval: 2000,\n\t\t\t});\n\n\t\t\tconst { sort } = options || {};\n\t\t\tconst sortOptions = sort ? { sort } : undefined;\n\n\t\t\tconst modelDefinition = getModelDefinition(model);\n\t\t\tif (!modelDefinition) {\n\t\t\t\tthrow new Error('Could not find model definition.');\n\t\t\t}\n\n\t\t\tif (model && typeof criteria === 'function') {\n\t\t\t\texecutivePredicate = internals(\n\t\t\t\t\t(criteria as RecursiveModelPredicateExtender<T>)(\n\t\t\t\t\t\tbuildSeedPredicate(model)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t} else if (isPredicatesAll(criteria)) {\n\t\t\t\texecutivePredicate = undefined;\n\t\t\t}\n\n\t\t\tthis.runningProcesses\n\t\t\t\t.add(async () => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// first, query and return any locally-available records\n\t\t\t\t\t\t(await this.query(model, criteria, sortOptions)).forEach(item => {\n\t\t\t\t\t\t\tconst itemModelDefinition = getModelDefinition(model);\n\t\t\t\t\t\t\tconst idOrPk = getIdentifierValue(itemModelDefinition!, item);\n\t\t\t\t\t\t\titems.set(idOrPk, item);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Observe the model and send a stream of updates (debounced).\n\t\t\t\t\t\t// We need to post-filter results instead of passing criteria through\n\t\t\t\t\t\t// to have visibility into items that move from in-set to out-of-set.\n\t\t\t\t\t\t// We need to explicitly remove those items from the existing snapshot.\n\t\t\t\t\t\thandle = this.observe(model).subscribe(\n\t\t\t\t\t\t\t({ element, model, opType }) =>\n\t\t\t\t\t\t\t\tthis.runningProcesses.isOpen &&\n\t\t\t\t\t\t\t\tthis.runningProcesses.add(async () => {\n\t\t\t\t\t\t\t\t\tconst itemModelDefinition = getModelDefinition(model)!;\n\t\t\t\t\t\t\t\t\tconst idOrPk = getIdentifierValue(\n\t\t\t\t\t\t\t\t\t\titemModelDefinition,\n\t\t\t\t\t\t\t\t\t\telement\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\texecutivePredicate &&\n\t\t\t\t\t\t\t\t\t\t!(await executivePredicate.matches(element))\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\topType === 'UPDATE' &&\n\t\t\t\t\t\t\t\t\t\t\t(items.has(idOrPk) || itemsChanged.has(idOrPk))\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t// tracking as a \"deleted item\" will include the item in\n\t\t\t\t\t\t\t\t\t\t\t// page limit calculations and ensure it is removed from the\n\t\t\t\t\t\t\t\t\t\t\t// final items collection, regardless of which collection(s)\n\t\t\t\t\t\t\t\t\t\t\t// it is currently in. (I mean, it could be in both, right!?)\n\t\t\t\t\t\t\t\t\t\t\tdeletedItemIds.push(idOrPk);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t// ignore updates for irrelevant/filtered items.\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Flag items which have been recently deleted\n\t\t\t\t\t\t\t\t\t// NOTE: Merging of separate operations to the same model instance is handled upstream\n\t\t\t\t\t\t\t\t\t// in the `mergePage` method within src/sync/merger.ts. The final state of a model instance\n\t\t\t\t\t\t\t\t\t// depends on the LATEST record (for a given id).\n\t\t\t\t\t\t\t\t\tif (opType === 'DELETE') {\n\t\t\t\t\t\t\t\t\t\tdeletedItemIds.push(idOrPk);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\titemsChanged.set(idOrPk, element);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tconst isSynced =\n\t\t\t\t\t\t\t\t\t\tthis.sync?.getModelSyncedStatus(model) ?? false;\n\n\t\t\t\t\t\t\t\t\tconst limit =\n\t\t\t\t\t\t\t\t\t\titemsChanged.size - deletedItemIds.length >=\n\t\t\t\t\t\t\t\t\t\tthis.syncPageSize;\n\n\t\t\t\t\t\t\t\t\tif (limit || isSynced) {\n\t\t\t\t\t\t\t\t\t\tlimitTimerRace.resolve();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// kicks off every subsequent race as results sync down\n\t\t\t\t\t\t\t\t\tlimitTimerRace.start();\n\t\t\t\t\t\t\t\t}, 'handle observeQuery observed event')\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// returns a set of initial/locally-available results\n\t\t\t\t\t\tgenerateAndEmitSnapshot();\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tobserver.error(err);\n\t\t\t\t\t}\n\t\t\t\t}, 'datastore observequery startup')\n\t\t\t\t.catch(this.handleAddProcError('DataStore.observeQuery()'))\n\t\t\t\t.catch(error => {\n\t\t\t\t\tobserver.error(error);\n\t\t\t\t});\n\n\t\t\t/**\n\t\t\t * Combines the `items`, `itemsChanged`, and `deletedItemIds` collections into\n\t\t\t * a snapshot in the form of `{ items: T[], isSynced: boolean}`.\n\t\t\t *\n\t\t\t * SIDE EFFECT: The shared `items` collection is recreated.\n\t\t\t */\n\t\t\tconst generateSnapshot = (): DataStoreSnapshot<T> => {\n\t\t\t\tconst isSynced = this.sync?.getModelSyncedStatus(model) ?? false;\n\t\t\t\tconst itemsArray = [\n\t\t\t\t\t...Array.from(items.values()),\n\t\t\t\t\t...Array.from(itemsChanged.values()),\n\t\t\t\t];\n\n\t\t\t\titems.clear();\n\t\t\t\titemsArray.forEach(item => {\n\t\t\t\t\tconst itemModelDefinition = getModelDefinition(model);\n\t\t\t\t\tconst idOrPk = getIdentifierValue(itemModelDefinition!, item);\n\t\t\t\t\titems.set(idOrPk, item);\n\t\t\t\t});\n\n\t\t\t\t// remove deleted items from the final result set\n\t\t\t\tdeletedItemIds.forEach(idOrPk => items.delete(idOrPk));\n\n\t\t\t\tconst snapshot = Array.from(items.values());\n\n\t\t\t\t// we sort after we merge the snapshots (items, itemsChanged)\n\t\t\t\t// otherwise, the merge may not\n\t\t\t\tif (options?.sort) {\n\t\t\t\t\tsortItems(snapshot);\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\titems: snapshot,\n\t\t\t\t\tisSynced,\n\t\t\t\t};\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Emits the list of items to the observer.\n\t\t\t *\n\t\t\t * SIDE EFFECT: `itemsChanged` and `deletedItemIds` are cleared to prepare\n\t\t\t * for the next snapshot.\n\t\t\t *\n\t\t\t * @param snapshot The generated items data to emit.\n\t\t\t */\n\t\t\tconst emitSnapshot = (snapshot: DataStoreSnapshot<T>): void => {\n\t\t\t\t// send the generated snapshot to the primary subscription.\n\t\t\t\t// NOTE: This observer's handler *could* be async ...\n\n\t\t\t\tobserver.next(snapshot);\n\n\t\t\t\t// reset the changed items sets\n\t\t\t\titemsChanged.clear();\n\t\t\t\tdeletedItemIds = [];\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Sorts an `Array` of `T` according to the sort instructions given in the\n\t\t\t * original  `observeQuery()` call.\n\t\t\t *\n\t\t\t * @param itemsToSort A array of model type.\n\t\t\t */\n\t\t\tconst sortItems = (itemsToSort: T[]): void => {\n\t\t\t\tconst modelDefinition = getModelDefinition(model);\n\t\t\t\tconst pagination = this.processPagination(modelDefinition!, options);\n\n\t\t\t\tconst sortPredicates = ModelSortPredicateCreator.getPredicates(\n\t\t\t\t\tpagination!.sort!\n\t\t\t\t);\n\n\t\t\t\tif (sortPredicates.length) {\n\t\t\t\t\tconst compareFn = sortCompareFunction(sortPredicates);\n\t\t\t\t\titemsToSort.sort(compareFn);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Force one last snapshot when the model is fully synced.\n\t\t\t *\n\t\t\t * This reduces latency for that last snapshot, which will otherwise\n\t\t\t * wait for the configured timeout.\n\t\t\t *\n\t\t\t * @param payload The payload from the Hub event.\n\t\t\t */\n\t\t\tconst hubCallback = ({ payload }): void => {\n\t\t\t\tconst { event, data } = payload;\n\t\t\t\tif (\n\t\t\t\t\tevent === ControlMessage.SYNC_ENGINE_MODEL_SYNCED &&\n\t\t\t\t\tdata?.model?.name === model.name\n\t\t\t\t) {\n\t\t\t\t\tgenerateAndEmitSnapshot();\n\t\t\t\t\tHub.remove('datastore', hubCallback);\n\t\t\t\t}\n\t\t\t};\n\t\t\tHub.listen('datastore', hubCallback);\n\n\t\t\treturn this.runningProcesses.addCleaner(async () => {\n\t\t\t\tif (handle) {\n\t\t\t\t\thandle.unsubscribe();\n\t\t\t\t}\n\t\t\t}, 'datastore observequery cleaner');\n\t\t});\n\t};\n\n\tconfigure = (config: DataStoreConfig = {}) => {\n\t\tthis.amplifyContext.Auth = this.Auth;\n\t\tthis.amplifyContext.InternalAPI = this.InternalAPI;\n\t\tthis.amplifyContext.Cache = this.Cache;\n\n\t\tconst {\n\t\t\tDataStore: configDataStore,\n\t\t\tauthModeStrategyType: configAuthModeStrategyType,\n\t\t\tconflictHandler: configConflictHandler,\n\t\t\terrorHandler: configErrorHandler,\n\t\t\tmaxRecordsToSync: configMaxRecordsToSync,\n\t\t\tsyncPageSize: configSyncPageSize,\n\t\t\tfullSyncInterval: configFullSyncInterval,\n\t\t\tsyncExpressions: configSyncExpressions,\n\t\t\tauthProviders: configAuthProviders,\n\t\t\tstorageAdapter: configStorageAdapter,\n\t\t\t...configFromAmplify\n\t\t} = config;\n\n\t\tthis.amplifyConfig = {\n\t\t\t...configFromAmplify,\n\t\t\t...this.amplifyConfig,\n\t\t};\n\n\t\tthis.conflictHandler = this.setConflictHandler(config);\n\t\tthis.errorHandler = this.setErrorHandler(config);\n\n\t\tconst authModeStrategyType =\n\t\t\t(configDataStore && configDataStore.authModeStrategyType) ||\n\t\t\tconfigAuthModeStrategyType ||\n\t\t\tAuthModeStrategyType.DEFAULT;\n\n\t\tswitch (authModeStrategyType) {\n\t\t\tcase AuthModeStrategyType.MULTI_AUTH:\n\t\t\t\tthis.authModeStrategy = multiAuthStrategy(this.amplifyContext);\n\t\t\t\tbreak;\n\t\t\tcase AuthModeStrategyType.DEFAULT:\n\t\t\t\tthis.authModeStrategy = defaultAuthStrategy;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthis.authModeStrategy = defaultAuthStrategy;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// store on config object, so that Sync, Subscription, and Mutation processors can have access\n\t\tthis.amplifyConfig.authProviders =\n\t\t\t(configDataStore && configDataStore.authProviders) || configAuthProviders;\n\n\t\tthis.syncExpressions =\n\t\t\t(configDataStore && configDataStore.syncExpressions) ||\n\t\t\tconfigSyncExpressions ||\n\t\t\tthis.syncExpressions;\n\n\t\tthis.maxRecordsToSync =\n\t\t\t(configDataStore && configDataStore.maxRecordsToSync) ||\n\t\t\tconfigMaxRecordsToSync ||\n\t\t\tthis.maxRecordsToSync ||\n\t\t\t10000;\n\n\t\t// store on config object, so that Sync, Subscription, and Mutation processors can have access\n\t\tthis.amplifyConfig.maxRecordsToSync = this.maxRecordsToSync;\n\n\t\tthis.syncPageSize =\n\t\t\t(configDataStore && configDataStore.syncPageSize) ||\n\t\t\tconfigSyncPageSize ||\n\t\t\tthis.syncPageSize ||\n\t\t\t1000;\n\n\t\t// store on config object, so that Sync, Subscription, and Mutation processors can have access\n\t\tthis.amplifyConfig.syncPageSize = this.syncPageSize;\n\n\t\tthis.fullSyncInterval =\n\t\t\t(configDataStore && configDataStore.fullSyncInterval) ||\n\t\t\tconfigFullSyncInterval ||\n\t\t\tthis.fullSyncInterval ||\n\t\t\t24 * 60; // 1 day\n\n\t\tthis.storageAdapter =\n\t\t\t(configDataStore && configDataStore.storageAdapter) ||\n\t\t\tconfigStorageAdapter ||\n\t\t\tthis.storageAdapter ||\n\t\t\tundefined;\n\n\t\tthis.sessionId = this.retrieveSessionId()!;\n\t};\n\n\t/**\n\t * Clears all data from storage and removes all data, schema info, other\n\t * initialization details, and then stops DataStore.\n\t *\n\t * That said, reinitialization is required after clearing. This can be done\n\t * by explicitiliy calling `start()` or any method that implicitly starts\n\t * DataStore, such as `query()`, `save()`, or `delete()`.\n\t */\n\tasync clear() {\n\t\tcheckSchemaInitialized();\n\t\tthis.state = DataStoreState.Clearing;\n\t\tawait this.runningProcesses.close();\n\t\tif (this.storage === undefined) {\n\t\t\t// connect to storage so that it can be cleared without fully starting DataStore\n\t\t\tthis.storage = new Storage(\n\t\t\t\tschema,\n\t\t\t\tnamespaceResolver,\n\t\t\t\tgetModelConstructorByModelName,\n\t\t\t\tmodelInstanceCreator,\n\t\t\t\tthis.storageAdapter,\n\t\t\t\tthis.sessionId\n\t\t\t);\n\t\t\tawait this.storage.init();\n\t\t}\n\n\t\tif (syncSubscription && !syncSubscription.closed) {\n\t\t\tsyncSubscription.unsubscribe();\n\t\t}\n\n\t\tif (this.sync) {\n\t\t\tawait this.sync.stop();\n\t\t}\n\n\t\tawait this.storage!.clear();\n\n\t\tthis.initialized = undefined; // Should re-initialize when start() is called.\n\t\tthis.storage = undefined;\n\t\tthis.sync = undefined;\n\t\tthis.syncPredicates = new WeakMap<SchemaModel, ModelPredicate<any>>();\n\n\t\tawait this.runningProcesses.open();\n\t\tthis.state = DataStoreState.NotRunning;\n\t}\n\n\t/**\n\t * Stops all DataStore sync activities.\n\t *\n\t * TODO: \"Waits for graceful termination of\n\t * running queries and terminates subscriptions.\"\n\t */\n\tasync stop(this: InstanceType<typeof DataStore>) {\n\t\tthis.state = DataStoreState.Stopping;\n\n\t\tawait this.runningProcesses.close();\n\n\t\tif (syncSubscription && !syncSubscription.closed) {\n\t\t\tsyncSubscription.unsubscribe();\n\t\t}\n\n\t\tif (this.sync) {\n\t\t\tawait this.sync.stop();\n\t\t}\n\n\t\tthis.initialized = undefined; // Should re-initialize when start() is called.\n\t\tthis.sync = undefined;\n\t\tawait this.runningProcesses.open();\n\t\tthis.state = DataStoreState.NotRunning;\n\t}\n\n\t/**\n\t * Validates given pagination input from a query and creates a pagination\n\t * argument for use against the storage layer.\n\t *\n\t * @param modelDefinition\n\t * @param paginationProducer\n\t */\n\tprivate processPagination<T extends PersistentModel>(\n\t\tmodelDefinition: SchemaModel,\n\t\tpaginationProducer?: ProducerPaginationInput<T>\n\t): PaginationInput<T> | undefined {\n\t\tlet sortPredicate: SortPredicate<T> | undefined;\n\t\tconst { limit, page, sort } = paginationProducer || {};\n\n\t\tif (limit === undefined && page === undefined && sort === undefined) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (page !== undefined && limit === undefined) {\n\t\t\tthrow new Error('Limit is required when requesting a page');\n\t\t}\n\n\t\tif (page !== undefined) {\n\t\t\tif (typeof page !== 'number') {\n\t\t\t\tthrow new Error('Page should be a number');\n\t\t\t}\n\n\t\t\tif (page < 0) {\n\t\t\t\tthrow new Error(\"Page can't be negative\");\n\t\t\t}\n\t\t}\n\n\t\tif (limit !== undefined) {\n\t\t\tif (typeof limit !== 'number') {\n\t\t\t\tthrow new Error('Limit should be a number');\n\t\t\t}\n\n\t\t\tif (limit < 0) {\n\t\t\t\tthrow new Error(\"Limit can't be negative\");\n\t\t\t}\n\t\t}\n\n\t\tif (sort) {\n\t\t\tsortPredicate = ModelSortPredicateCreator.createFromExisting(\n\t\t\t\tmodelDefinition,\n\t\t\t\tsort\n\t\t\t);\n\t\t}\n\n\t\treturn {\n\t\t\tlimit,\n\t\t\tpage,\n\t\t\tsort: sortPredicate,\n\t\t};\n\t}\n\n\t/**\n\t * Examines the configured `syncExpressions` and produces a WeakMap of\n\t * SchemaModel -> predicate to use during sync.\n\t */\n\tprivate async processSyncExpressions(): Promise<\n\t\tWeakMap<SchemaModel, ModelPredicate<any> | null>\n\t> {\n\t\tif (!this.syncExpressions || !this.syncExpressions.length) {\n\t\t\treturn new WeakMap<SchemaModel, ModelPredicate<any>>();\n\t\t}\n\n\t\tconst syncPredicates = await Promise.all(\n\t\t\tthis.syncExpressions.map(\n\t\t\t\tasync (\n\t\t\t\t\tsyncExpression: SyncExpression\n\t\t\t\t): Promise<[SchemaModel, ModelPredicate<any> | null]> => {\n\t\t\t\t\tconst { modelConstructor, conditionProducer } = await syncExpression;\n\t\t\t\t\tconst modelDefinition = getModelDefinition(modelConstructor)!;\n\n\t\t\t\t\t// conditionProducer is either a predicate, e.g. (c) => c.field.eq(1)\n\t\t\t\t\t// OR a function/promise that returns a predicate\n\t\t\t\t\tconst condition = await this.unwrapPromise(conditionProducer);\n\t\t\t\t\tif (isPredicatesAll(condition)) {\n\t\t\t\t\t\treturn [modelDefinition, null];\n\t\t\t\t\t}\n\n\t\t\t\t\tconst predicate = internals(\n\t\t\t\t\t\tcondition(\n\t\t\t\t\t\t\tpredicateFor({\n\t\t\t\t\t\t\t\tbuilder: modelConstructor,\n\t\t\t\t\t\t\t\tschema: modelDefinition,\n\t\t\t\t\t\t\t\tpkField: extractPrimaryKeyFieldNames(modelDefinition),\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t)\n\t\t\t\t\t).toStoragePredicate<any>();\n\n\t\t\t\t\treturn [modelDefinition, predicate];\n\t\t\t\t}\n\t\t\t)\n\t\t);\n\n\t\treturn this.weakMapFromEntries(syncPredicates);\n\t}\n\n\tprivate async unwrapPromise<T extends PersistentModel>(\n\t\tconditionProducer\n\t): Promise<ModelPredicateExtender<T>> {\n\t\ttry {\n\t\t\tconst condition = await conditionProducer();\n\t\t\treturn condition || conditionProducer;\n\t\t} catch (error) {\n\t\t\tif (error instanceof TypeError) {\n\t\t\t\treturn conditionProducer;\n\t\t\t}\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tprivate weakMapFromEntries(\n\t\tentries: [SchemaModel, ModelPredicate<any> | null][]\n\t): WeakMap<SchemaModel, ModelPredicate<any>> {\n\t\treturn entries.reduce((map, [modelDefinition, predicate]) => {\n\t\t\tif (map.has(modelDefinition)) {\n\t\t\t\tconst { name } = modelDefinition;\n\t\t\t\tlogger.warn(\n\t\t\t\t\t`You can only utilize one Sync Expression per model.\n          Subsequent sync expressions for the ${name} model will be ignored.`\n\t\t\t\t);\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\tif (predicate) {\n\t\t\t\tmap.set(modelDefinition, predicate);\n\t\t\t}\n\n\t\t\treturn map;\n\t\t}, new WeakMap<SchemaModel, ModelPredicate<any>>());\n\t}\n\n\t/**\n\t * A session ID to allow CMS to open databases against multiple apps.\n\t * This session ID is only expected be set by AWS Amplify Studio.\n\t */\n\tprivate retrieveSessionId(): string | undefined {\n\t\ttry {\n\t\t\tconst sessionId = sessionStorage.getItem('datastoreSessionId');\n\n\t\t\tif (sessionId) {\n\t\t\t\tconst { aws_appsync_graphqlEndpoint } = this.amplifyConfig;\n\n\t\t\t\tconst appSyncUrl = aws_appsync_graphqlEndpoint.split('/')[2];\n\t\t\t\tconst [appSyncId] = appSyncUrl.split('.');\n\n\t\t\t\treturn `${sessionId}-${appSyncId}`;\n\t\t\t}\n\t\t} catch {}\n\n\t\treturn undefined;\n\t}\n}\n\nconst instance = new DataStore();\nAmplify.register(instance);\n\nexport { DataStore as DataStoreClass, initSchema, instance as DataStore };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}