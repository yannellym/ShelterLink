{"ast":null,"code":"var SHORT_TO_HEX = {};\nvar HEX_TO_SHORT = {};\nfor (var i = 0; i < 256; i++) {\n  var encodedByte = i.toString(16).toLowerCase();\n  if (encodedByte.length === 1) {\n    encodedByte = \"0\".concat(encodedByte);\n  }\n  SHORT_TO_HEX[i] = encodedByte;\n  HEX_TO_SHORT[encodedByte] = i;\n}\nexport function fromHex(encoded) {\n  if (encoded.length % 2 !== 0) {\n    throw new Error(\"Hex encoded strings must have an even number length\");\n  }\n  var out = new Uint8Array(encoded.length / 2);\n  for (var i = 0; i < encoded.length; i += 2) {\n    var encodedByte = encoded.slice(i, i + 2).toLowerCase();\n    if (encodedByte in HEX_TO_SHORT) {\n      out[i / 2] = HEX_TO_SHORT[encodedByte];\n    } else {\n      throw new Error(\"Cannot decode unrecognized sequence \".concat(encodedByte, \" as hexadecimal\"));\n    }\n  }\n  return out;\n}\nexport function toHex(bytes) {\n  var out = \"\";\n  for (var i = 0; i < bytes.byteLength; i++) {\n    out += SHORT_TO_HEX[bytes[i]];\n  }\n  return out;\n}","map":{"version":3,"names":["SHORT_TO_HEX","HEX_TO_SHORT","i","encodedByte","toString","toLowerCase","length","concat","fromHex","encoded","Error","out","Uint8Array","slice","toHex","bytes","byteLength"],"sources":["/Users/yannellym/Desktop/iwantapet/node_modules/@aws-sdk/client-location/node_modules/@aws-sdk/util-hex-encoding/dist-es/index.js"],"sourcesContent":["var SHORT_TO_HEX = {};\nvar HEX_TO_SHORT = {};\nfor (var i = 0; i < 256; i++) {\n    var encodedByte = i.toString(16).toLowerCase();\n    if (encodedByte.length === 1) {\n        encodedByte = \"0\".concat(encodedByte);\n    }\n    SHORT_TO_HEX[i] = encodedByte;\n    HEX_TO_SHORT[encodedByte] = i;\n}\nexport function fromHex(encoded) {\n    if (encoded.length % 2 !== 0) {\n        throw new Error(\"Hex encoded strings must have an even number length\");\n    }\n    var out = new Uint8Array(encoded.length / 2);\n    for (var i = 0; i < encoded.length; i += 2) {\n        var encodedByte = encoded.slice(i, i + 2).toLowerCase();\n        if (encodedByte in HEX_TO_SHORT) {\n            out[i / 2] = HEX_TO_SHORT[encodedByte];\n        }\n        else {\n            throw new Error(\"Cannot decode unrecognized sequence \".concat(encodedByte, \" as hexadecimal\"));\n        }\n    }\n    return out;\n}\nexport function toHex(bytes) {\n    var out = \"\";\n    for (var i = 0; i < bytes.byteLength; i++) {\n        out += SHORT_TO_HEX[bytes[i]];\n    }\n    return out;\n}\n"],"mappings":"AAAA,IAAIA,YAAY,GAAG,CAAC,CAAC;AACrB,IAAIC,YAAY,GAAG,CAAC,CAAC;AACrB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,GAAG,EAAEA,CAAC,EAAE,EAAE;EAC1B,IAAIC,WAAW,GAAGD,CAAC,CAACE,QAAQ,CAAC,EAAE,CAAC,CAACC,WAAW,CAAC,CAAC;EAC9C,IAAIF,WAAW,CAACG,MAAM,KAAK,CAAC,EAAE;IAC1BH,WAAW,GAAG,GAAG,CAACI,MAAM,CAACJ,WAAW,CAAC;EACzC;EACAH,YAAY,CAACE,CAAC,CAAC,GAAGC,WAAW;EAC7BF,YAAY,CAACE,WAAW,CAAC,GAAGD,CAAC;AACjC;AACA,OAAO,SAASM,OAAOA,CAACC,OAAO,EAAE;EAC7B,IAAIA,OAAO,CAACH,MAAM,GAAG,CAAC,KAAK,CAAC,EAAE;IAC1B,MAAM,IAAII,KAAK,CAAC,qDAAqD,CAAC;EAC1E;EACA,IAAIC,GAAG,GAAG,IAAIC,UAAU,CAACH,OAAO,CAACH,MAAM,GAAG,CAAC,CAAC;EAC5C,KAAK,IAAIJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGO,OAAO,CAACH,MAAM,EAAEJ,CAAC,IAAI,CAAC,EAAE;IACxC,IAAIC,WAAW,GAAGM,OAAO,CAACI,KAAK,CAACX,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC,CAACG,WAAW,CAAC,CAAC;IACvD,IAAIF,WAAW,IAAIF,YAAY,EAAE;MAC7BU,GAAG,CAACT,CAAC,GAAG,CAAC,CAAC,GAAGD,YAAY,CAACE,WAAW,CAAC;IAC1C,CAAC,MACI;MACD,MAAM,IAAIO,KAAK,CAAC,sCAAsC,CAACH,MAAM,CAACJ,WAAW,EAAE,iBAAiB,CAAC,CAAC;IAClG;EACJ;EACA,OAAOQ,GAAG;AACd;AACA,OAAO,SAASG,KAAKA,CAACC,KAAK,EAAE;EACzB,IAAIJ,GAAG,GAAG,EAAE;EACZ,KAAK,IAAIT,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGa,KAAK,CAACC,UAAU,EAAEd,CAAC,EAAE,EAAE;IACvCS,GAAG,IAAIX,YAAY,CAACe,KAAK,CAACb,CAAC,CAAC,CAAC;EACjC;EACA,OAAOS,GAAG;AACd"},"metadata":{},"sourceType":"module","externalDependencies":[]}