{"ast":null,"code":"import { __awaiter, __generator, __read, __spread, __values } from \"tslib\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { browserOrNode, ConsoleLogger as Logger, BackgroundProcessManager, Hub } from '@aws-amplify/core';\nimport { CONTROL_MSG as PUBSUB_CONTROL_MSG, CONNECTION_STATE_CHANGE as PUBSUB_CONNECTION_STATE_CHANGE, ConnectionState } from '@aws-amplify/pubsub';\nimport Observable from 'zen-observable-ts';\nimport { ModelPredicateCreator } from '../predicates';\nimport { OpType } from '../types';\nimport { getNow, SYNC, USER } from '../util';\nimport DataStoreConnectivity from './datastoreConnectivity';\nimport { ModelMerger } from './merger';\nimport { MutationEventOutbox } from './outbox';\nimport { MutationProcessor } from './processors/mutation';\nimport { CONTROL_MSG, SubscriptionProcessor } from './processors/subscription';\nimport { SyncProcessor } from './processors/sync';\nimport { createMutationInstanceFromModelOperation, getIdentifierValue, predicateToGraphQLCondition } from './utils';\nvar isNode = browserOrNode().isNode;\nvar logger = new Logger('DataStore');\nvar ownSymbol = Symbol('sync');\nexport var ControlMessage;\n(function (ControlMessage) {\n  ControlMessage[\"SYNC_ENGINE_STORAGE_SUBSCRIBED\"] = \"storageSubscribed\";\n  ControlMessage[\"SYNC_ENGINE_SUBSCRIPTIONS_ESTABLISHED\"] = \"subscriptionsEstablished\";\n  ControlMessage[\"SYNC_ENGINE_SYNC_QUERIES_STARTED\"] = \"syncQueriesStarted\";\n  ControlMessage[\"SYNC_ENGINE_SYNC_QUERIES_READY\"] = \"syncQueriesReady\";\n  ControlMessage[\"SYNC_ENGINE_MODEL_SYNCED\"] = \"modelSynced\";\n  ControlMessage[\"SYNC_ENGINE_OUTBOX_MUTATION_ENQUEUED\"] = \"outboxMutationEnqueued\";\n  ControlMessage[\"SYNC_ENGINE_OUTBOX_MUTATION_PROCESSED\"] = \"outboxMutationProcessed\";\n  ControlMessage[\"SYNC_ENGINE_OUTBOX_STATUS\"] = \"outboxStatus\";\n  ControlMessage[\"SYNC_ENGINE_NETWORK_STATUS\"] = \"networkStatus\";\n  ControlMessage[\"SYNC_ENGINE_READY\"] = \"ready\";\n})(ControlMessage || (ControlMessage = {}));\nvar SyncEngine = /** @class */function () {\n  function SyncEngine(schema, namespaceResolver, modelClasses, userModelClasses, storage, modelInstanceCreator, conflictHandler, errorHandler, syncPredicates, amplifyConfig, authModeStrategy, amplifyContext, connectivityMonitor) {\n    var _this = this;\n    if (amplifyConfig === void 0) {\n      amplifyConfig = {};\n    }\n    this.schema = schema;\n    this.namespaceResolver = namespaceResolver;\n    this.modelClasses = modelClasses;\n    this.userModelClasses = userModelClasses;\n    this.storage = storage;\n    this.modelInstanceCreator = modelInstanceCreator;\n    this.syncPredicates = syncPredicates;\n    this.amplifyConfig = amplifyConfig;\n    this.authModeStrategy = authModeStrategy;\n    this.amplifyContext = amplifyContext;\n    this.connectivityMonitor = connectivityMonitor;\n    this.online = false;\n    this.modelSyncedStatus = new WeakMap();\n    this.connectionDisrupted = false;\n    this.runningProcesses = new BackgroundProcessManager();\n    this.waitForSleepState = new Promise(function (resolve) {\n      _this.syncQueriesObservableStartSleeping = resolve;\n    });\n    var MutationEvent = this.modelClasses['MutationEvent'];\n    this.outbox = new MutationEventOutbox(this.schema, MutationEvent, modelInstanceCreator, ownSymbol);\n    this.modelMerger = new ModelMerger(this.outbox, ownSymbol);\n    this.syncQueriesProcessor = new SyncProcessor(this.schema, this.syncPredicates, this.amplifyConfig, this.authModeStrategy, errorHandler, this.amplifyContext);\n    this.subscriptionsProcessor = new SubscriptionProcessor(this.schema, this.syncPredicates, this.amplifyConfig, this.authModeStrategy, errorHandler, this.amplifyContext);\n    this.mutationsProcessor = new MutationProcessor(this.schema, this.storage, this.userModelClasses, this.outbox, this.modelInstanceCreator, MutationEvent, this.amplifyConfig, this.authModeStrategy, errorHandler, conflictHandler, this.amplifyContext);\n    this.datastoreConnectivity = this.connectivityMonitor || new DataStoreConnectivity();\n  }\n  SyncEngine.prototype.getModelSyncedStatus = function (modelConstructor) {\n    return this.modelSyncedStatus.get(modelConstructor);\n  };\n  SyncEngine.prototype.start = function (params) {\n    var _this = this;\n    return new Observable(function (observer) {\n      logger.log('starting sync engine...');\n      var subscriptions = [];\n      _this.runningProcesses.add(function () {\n        return __awaiter(_this, void 0, void 0, function () {\n          var err_1, startPromise, hasMutationsInOutbox;\n          var _this = this;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                _a.trys.push([0, 2,, 3]);\n                return [4 /*yield*/, this.setupModels(params)];\n              case 1:\n                _a.sent();\n                return [3 /*break*/, 3];\n              case 2:\n                err_1 = _a.sent();\n                observer.error(err_1);\n                return [2 /*return*/];\n              case 3:\n                startPromise = new Promise(function (doneStarting, failedStarting) {\n                  _this.datastoreConnectivity.status().subscribe(function (_a) {\n                    var online = _a.online;\n                    return __awaiter(_this, void 0, void 0, function () {\n                      var _this = this;\n                      return __generator(this, function (_b) {\n                        return [2 /*return*/, this.runningProcesses.isOpen && this.runningProcesses.add(function (onTerminate) {\n                          return __awaiter(_this, void 0, void 0, function () {\n                            var ctlSubsObservable_1, dataSubsObservable, err_2, error_1;\n                            var _a;\n                            var _this = this;\n                            return __generator(this, function (_b) {\n                              switch (_b.label) {\n                                case 0:\n                                  if (!(online && !this.online)) return [3 /*break*/, 10];\n                                  this.online = online;\n                                  observer.next({\n                                    type: ControlMessage.SYNC_ENGINE_NETWORK_STATUS,\n                                    data: {\n                                      active: this.online\n                                    }\n                                  });\n                                  dataSubsObservable = void 0;\n                                  if (!isNode) return [3 /*break*/, 1];\n                                  logger.warn('Realtime disabled when in a server-side environment');\n                                  return [3 /*break*/, 6];\n                                case 1:\n                                  this.stopDisruptionListener = this.startDisruptionListener();\n                                  //#region GraphQL Subscriptions\n                                  _a = __read(this.subscriptionsProcessor.start(), 2), ctlSubsObservable_1 = _a[0], dataSubsObservable = _a[1];\n                                  _b.label = 2;\n                                case 2:\n                                  _b.trys.push([2, 4,, 5]);\n                                  return [4 /*yield*/, new Promise(function (resolve, reject) {\n                                    onTerminate.then(reject);\n                                    var ctlSubsSubscription = ctlSubsObservable_1.subscribe({\n                                      next: function (msg) {\n                                        if (msg === CONTROL_MSG.CONNECTED) {\n                                          resolve();\n                                        }\n                                      },\n                                      error: function (err) {\n                                        reject(err);\n                                        var handleDisconnect = _this.disconnectionHandler();\n                                        handleDisconnect(err);\n                                      }\n                                    });\n                                    subscriptions.push(ctlSubsSubscription);\n                                  })];\n                                case 3:\n                                  _b.sent();\n                                  return [3 /*break*/, 5];\n                                case 4:\n                                  err_2 = _b.sent();\n                                  observer.error(err_2);\n                                  failedStarting();\n                                  return [2 /*return*/];\n                                case 5:\n                                  logger.log('Realtime ready');\n                                  observer.next({\n                                    type: ControlMessage.SYNC_ENGINE_SUBSCRIPTIONS_ESTABLISHED\n                                  });\n                                  _b.label = 6;\n                                case 6:\n                                  _b.trys.push([6, 8,, 9]);\n                                  return [4 /*yield*/, new Promise(function (resolve, reject) {\n                                    var syncQuerySubscription = _this.syncQueriesObservable().subscribe({\n                                      next: function (message) {\n                                        var type = message.type;\n                                        if (type === ControlMessage.SYNC_ENGINE_SYNC_QUERIES_READY) {\n                                          resolve();\n                                        }\n                                        observer.next(message);\n                                      },\n                                      complete: function () {\n                                        resolve();\n                                      },\n                                      error: function (error) {\n                                        reject(error);\n                                      }\n                                    });\n                                    if (syncQuerySubscription) {\n                                      subscriptions.push(syncQuerySubscription);\n                                    }\n                                  })];\n                                case 7:\n                                  _b.sent();\n                                  return [3 /*break*/, 9];\n                                case 8:\n                                  error_1 = _b.sent();\n                                  observer.error(error_1);\n                                  failedStarting();\n                                  return [2 /*return*/];\n                                case 9:\n                                  //#endregion\n                                  //#region process mutations (outbox)\n                                  subscriptions.push(this.mutationsProcessor.start().subscribe(function (_a) {\n                                    var modelDefinition = _a.modelDefinition,\n                                      item = _a.model,\n                                      hasMore = _a.hasMore;\n                                    return _this.runningProcesses.add(function () {\n                                      return __awaiter(_this, void 0, void 0, function () {\n                                        var modelConstructor, model;\n                                        var _this = this;\n                                        return __generator(this, function (_a) {\n                                          switch (_a.label) {\n                                            case 0:\n                                              modelConstructor = this.userModelClasses[modelDefinition.name];\n                                              model = this.modelInstanceCreator(modelConstructor, item);\n                                              return [4 /*yield*/, this.storage.runExclusive(function (storage) {\n                                                return _this.modelMerger.merge(storage, model, modelDefinition);\n                                              })];\n                                            case 1:\n                                              _a.sent();\n                                              observer.next({\n                                                type: ControlMessage.SYNC_ENGINE_OUTBOX_MUTATION_PROCESSED,\n                                                data: {\n                                                  model: modelConstructor,\n                                                  element: model\n                                                }\n                                              });\n                                              observer.next({\n                                                type: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n                                                data: {\n                                                  isEmpty: !hasMore\n                                                }\n                                              });\n                                              return [2 /*return*/];\n                                          }\n                                        });\n                                      });\n                                    }, 'mutation processor event');\n                                  }));\n                                  //#endregion\n                                  //#region Merge subscriptions buffer\n                                  // TODO: extract to function\n                                  if (!isNode) {\n                                    subscriptions.push(dataSubsObservable.subscribe(function (_a) {\n                                      var _b = __read(_a, 3),\n                                        _transformerMutationType = _b[0],\n                                        modelDefinition = _b[1],\n                                        item = _b[2];\n                                      return _this.runningProcesses.add(function () {\n                                        return __awaiter(_this, void 0, void 0, function () {\n                                          var modelConstructor, model;\n                                          var _this = this;\n                                          return __generator(this, function (_a) {\n                                            switch (_a.label) {\n                                              case 0:\n                                                modelConstructor = this.userModelClasses[modelDefinition.name];\n                                                model = this.modelInstanceCreator(modelConstructor, item);\n                                                return [4 /*yield*/, this.storage.runExclusive(function (storage) {\n                                                  return _this.modelMerger.merge(storage, model, modelDefinition);\n                                                })];\n                                              case 1:\n                                                _a.sent();\n                                                return [2 /*return*/];\n                                            }\n                                          });\n                                        });\n                                      }, 'subscription dataSubsObservable event');\n                                    }));\n                                  }\n                                  return [3 /*break*/, 11];\n                                case 10:\n                                  if (!online) {\n                                    this.online = online;\n                                    observer.next({\n                                      type: ControlMessage.SYNC_ENGINE_NETWORK_STATUS,\n                                      data: {\n                                        active: this.online\n                                      }\n                                    });\n                                    subscriptions.forEach(function (sub) {\n                                      return sub.unsubscribe();\n                                    });\n                                    subscriptions = [];\n                                  }\n                                  _b.label = 11;\n                                case 11:\n                                  doneStarting();\n                                  return [2 /*return*/];\n                              }\n                            });\n                          });\n                        }, 'datastore connectivity event')];\n                      });\n                    });\n                  });\n                });\n                this.storage.observe(null, null, ownSymbol).filter(function (_a) {\n                  var model = _a.model;\n                  var modelDefinition = _this.getModelDefinition(model);\n                  return modelDefinition.syncable === true;\n                }).subscribe({\n                  next: function (_a) {\n                    var opType = _a.opType,\n                      model = _a.model,\n                      element = _a.element,\n                      condition = _a.condition;\n                    return __awaiter(_this, void 0, void 0, function () {\n                      var _this = this;\n                      return __generator(this, function (_b) {\n                        return [2 /*return*/, this.runningProcesses.add(function () {\n                          return __awaiter(_this, void 0, void 0, function () {\n                            var namespace, MutationEventConstructor, modelDefinition, graphQLCondition, mutationEvent;\n                            return __generator(this, function (_a) {\n                              switch (_a.label) {\n                                case 0:\n                                  namespace = this.schema.namespaces[this.namespaceResolver(model)];\n                                  MutationEventConstructor = this.modelClasses['MutationEvent'];\n                                  modelDefinition = this.getModelDefinition(model);\n                                  graphQLCondition = predicateToGraphQLCondition(condition, modelDefinition);\n                                  mutationEvent = createMutationInstanceFromModelOperation(namespace.relationships, this.getModelDefinition(model), opType, model, element, graphQLCondition, MutationEventConstructor, this.modelInstanceCreator);\n                                  return [4 /*yield*/, this.outbox.enqueue(this.storage, mutationEvent)];\n                                case 1:\n                                  _a.sent();\n                                  observer.next({\n                                    type: ControlMessage.SYNC_ENGINE_OUTBOX_MUTATION_ENQUEUED,\n                                    data: {\n                                      model: model,\n                                      element: element\n                                    }\n                                  });\n                                  observer.next({\n                                    type: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n                                    data: {\n                                      isEmpty: false\n                                    }\n                                  });\n                                  return [4 /*yield*/, startPromise];\n                                case 2:\n                                  _a.sent();\n                                  // Set by the this.datastoreConnectivity.status().subscribe() loop\n                                  if (this.online) {\n                                    this.mutationsProcessor.resume();\n                                  }\n                                  return [2 /*return*/];\n                              }\n                            });\n                          });\n                        }, 'storage event')];\n                      });\n                    });\n                  }\n                });\n                observer.next({\n                  type: ControlMessage.SYNC_ENGINE_STORAGE_SUBSCRIBED\n                });\n                return [4 /*yield*/, this.outbox.peek(this.storage)];\n              case 4:\n                hasMutationsInOutbox = _a.sent() === undefined;\n                observer.next({\n                  type: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n                  data: {\n                    isEmpty: hasMutationsInOutbox\n                  }\n                });\n                return [4 /*yield*/, startPromise];\n              case 5:\n                _a.sent();\n                observer.next({\n                  type: ControlMessage.SYNC_ENGINE_READY\n                });\n                return [2 /*return*/];\n            }\n          });\n        });\n      }, 'sync start');\n    });\n  };\n  SyncEngine.prototype.getModelsMetadataWithNextFullSync = function (currentTimeStamp) {\n    return __awaiter(this, void 0, void 0, function () {\n      var modelLastSync, _a;\n      var _this = this;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = Map.bind;\n            return [4 /*yield*/, this.runningProcesses.add(function () {\n              return _this.getModelsMetadata();\n            }, 'sync/index getModelsMetadataWithNextFullSync')];\n          case 1:\n            modelLastSync = new (_a.apply(Map, [void 0, _b.sent().map(function (_a) {\n              var namespace = _a.namespace,\n                model = _a.model,\n                lastSync = _a.lastSync,\n                lastFullSync = _a.lastFullSync,\n                fullSyncInterval = _a.fullSyncInterval,\n                lastSyncPredicate = _a.lastSyncPredicate;\n              var nextFullSync = lastFullSync + fullSyncInterval;\n              var syncFrom = !lastFullSync || nextFullSync < currentTimeStamp ? 0 // perform full sync if expired\n              : lastSync; // perform delta sync\n              return [_this.schema.namespaces[namespace].models[model], [namespace, syncFrom]];\n            })]))();\n            return [2 /*return*/, modelLastSync];\n        }\n      });\n    });\n  };\n  SyncEngine.prototype.syncQueriesObservable = function () {\n    var _this = this;\n    if (!this.online) {\n      return Observable.of();\n    }\n    return new Observable(function (observer) {\n      var syncQueriesSubscription;\n      _this.runningProcesses.isOpen && _this.runningProcesses.add(function (onTerminate) {\n        return __awaiter(_this, void 0, void 0, function () {\n          var terminated, _loop_1, this_1;\n          var _this = this;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                terminated = false;\n                _loop_1 = function () {\n                  var count, modelLastSync, paginatingModels, lastFullSyncStartedAt, syncInterval, start, syncDuration, lastStartedAt, msNextFullSync;\n                  return __generator(this, function (_a) {\n                    switch (_a.label) {\n                      case 0:\n                        count = new WeakMap();\n                        return [4 /*yield*/, this_1.getModelsMetadataWithNextFullSync(Date.now())];\n                      case 1:\n                        modelLastSync = _a.sent();\n                        paginatingModels = new Set(modelLastSync.keys());\n                        return [4 /*yield*/, new Promise(function (resolve, reject) {\n                          if (!_this.runningProcesses.isOpen) resolve();\n                          onTerminate.then(function () {\n                            return resolve();\n                          });\n                          syncQueriesSubscription = _this.syncQueriesProcessor.start(modelLastSync).subscribe({\n                            next: function (_a) {\n                              var namespace = _a.namespace,\n                                modelDefinition = _a.modelDefinition,\n                                items = _a.items,\n                                done = _a.done,\n                                startedAt = _a.startedAt,\n                                isFullSync = _a.isFullSync;\n                              return __awaiter(_this, void 0, void 0, function () {\n                                var modelConstructor, modelName, modelMetadata_1, lastFullSync, fullSyncInterval, counts;\n                                var _this = this;\n                                return __generator(this, function (_b) {\n                                  switch (_b.label) {\n                                    case 0:\n                                      modelConstructor = this.userModelClasses[modelDefinition.name];\n                                      if (!count.has(modelConstructor)) {\n                                        count.set(modelConstructor, {\n                                          new: 0,\n                                          updated: 0,\n                                          deleted: 0\n                                        });\n                                        start = getNow();\n                                        lastStartedAt = lastStartedAt === undefined ? startedAt : Math.max(lastStartedAt, startedAt);\n                                      }\n                                      /**\n                                       * If there are mutations in the outbox for a given id, those need to be\n                                       * merged individually. Otherwise, we can merge them in batches.\n                                       */\n                                      return [4 /*yield*/, this.storage.runExclusive(function (storage) {\n                                        return __awaiter(_this, void 0, void 0, function () {\n                                          var idsInOutbox, oneByOne, page, opTypeCount, oneByOne_1, oneByOne_1_1, item, opType, e_1_1, _a, _b, _c, counts;\n                                          var e_1, _d;\n                                          return __generator(this, function (_e) {\n                                            switch (_e.label) {\n                                              case 0:\n                                                return [4 /*yield*/, this.outbox.getModelIds(storage)];\n                                              case 1:\n                                                idsInOutbox = _e.sent();\n                                                oneByOne = [];\n                                                page = items.filter(function (item) {\n                                                  var itemId = getIdentifierValue(modelDefinition, item);\n                                                  if (!idsInOutbox.has(itemId)) {\n                                                    return true;\n                                                  }\n                                                  oneByOne.push(item);\n                                                  return false;\n                                                });\n                                                opTypeCount = [];\n                                                _e.label = 2;\n                                              case 2:\n                                                _e.trys.push([2, 7, 8, 9]);\n                                                oneByOne_1 = __values(oneByOne), oneByOne_1_1 = oneByOne_1.next();\n                                                _e.label = 3;\n                                              case 3:\n                                                if (!!oneByOne_1_1.done) return [3 /*break*/, 6];\n                                                item = oneByOne_1_1.value;\n                                                return [4 /*yield*/, this.modelMerger.merge(storage, item, modelDefinition)];\n                                              case 4:\n                                                opType = _e.sent();\n                                                if (opType !== undefined) {\n                                                  opTypeCount.push([item, opType]);\n                                                }\n                                                _e.label = 5;\n                                              case 5:\n                                                oneByOne_1_1 = oneByOne_1.next();\n                                                return [3 /*break*/, 3];\n                                              case 6:\n                                                return [3 /*break*/, 9];\n                                              case 7:\n                                                e_1_1 = _e.sent();\n                                                e_1 = {\n                                                  error: e_1_1\n                                                };\n                                                return [3 /*break*/, 9];\n                                              case 8:\n                                                try {\n                                                  if (oneByOne_1_1 && !oneByOne_1_1.done && (_d = oneByOne_1.return)) _d.call(oneByOne_1);\n                                                } finally {\n                                                  if (e_1) throw e_1.error;\n                                                }\n                                                return [7 /*endfinally*/];\n                                              case 9:\n                                                _b = (_a = opTypeCount.push).apply;\n                                                _c = [opTypeCount];\n                                                return [4 /*yield*/, this.modelMerger.mergePage(storage, modelConstructor, page, modelDefinition)];\n                                              case 10:\n                                                _b.apply(_a, _c.concat([__spread.apply(void 0, [_e.sent()])]));\n                                                counts = count.get(modelConstructor);\n                                                opTypeCount.forEach(function (_a) {\n                                                  var _b = __read(_a, 2),\n                                                    opType = _b[1];\n                                                  switch (opType) {\n                                                    case OpType.INSERT:\n                                                      counts.new++;\n                                                      break;\n                                                    case OpType.UPDATE:\n                                                      counts.updated++;\n                                                      break;\n                                                    case OpType.DELETE:\n                                                      counts.deleted++;\n                                                      break;\n                                                    default:\n                                                      throw new Error(\"Invalid opType \" + opType);\n                                                  }\n                                                });\n                                                return [2 /*return*/];\n                                            }\n                                          });\n                                        });\n                                      })];\n\n                                    case 1:\n                                      /**\n                                       * If there are mutations in the outbox for a given id, those need to be\n                                       * merged individually. Otherwise, we can merge them in batches.\n                                       */\n                                      _b.sent();\n                                      if (!done) return [3 /*break*/, 4];\n                                      modelName = modelDefinition.name;\n                                      return [4 /*yield*/, this.getModelMetadata(namespace, modelName)];\n                                    case 2:\n                                      modelMetadata_1 = _b.sent();\n                                      lastFullSync = modelMetadata_1.lastFullSync, fullSyncInterval = modelMetadata_1.fullSyncInterval;\n                                      syncInterval = fullSyncInterval;\n                                      lastFullSyncStartedAt = lastFullSyncStartedAt === undefined ? lastFullSync : Math.max(lastFullSyncStartedAt, isFullSync ? startedAt : lastFullSync);\n                                      modelMetadata_1 = this.modelClasses.ModelMetadata.copyOf(modelMetadata_1, function (draft) {\n                                        draft.lastSync = startedAt;\n                                        draft.lastFullSync = isFullSync ? startedAt : modelMetadata_1.lastFullSync;\n                                      });\n                                      return [4 /*yield*/, this.storage.save(modelMetadata_1, undefined, ownSymbol)];\n                                    case 3:\n                                      _b.sent();\n                                      counts = count.get(modelConstructor);\n                                      this.modelSyncedStatus.set(modelConstructor, true);\n                                      observer.next({\n                                        type: ControlMessage.SYNC_ENGINE_MODEL_SYNCED,\n                                        data: {\n                                          model: modelConstructor,\n                                          isFullSync: isFullSync,\n                                          isDeltaSync: !isFullSync,\n                                          counts: counts\n                                        }\n                                      });\n                                      paginatingModels.delete(modelDefinition);\n                                      if (paginatingModels.size === 0) {\n                                        syncDuration = getNow() - start;\n                                        resolve();\n                                        observer.next({\n                                          type: ControlMessage.SYNC_ENGINE_SYNC_QUERIES_READY\n                                        });\n                                        syncQueriesSubscription.unsubscribe();\n                                      }\n                                      _b.label = 4;\n                                    case 4:\n                                      return [2 /*return*/];\n                                  }\n                                });\n                              });\n                            },\n\n                            error: function (error) {\n                              observer.error(error);\n                            }\n                          });\n                          observer.next({\n                            type: ControlMessage.SYNC_ENGINE_SYNC_QUERIES_STARTED,\n                            data: {\n                              models: Array.from(paginatingModels).map(function (_a) {\n                                var name = _a.name;\n                                return name;\n                              })\n                            }\n                          });\n                        })];\n                      case 2:\n                        _a.sent();\n                        if (!lastFullSyncStartedAt) {\n                          msNextFullSync = syncInterval - syncDuration;\n                        } else {\n                          msNextFullSync = lastFullSyncStartedAt + syncInterval - (lastStartedAt + syncDuration);\n                        }\n                        logger.debug(\"Next fullSync in \" + msNextFullSync / 1000 + \" seconds. (\" + new Date(Date.now() + msNextFullSync) + \")\");\n                        // TODO: create `BackgroundProcessManager.sleep()` ... but, need to put\n                        // a lot of thought into what that contract looks like to\n                        //  support possible use-cases:\n                        //\n                        //  1. non-cancelable\n                        //  2. cancelable, unsleep on exit()\n                        //  3. cancelable, throw Error on exit()\n                        //  4. cancelable, callback first on exit()?\n                        //  5. ... etc. ? ...\n                        //\n                        // TLDR; this is a lot of complexity here for a sleep(),\n                        // but, it's not clear to me yet how to support an\n                        // extensible, centralized cancelable `sleep()` elegantly.\n                        return [4 /*yield*/, this_1.runningProcesses.add(function (onTerminate) {\n                          return __awaiter(_this, void 0, void 0, function () {\n                            var sleepTimer, unsleep, sleep;\n                            var _this = this;\n                            return __generator(this, function (_a) {\n                              sleep = new Promise(function (_unsleep) {\n                                unsleep = _unsleep;\n                                sleepTimer = setTimeout(unsleep, msNextFullSync);\n                              });\n                              onTerminate.then(function () {\n                                terminated = true;\n                                _this.syncQueriesObservableStartSleeping();\n                                unsleep();\n                              });\n                              this.unsleepSyncQueriesObservable = unsleep;\n                              this.syncQueriesObservableStartSleeping();\n                              return [2 /*return*/, sleep];\n                            });\n                          });\n                        }, 'syncQueriesObservable sleep')];\n                      case 3:\n                        // TODO: create `BackgroundProcessManager.sleep()` ... but, need to put\n                        // a lot of thought into what that contract looks like to\n                        //  support possible use-cases:\n                        //\n                        //  1. non-cancelable\n                        //  2. cancelable, unsleep on exit()\n                        //  3. cancelable, throw Error on exit()\n                        //  4. cancelable, callback first on exit()?\n                        //  5. ... etc. ? ...\n                        //\n                        // TLDR; this is a lot of complexity here for a sleep(),\n                        // but, it's not clear to me yet how to support an\n                        // extensible, centralized cancelable `sleep()` elegantly.\n                        _a.sent();\n                        this_1.unsleepSyncQueriesObservable = null;\n                        this_1.waitForSleepState = new Promise(function (resolve) {\n                          _this.syncQueriesObservableStartSleeping = resolve;\n                        });\n                        return [2 /*return*/];\n                    }\n                  });\n                };\n\n                this_1 = this;\n                _a.label = 1;\n              case 1:\n                if (!(!observer.closed && !terminated)) return [3 /*break*/, 3];\n                return [5 /*yield**/, _loop_1()];\n              case 2:\n                _a.sent();\n                return [3 /*break*/, 1];\n              case 3:\n                return [2 /*return*/];\n            }\n          });\n        });\n      }, 'syncQueriesObservable main');\n    });\n  };\n  SyncEngine.prototype.disconnectionHandler = function () {\n    var _this = this;\n    return function (msg) {\n      // This implementation is tied to AWSAppSyncRealTimeProvider 'Connection closed', 'Timeout disconnect' msg\n      if (PUBSUB_CONTROL_MSG.CONNECTION_CLOSED === msg || PUBSUB_CONTROL_MSG.TIMEOUT_DISCONNECT === msg) {\n        _this.datastoreConnectivity.socketDisconnected();\n      }\n    };\n  };\n  SyncEngine.prototype.unsubscribeConnectivity = function () {\n    this.datastoreConnectivity.unsubscribe();\n  };\n  /**\n   * Stops all subscription activities and resolves when all activies report\n   * that they're disconnected, done retrying, etc..\n   */\n  SyncEngine.prototype.stop = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            logger.debug('stopping sync engine');\n            /**\n             * Gracefully disconnecting subscribers first just prevents *more* work\n             * from entering the pipelines.\n             */\n            this.unsubscribeConnectivity();\n            /**\n             * Stop listening for websocket connection disruption\n             */\n            this.stopDisruptionListener && this.stopDisruptionListener();\n            /**\n             * aggressively shut down any lingering background processes.\n             * some of this might be semi-redundant with unsubscribing. however,\n             * unsubscribing doesn't allow us to wait for settling.\n             * (Whereas `stop()` does.)\n             */\n            return [4 /*yield*/, this.mutationsProcessor.stop()];\n          case 1:\n            /**\n             * aggressively shut down any lingering background processes.\n             * some of this might be semi-redundant with unsubscribing. however,\n             * unsubscribing doesn't allow us to wait for settling.\n             * (Whereas `stop()` does.)\n             */\n            _a.sent();\n            return [4 /*yield*/, this.subscriptionsProcessor.stop()];\n          case 2:\n            _a.sent();\n            return [4 /*yield*/, this.datastoreConnectivity.stop()];\n          case 3:\n            _a.sent();\n            return [4 /*yield*/, this.syncQueriesProcessor.stop()];\n          case 4:\n            _a.sent();\n            return [4 /*yield*/, this.runningProcesses.close()];\n          case 5:\n            _a.sent();\n            return [4 /*yield*/, this.runningProcesses.open()];\n          case 6:\n            _a.sent();\n            logger.debug('sync engine stopped and ready to restart');\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  SyncEngine.prototype.setupModels = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var fullSyncInterval, ModelMetadataConstructor, models, savedModel, promises, result, _a, _b, modelMetadata, modelName, e_2_1;\n      var e_2, _c;\n      var _this = this;\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            fullSyncInterval = params.fullSyncInterval;\n            ModelMetadataConstructor = this.modelClasses.ModelMetadata;\n            models = [];\n            Object.values(this.schema.namespaces).forEach(function (namespace) {\n              Object.values(namespace.models).filter(function (_a) {\n                var syncable = _a.syncable;\n                return syncable;\n              }).forEach(function (model) {\n                models.push([namespace.name, model]);\n                if (namespace.name === USER) {\n                  var modelConstructor = _this.userModelClasses[model.name];\n                  _this.modelSyncedStatus.set(modelConstructor, false);\n                }\n              });\n            });\n            promises = models.map(function (_a) {\n              var _b = __read(_a, 2),\n                namespace = _b[0],\n                model = _b[1];\n              return __awaiter(_this, void 0, void 0, function () {\n                var modelMetadata, syncPredicate, lastSyncPredicate, prevSyncPredicate, syncPredicateUpdated_1;\n                var _c, _d, _e, _f;\n                return __generator(this, function (_g) {\n                  switch (_g.label) {\n                    case 0:\n                      return [4 /*yield*/, this.getModelMetadata(namespace, model.name)];\n                    case 1:\n                      modelMetadata = _g.sent();\n                      syncPredicate = ModelPredicateCreator.getPredicates(this.syncPredicates.get(model), false);\n                      lastSyncPredicate = syncPredicate ? JSON.stringify(syncPredicate) : null;\n                      if (!(modelMetadata === undefined)) return [3 /*break*/, 3];\n                      return [4 /*yield*/, this.storage.save(this.modelInstanceCreator(ModelMetadataConstructor, {\n                        model: model.name,\n                        namespace: namespace,\n                        lastSync: null,\n                        fullSyncInterval: fullSyncInterval,\n                        lastFullSync: null,\n                        lastSyncPredicate: lastSyncPredicate\n                      }), undefined, ownSymbol)];\n                    case 2:\n                      _c = __read.apply(void 0, [_g.sent(), 1]), _d = __read(_c[0], 1), savedModel = _d[0];\n                      return [3 /*break*/, 5];\n                    case 3:\n                      prevSyncPredicate = modelMetadata.lastSyncPredicate ? modelMetadata.lastSyncPredicate : null;\n                      syncPredicateUpdated_1 = prevSyncPredicate !== lastSyncPredicate;\n                      return [4 /*yield*/, this.storage.save(ModelMetadataConstructor.copyOf(modelMetadata, function (draft) {\n                        draft.fullSyncInterval = fullSyncInterval;\n                        // perform a base sync if the syncPredicate changed in between calls to DataStore.start\n                        // ensures that the local store contains all the data specified by the syncExpression\n                        if (syncPredicateUpdated_1) {\n                          draft.lastSync = null;\n                          draft.lastFullSync = null;\n                          draft.lastSyncPredicate = lastSyncPredicate;\n                        }\n                      }))];\n                    case 4:\n                      _e = __read.apply(void 0, [_g.sent(), 1]), _f = __read(_e[0], 1), savedModel = _f[0];\n                      _g.label = 5;\n                    case 5:\n                      return [2 /*return*/, savedModel];\n                  }\n                });\n              });\n            });\n            result = {};\n            _d.label = 1;\n          case 1:\n            _d.trys.push([1, 6, 7, 8]);\n            return [4 /*yield*/, Promise.all(promises)];\n          case 2:\n            _a = __values.apply(void 0, [_d.sent()]), _b = _a.next();\n            _d.label = 3;\n          case 3:\n            if (!!_b.done) return [3 /*break*/, 5];\n            modelMetadata = _b.value;\n            modelName = modelMetadata.model;\n            result[modelName] = modelMetadata;\n            _d.label = 4;\n          case 4:\n            _b = _a.next();\n            return [3 /*break*/, 3];\n          case 5:\n            return [3 /*break*/, 8];\n          case 6:\n            e_2_1 = _d.sent();\n            e_2 = {\n              error: e_2_1\n            };\n            return [3 /*break*/, 8];\n          case 7:\n            try {\n              if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n            return [7 /*endfinally*/];\n          case 8:\n            return [2 /*return*/, result];\n        }\n      });\n    });\n  };\n  SyncEngine.prototype.getModelsMetadata = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var ModelMetadata, modelsMetadata;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            ModelMetadata = this.modelClasses.ModelMetadata;\n            return [4 /*yield*/, this.storage.query(ModelMetadata)];\n          case 1:\n            modelsMetadata = _a.sent();\n            return [2 /*return*/, modelsMetadata];\n        }\n      });\n    });\n  };\n  SyncEngine.prototype.getModelMetadata = function (namespace, model) {\n    return __awaiter(this, void 0, void 0, function () {\n      var ModelMetadata, predicate, _a, modelMetadata;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            ModelMetadata = this.modelClasses.ModelMetadata;\n            predicate = ModelPredicateCreator.createFromAST(this.schema.namespaces[SYNC].models[ModelMetadata.name], {\n              and: [{\n                namespace: {\n                  eq: namespace\n                }\n              }, {\n                model: {\n                  eq: model\n                }\n              }]\n            });\n            return [4 /*yield*/, this.storage.query(ModelMetadata, predicate, {\n              page: 0,\n              limit: 1\n            })];\n          case 1:\n            _a = __read.apply(void 0, [_b.sent(), 1]), modelMetadata = _a[0];\n            return [2 /*return*/, modelMetadata];\n        }\n      });\n    });\n  };\n  SyncEngine.prototype.getModelDefinition = function (modelConstructor) {\n    var namespaceName = this.namespaceResolver(modelConstructor);\n    var modelDefinition = this.schema.namespaces[namespaceName].models[modelConstructor.name];\n    return modelDefinition;\n  };\n  SyncEngine.getNamespace = function () {\n    var namespace = {\n      name: SYNC,\n      relationships: {},\n      enums: {\n        OperationType: {\n          name: 'OperationType',\n          values: ['CREATE', 'UPDATE', 'DELETE']\n        }\n      },\n      nonModels: {},\n      models: {\n        MutationEvent: {\n          name: 'MutationEvent',\n          pluralName: 'MutationEvents',\n          syncable: false,\n          fields: {\n            id: {\n              name: 'id',\n              type: 'ID',\n              isRequired: true,\n              isArray: false\n            },\n            model: {\n              name: 'model',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            data: {\n              name: 'data',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            modelId: {\n              name: 'modelId',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            operation: {\n              name: 'operation',\n              type: {\n                enum: 'Operationtype'\n              },\n              isArray: false,\n              isRequired: true\n            },\n            condition: {\n              name: 'condition',\n              type: 'String',\n              isArray: false,\n              isRequired: true\n            }\n          }\n        },\n        ModelMetadata: {\n          name: 'ModelMetadata',\n          pluralName: 'ModelsMetadata',\n          syncable: false,\n          fields: {\n            id: {\n              name: 'id',\n              type: 'ID',\n              isRequired: true,\n              isArray: false\n            },\n            namespace: {\n              name: 'namespace',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            model: {\n              name: 'model',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            lastSync: {\n              name: 'lastSync',\n              type: 'Int',\n              isRequired: false,\n              isArray: false\n            },\n            lastFullSync: {\n              name: 'lastFullSync',\n              type: 'Int',\n              isRequired: false,\n              isArray: false\n            },\n            fullSyncInterval: {\n              name: 'fullSyncInterval',\n              type: 'Int',\n              isRequired: true,\n              isArray: false\n            },\n            lastSyncPredicate: {\n              name: 'lastSyncPredicate',\n              type: 'String',\n              isRequired: false,\n              isArray: false\n            }\n          }\n        }\n      }\n    };\n    return namespace;\n  };\n  /**\n   * listen for websocket connection disruption\n   *\n   * May indicate there was a period of time where messages\n   * from AppSync were missed. A sync needs to be triggered to\n   * retrieve the missed data.\n   */\n  SyncEngine.prototype.startDisruptionListener = function () {\n    var _this = this;\n    return Hub.listen('api', function (data) {\n      if (data.source === 'PubSub' && data.payload.event === PUBSUB_CONNECTION_STATE_CHANGE) {\n        var connectionState = data.payload.data.connectionState;\n        switch (connectionState) {\n          // Do not need to listen for ConnectionDisruptedPendingNetwork\n          // Normal network reconnection logic will handle the sync\n          case ConnectionState.ConnectionDisrupted:\n            _this.connectionDisrupted = true;\n            break;\n          case ConnectionState.Connected:\n            if (_this.connectionDisrupted) {\n              _this.scheduleSync();\n            }\n            _this.connectionDisrupted = false;\n            break;\n        }\n      }\n    });\n  };\n  /*\n   * Schedule a sync to start when syncQueriesObservable enters sleep state\n   * Start sync immediately if syncQueriesObservable is already in sleep state\n   */\n  SyncEngine.prototype.scheduleSync = function () {\n    var _this = this;\n    return this.runningProcesses.isOpen && this.runningProcesses.add(function () {\n      return _this.waitForSleepState.then(function () {\n        // unsleepSyncQueriesObservable will be set if waitForSleepState has resolved\n        _this.unsleepSyncQueriesObservable();\n      });\n    });\n  };\n  return SyncEngine;\n}();\nexport { SyncEngine };","map":{"version":3,"names":["browserOrNode","ConsoleLogger","Logger","BackgroundProcessManager","Hub","CONTROL_MSG","PUBSUB_CONTROL_MSG","CONNECTION_STATE_CHANGE","PUBSUB_CONNECTION_STATE_CHANGE","ConnectionState","Observable","ModelPredicateCreator","OpType","getNow","SYNC","USER","DataStoreConnectivity","ModelMerger","MutationEventOutbox","MutationProcessor","SubscriptionProcessor","SyncProcessor","createMutationInstanceFromModelOperation","getIdentifierValue","predicateToGraphQLCondition","isNode","logger","ownSymbol","Symbol","ControlMessage","SyncEngine","schema","namespaceResolver","modelClasses","userModelClasses","storage","modelInstanceCreator","conflictHandler","errorHandler","syncPredicates","amplifyConfig","authModeStrategy","amplifyContext","connectivityMonitor","_this","online","modelSyncedStatus","WeakMap","connectionDisrupted","runningProcesses","waitForSleepState","Promise","resolve","syncQueriesObservableStartSleeping","MutationEvent","outbox","modelMerger","syncQueriesProcessor","subscriptionsProcessor","mutationsProcessor","datastoreConnectivity","prototype","getModelSyncedStatus","modelConstructor","get","start","params","observer","log","subscriptions","add","__awaiter","setupModels","_a","sent","error","err_1","startPromise","doneStarting","failedStarting","status","subscribe","isOpen","onTerminate","next","type","SYNC_ENGINE_NETWORK_STATUS","data","active","dataSubsObservable","warn","stopDisruptionListener","startDisruptionListener","__read","ctlSubsObservable_1","reject","then","ctlSubsSubscription","msg","CONNECTED","err","handleDisconnect","disconnectionHandler","push","_b","err_2","SYNC_ENGINE_SUBSCRIPTIONS_ESTABLISHED","syncQuerySubscription","syncQueriesObservable","message","SYNC_ENGINE_SYNC_QUERIES_READY","complete","error_1","modelDefinition","item","model","hasMore","name","runExclusive","merge","SYNC_ENGINE_OUTBOX_MUTATION_PROCESSED","element","SYNC_ENGINE_OUTBOX_STATUS","isEmpty","_transformerMutationType","forEach","sub","unsubscribe","observe","filter","getModelDefinition","syncable","opType","condition","namespace","namespaces","MutationEventConstructor","graphQLCondition","mutationEvent","relationships","enqueue","SYNC_ENGINE_OUTBOX_MUTATION_ENQUEUED","resume","SYNC_ENGINE_STORAGE_SUBSCRIBED","peek","hasMutationsInOutbox","undefined","SYNC_ENGINE_READY","getModelsMetadataWithNextFullSync","currentTimeStamp","Map","bind","getModelsMetadata","modelLastSync","apply","map","lastSync","lastFullSync","fullSyncInterval","lastSyncPredicate","nextFullSync","syncFrom","models","of","syncQueriesSubscription","terminated","count","this_1","Date","now","paginatingModels","Set","keys","items","done","startedAt","isFullSync","has","set","new","updated","deleted","lastStartedAt","Math","max","getModelIds","idsInOutbox","_e","oneByOne","page","itemId","opTypeCount","oneByOne_1","__values","oneByOne_1_1","value","mergePage","_c","concat","__spread","counts","INSERT","UPDATE","DELETE","Error","modelName","getModelMetadata","modelMetadata_1","syncInterval","lastFullSyncStartedAt","ModelMetadata","copyOf","draft","save","SYNC_ENGINE_MODEL_SYNCED","isDeltaSync","delete","size","syncDuration","SYNC_ENGINE_SYNC_QUERIES_STARTED","Array","from","msNextFullSync","debug","sleep","_unsleep","unsleep","sleepTimer","setTimeout","unsleepSyncQueriesObservable","closed","CONNECTION_CLOSED","TIMEOUT_DISCONNECT","socketDisconnected","unsubscribeConnectivity","stop","close","open","ModelMetadataConstructor","Object","values","promises","modelMetadata","_g","syncPredicate","getPredicates","JSON","stringify","_d","savedModel","prevSyncPredicate","syncPredicateUpdated_1","_f","result","all","query","modelsMetadata","predicate","createFromAST","and","eq","limit","namespaceName","getNamespace","enums","OperationType","nonModels","pluralName","fields","id","isRequired","isArray","modelId","operation","enum","listen","source","payload","event","connectionState","ConnectionDisrupted","Connected","scheduleSync"],"sources":["/Users/yannellym/Desktop/iwantapet/node_modules/@aws-amplify/datastore/src/sync/index.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport {\n\tbrowserOrNode,\n\tConsoleLogger as Logger,\n\tBackgroundProcessManager,\n\tHub,\n} from '@aws-amplify/core';\nimport {\n\tCONTROL_MSG as PUBSUB_CONTROL_MSG,\n\tCONNECTION_STATE_CHANGE as PUBSUB_CONNECTION_STATE_CHANGE,\n\tConnectionState,\n} from '@aws-amplify/pubsub';\nimport Observable, { ZenObservable } from 'zen-observable-ts';\nimport { ModelInstanceCreator } from '../datastore/datastore';\nimport { ModelPredicateCreator } from '../predicates';\nimport { ExclusiveStorage as Storage } from '../storage/storage';\nimport {\n\tConflictHandler,\n\tControlMessageType,\n\tErrorHandler,\n\tInternalSchema,\n\tModelInit,\n\tModelInstanceMetadata,\n\tMutableModel,\n\tNamespaceResolver,\n\tOpType,\n\tPersistentModel,\n\tPersistentModelConstructor,\n\tSchemaModel,\n\tSchemaNamespace,\n\tTypeConstructorMap,\n\tModelPredicate,\n\tAuthModeStrategy,\n\tManagedIdentifier,\n\tOptionallyManagedIdentifier,\n\tAmplifyContext,\n} from '../types';\n// tslint:disable:no-duplicate-imports\nimport type { __modelMeta__ } from '../types';\n\nimport { getNow, SYNC, USER } from '../util';\nimport DataStoreConnectivity from './datastoreConnectivity';\nimport { ModelMerger } from './merger';\nimport { MutationEventOutbox } from './outbox';\nimport { MutationProcessor } from './processors/mutation';\nimport { CONTROL_MSG, SubscriptionProcessor } from './processors/subscription';\nimport { SyncProcessor } from './processors/sync';\nimport {\n\tcreateMutationInstanceFromModelOperation,\n\tgetIdentifierValue,\n\tpredicateToGraphQLCondition,\n\tTransformerMutationType,\n} from './utils';\n\nconst { isNode } = browserOrNode();\nconst logger = new Logger('DataStore');\n\nconst ownSymbol = Symbol('sync');\n\ntype StartParams = {\n\tfullSyncInterval: number;\n};\n\nexport declare class MutationEvent {\n\treadonly [__modelMeta__]: {\n\t\tidentifier: OptionallyManagedIdentifier<MutationEvent, 'id'>;\n\t};\n\tpublic readonly id: string;\n\tpublic readonly model: string;\n\tpublic readonly operation: TransformerMutationType;\n\tpublic readonly modelId: string;\n\tpublic readonly condition: string;\n\tpublic readonly data: string;\n\tconstructor(init: ModelInit<MutationEvent>);\n\tstatic copyOf(\n\t\tsrc: MutationEvent,\n\t\tmutator: (draft: MutableModel<MutationEvent>) => void | MutationEvent\n\t): MutationEvent;\n}\n\nexport declare class ModelMetadata {\n\treadonly [__modelMeta__]: {\n\t\tidentifier: ManagedIdentifier<ModelMetadata, 'id'>;\n\t};\n\tpublic readonly id: string;\n\tpublic readonly namespace: string;\n\tpublic readonly model: string;\n\tpublic readonly fullSyncInterval: number;\n\tpublic readonly lastSync?: number;\n\tpublic readonly lastFullSync?: number;\n\tpublic readonly lastSyncPredicate?: null | string;\n\tconstructor(init: ModelInit<ModelMetadata>);\n\tstatic copyOf(\n\t\tsrc: ModelMetadata,\n\t\tmutator: (draft: MutableModel<ModelMetadata>) => void | ModelMetadata\n\t): ModelMetadata;\n}\n\nexport enum ControlMessage {\n\tSYNC_ENGINE_STORAGE_SUBSCRIBED = 'storageSubscribed',\n\tSYNC_ENGINE_SUBSCRIPTIONS_ESTABLISHED = 'subscriptionsEstablished',\n\tSYNC_ENGINE_SYNC_QUERIES_STARTED = 'syncQueriesStarted',\n\tSYNC_ENGINE_SYNC_QUERIES_READY = 'syncQueriesReady',\n\tSYNC_ENGINE_MODEL_SYNCED = 'modelSynced',\n\tSYNC_ENGINE_OUTBOX_MUTATION_ENQUEUED = 'outboxMutationEnqueued',\n\tSYNC_ENGINE_OUTBOX_MUTATION_PROCESSED = 'outboxMutationProcessed',\n\tSYNC_ENGINE_OUTBOX_STATUS = 'outboxStatus',\n\tSYNC_ENGINE_NETWORK_STATUS = 'networkStatus',\n\tSYNC_ENGINE_READY = 'ready',\n}\n\nexport class SyncEngine {\n\tprivate online = false;\n\n\tprivate readonly syncQueriesProcessor: SyncProcessor;\n\tprivate readonly subscriptionsProcessor: SubscriptionProcessor;\n\tprivate readonly mutationsProcessor: MutationProcessor;\n\tprivate readonly modelMerger: ModelMerger;\n\tprivate readonly outbox: MutationEventOutbox;\n\tprivate readonly datastoreConnectivity: DataStoreConnectivity;\n\tprivate readonly modelSyncedStatus: WeakMap<\n\t\tPersistentModelConstructor<any>,\n\t\tboolean\n\t> = new WeakMap();\n\tprivate unsleepSyncQueriesObservable: (() => void) | null;\n\tprivate waitForSleepState: Promise<void>;\n\tprivate syncQueriesObservableStartSleeping: (\n\t\tvalue?: void | PromiseLike<void>\n\t) => void;\n\tprivate stopDisruptionListener: () => void;\n\tprivate connectionDisrupted = false;\n\n\tprivate runningProcesses: BackgroundProcessManager;\n\n\tpublic getModelSyncedStatus(\n\t\tmodelConstructor: PersistentModelConstructor<any>\n\t): boolean {\n\t\treturn this.modelSyncedStatus.get(modelConstructor)!;\n\t}\n\n\tconstructor(\n\t\tprivate readonly schema: InternalSchema,\n\t\tprivate readonly namespaceResolver: NamespaceResolver,\n\t\tprivate readonly modelClasses: TypeConstructorMap,\n\t\tprivate readonly userModelClasses: TypeConstructorMap,\n\t\tprivate readonly storage: Storage,\n\t\tprivate readonly modelInstanceCreator: ModelInstanceCreator,\n\t\tconflictHandler: ConflictHandler,\n\t\terrorHandler: ErrorHandler,\n\t\tprivate readonly syncPredicates: WeakMap<\n\t\t\tSchemaModel,\n\t\t\tModelPredicate<any> | null\n\t\t>,\n\t\tprivate readonly amplifyConfig: Record<string, any> = {},\n\t\tprivate readonly authModeStrategy: AuthModeStrategy,\n\t\tprivate readonly amplifyContext: AmplifyContext,\n\t\tprivate readonly connectivityMonitor?: DataStoreConnectivity\n\t) {\n\t\tthis.runningProcesses = new BackgroundProcessManager();\n\t\tthis.waitForSleepState = new Promise(resolve => {\n\t\t\tthis.syncQueriesObservableStartSleeping = resolve;\n\t\t});\n\n\t\tconst MutationEvent = this.modelClasses[\n\t\t\t'MutationEvent'\n\t\t] as PersistentModelConstructor<MutationEvent>;\n\n\t\tthis.outbox = new MutationEventOutbox(\n\t\t\tthis.schema,\n\t\t\tMutationEvent,\n\t\t\tmodelInstanceCreator,\n\t\t\townSymbol\n\t\t);\n\n\t\tthis.modelMerger = new ModelMerger(this.outbox, ownSymbol);\n\n\t\tthis.syncQueriesProcessor = new SyncProcessor(\n\t\t\tthis.schema,\n\t\t\tthis.syncPredicates,\n\t\t\tthis.amplifyConfig,\n\t\t\tthis.authModeStrategy,\n\t\t\terrorHandler,\n\t\t\tthis.amplifyContext\n\t\t);\n\n\t\tthis.subscriptionsProcessor = new SubscriptionProcessor(\n\t\t\tthis.schema,\n\t\t\tthis.syncPredicates,\n\t\t\tthis.amplifyConfig,\n\t\t\tthis.authModeStrategy,\n\t\t\terrorHandler,\n\t\t\tthis.amplifyContext\n\t\t);\n\n\t\tthis.mutationsProcessor = new MutationProcessor(\n\t\t\tthis.schema,\n\t\t\tthis.storage,\n\t\t\tthis.userModelClasses,\n\t\t\tthis.outbox,\n\t\t\tthis.modelInstanceCreator,\n\t\t\tMutationEvent,\n\t\t\tthis.amplifyConfig,\n\t\t\tthis.authModeStrategy,\n\t\t\terrorHandler,\n\t\t\tconflictHandler,\n\t\t\tthis.amplifyContext\n\t\t);\n\n\t\tthis.datastoreConnectivity =\n\t\t\tthis.connectivityMonitor || new DataStoreConnectivity();\n\t}\n\n\tstart(params: StartParams) {\n\t\treturn new Observable<ControlMessageType<ControlMessage>>(observer => {\n\t\t\tlogger.log('starting sync engine...');\n\n\t\t\tlet subscriptions: ZenObservable.Subscription[] = [];\n\n\t\t\tthis.runningProcesses.add(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tawait this.setupModels(params);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tobserver.error(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// this is awaited at the bottom. so, we don't need to register\n\t\t\t\t// this explicitly with the context. it's already contained.\n\t\t\t\tconst startPromise = new Promise<void>(\n\t\t\t\t\t(doneStarting, failedStarting) => {\n\t\t\t\t\t\tthis.datastoreConnectivity.status().subscribe(\n\t\t\t\t\t\t\tasync ({ online }) =>\n\t\t\t\t\t\t\t\tthis.runningProcesses.isOpen &&\n\t\t\t\t\t\t\t\tthis.runningProcesses.add(async onTerminate => {\n\t\t\t\t\t\t\t\t\t// From offline to online\n\t\t\t\t\t\t\t\t\tif (online && !this.online) {\n\t\t\t\t\t\t\t\t\t\tthis.online = online;\n\n\t\t\t\t\t\t\t\t\t\tobserver.next({\n\t\t\t\t\t\t\t\t\t\t\ttype: ControlMessage.SYNC_ENGINE_NETWORK_STATUS,\n\t\t\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\t\t\tactive: this.online,\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\tlet ctlSubsObservable: Observable<CONTROL_MSG>;\n\t\t\t\t\t\t\t\t\t\tlet dataSubsObservable: Observable<\n\t\t\t\t\t\t\t\t\t\t\t[TransformerMutationType, SchemaModel, PersistentModel]\n\t\t\t\t\t\t\t\t\t\t>;\n\n\t\t\t\t\t\t\t\t\t\t// NOTE: need a way to override this conditional for testing.\n\t\t\t\t\t\t\t\t\t\tif (isNode) {\n\t\t\t\t\t\t\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\t\t\t\t\t\t'Realtime disabled when in a server-side environment'\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tthis.stopDisruptionListener =\n\t\t\t\t\t\t\t\t\t\t\t\tthis.startDisruptionListener();\n\t\t\t\t\t\t\t\t\t\t\t//#region GraphQL Subscriptions\n\t\t\t\t\t\t\t\t\t\t\t[ctlSubsObservable, dataSubsObservable] =\n\t\t\t\t\t\t\t\t\t\t\t\tthis.subscriptionsProcessor.start();\n\n\t\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\t\tawait new Promise<void>((resolve, reject) => {\n\t\t\t\t\t\t\t\t\t\t\t\t\tonTerminate.then(reject);\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst ctlSubsSubscription =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tctlSubsObservable.subscribe({\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnext: msg => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (msg === CONTROL_MSG.CONNECTED) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\terror: err => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst handleDisconnect =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.disconnectionHandler();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thandleDisconnect(err);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tsubscriptions.push(ctlSubsSubscription);\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\t\t\t\tobserver.error(err);\n\t\t\t\t\t\t\t\t\t\t\t\tfailedStarting();\n\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tlogger.log('Realtime ready');\n\n\t\t\t\t\t\t\t\t\t\t\tobserver.next({\n\t\t\t\t\t\t\t\t\t\t\t\ttype: ControlMessage.SYNC_ENGINE_SUBSCRIPTIONS_ESTABLISHED,\n\t\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\t\t//#endregion\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t//#region Base & Sync queries\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tawait new Promise<void>((resolve, reject) => {\n\t\t\t\t\t\t\t\t\t\t\t\tconst syncQuerySubscription =\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.syncQueriesObservable().subscribe({\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnext: message => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst { type } = message;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype ===\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tControlMessage.SYNC_ENGINE_SYNC_QUERIES_READY\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tobserver.next(message);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcomplete: () => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\terror: error => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (syncQuerySubscription) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tsubscriptions.push(syncQuerySubscription);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\t\t\t\tobserver.error(error);\n\t\t\t\t\t\t\t\t\t\t\tfailedStarting();\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t//#endregion\n\n\t\t\t\t\t\t\t\t\t\t//#region process mutations (outbox)\n\t\t\t\t\t\t\t\t\t\tsubscriptions.push(\n\t\t\t\t\t\t\t\t\t\t\tthis.mutationsProcessor\n\t\t\t\t\t\t\t\t\t\t\t\t.start()\n\t\t\t\t\t\t\t\t\t\t\t\t.subscribe(\n\t\t\t\t\t\t\t\t\t\t\t\t\t({ modelDefinition, model: item, hasMore }) =>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.runningProcesses.add(async () => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst modelConstructor = this.userModelClasses[\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodelDefinition.name\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t] as PersistentModelConstructor<any>;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst model = this.modelInstanceCreator(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\titem\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tawait this.storage.runExclusive(storage =>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.modelMerger.merge(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstorage,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodelDefinition\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tobserver.next({\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: ControlMessage.SYNC_ENGINE_OUTBOX_MUTATION_PROCESSED,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel: modelConstructor,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telement: model,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tobserver.next({\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tisEmpty: !hasMore,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}, 'mutation processor event')\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t//#endregion\n\n\t\t\t\t\t\t\t\t\t\t//#region Merge subscriptions buffer\n\t\t\t\t\t\t\t\t\t\t// TODO: extract to function\n\t\t\t\t\t\t\t\t\t\tif (!isNode) {\n\t\t\t\t\t\t\t\t\t\t\tsubscriptions.push(\n\t\t\t\t\t\t\t\t\t\t\t\tdataSubsObservable!.subscribe(\n\t\t\t\t\t\t\t\t\t\t\t\t\t([_transformerMutationType, modelDefinition, item]) =>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.runningProcesses.add(async () => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst modelConstructor = this.userModelClasses[\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodelDefinition.name\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t] as PersistentModelConstructor<any>;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst model = this.modelInstanceCreator(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\titem\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tawait this.storage.runExclusive(storage =>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.modelMerger.merge(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstorage,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodelDefinition\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}, 'subscription dataSubsObservable event')\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t//#endregion\n\t\t\t\t\t\t\t\t\t} else if (!online) {\n\t\t\t\t\t\t\t\t\t\tthis.online = online;\n\n\t\t\t\t\t\t\t\t\t\tobserver.next({\n\t\t\t\t\t\t\t\t\t\t\ttype: ControlMessage.SYNC_ENGINE_NETWORK_STATUS,\n\t\t\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\t\t\tactive: this.online,\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\tsubscriptions.forEach(sub => sub.unsubscribe());\n\t\t\t\t\t\t\t\t\t\tsubscriptions = [];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tdoneStarting();\n\t\t\t\t\t\t\t\t}, 'datastore connectivity event')\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tthis.storage\n\t\t\t\t\t.observe(null, null, ownSymbol)\n\t\t\t\t\t.filter(({ model }) => {\n\t\t\t\t\t\tconst modelDefinition = this.getModelDefinition(model);\n\t\t\t\t\t\treturn modelDefinition.syncable === true;\n\t\t\t\t\t})\n\t\t\t\t\t.subscribe({\n\t\t\t\t\t\tnext: async ({ opType, model, element, condition }) =>\n\t\t\t\t\t\t\tthis.runningProcesses.add(async () => {\n\t\t\t\t\t\t\t\tconst namespace =\n\t\t\t\t\t\t\t\t\tthis.schema.namespaces[this.namespaceResolver(model)];\n\t\t\t\t\t\t\t\tconst MutationEventConstructor = this.modelClasses[\n\t\t\t\t\t\t\t\t\t'MutationEvent'\n\t\t\t\t\t\t\t\t] as PersistentModelConstructor<MutationEvent>;\n\t\t\t\t\t\t\t\tconst modelDefinition = this.getModelDefinition(model);\n\t\t\t\t\t\t\t\tconst graphQLCondition = predicateToGraphQLCondition(\n\t\t\t\t\t\t\t\t\tcondition!,\n\t\t\t\t\t\t\t\t\tmodelDefinition\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tconst mutationEvent = createMutationInstanceFromModelOperation(\n\t\t\t\t\t\t\t\t\tnamespace.relationships!,\n\t\t\t\t\t\t\t\t\tthis.getModelDefinition(model),\n\t\t\t\t\t\t\t\t\topType,\n\t\t\t\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t\t\t\telement,\n\t\t\t\t\t\t\t\t\tgraphQLCondition,\n\t\t\t\t\t\t\t\t\tMutationEventConstructor,\n\t\t\t\t\t\t\t\t\tthis.modelInstanceCreator\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tawait this.outbox.enqueue(this.storage, mutationEvent);\n\n\t\t\t\t\t\t\t\tobserver.next({\n\t\t\t\t\t\t\t\t\ttype: ControlMessage.SYNC_ENGINE_OUTBOX_MUTATION_ENQUEUED,\n\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t\t\t\t\telement,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\tobserver.next({\n\t\t\t\t\t\t\t\t\ttype: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\tisEmpty: false,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\tawait startPromise;\n\n\t\t\t\t\t\t\t\t// Set by the this.datastoreConnectivity.status().subscribe() loop\n\t\t\t\t\t\t\t\tif (this.online) {\n\t\t\t\t\t\t\t\t\tthis.mutationsProcessor.resume();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}, 'storage event'),\n\t\t\t\t\t});\n\n\t\t\t\tobserver.next({\n\t\t\t\t\ttype: ControlMessage.SYNC_ENGINE_STORAGE_SUBSCRIBED,\n\t\t\t\t});\n\n\t\t\t\tconst hasMutationsInOutbox =\n\t\t\t\t\t(await this.outbox.peek(this.storage)) === undefined;\n\t\t\t\tobserver.next({\n\t\t\t\t\ttype: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tisEmpty: hasMutationsInOutbox,\n\t\t\t\t\t},\n\t\t\t\t});\n\n\t\t\t\tawait startPromise;\n\n\t\t\t\tobserver.next({\n\t\t\t\t\ttype: ControlMessage.SYNC_ENGINE_READY,\n\t\t\t\t});\n\t\t\t}, 'sync start');\n\t\t});\n\t}\n\n\tprivate async getModelsMetadataWithNextFullSync(\n\t\tcurrentTimeStamp: number\n\t): Promise<Map<SchemaModel, [string, number]>> {\n\t\tconst modelLastSync: Map<SchemaModel, [string, number]> = new Map(\n\t\t\t(\n\t\t\t\tawait this.runningProcesses.add(\n\t\t\t\t\t() => this.getModelsMetadata(),\n\t\t\t\t\t'sync/index getModelsMetadataWithNextFullSync'\n\t\t\t\t)\n\t\t\t).map(\n\t\t\t\t({\n\t\t\t\t\tnamespace,\n\t\t\t\t\tmodel,\n\t\t\t\t\tlastSync,\n\t\t\t\t\tlastFullSync,\n\t\t\t\t\tfullSyncInterval,\n\t\t\t\t\tlastSyncPredicate,\n\t\t\t\t}) => {\n\t\t\t\t\tconst nextFullSync = lastFullSync! + fullSyncInterval;\n\t\t\t\t\tconst syncFrom =\n\t\t\t\t\t\t!lastFullSync || nextFullSync < currentTimeStamp\n\t\t\t\t\t\t\t? 0 // perform full sync if expired\n\t\t\t\t\t\t\t: lastSync; // perform delta sync\n\n\t\t\t\t\treturn [\n\t\t\t\t\t\tthis.schema.namespaces[namespace].models[model],\n\t\t\t\t\t\t[namespace, syncFrom!],\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t)\n\t\t);\n\n\t\treturn modelLastSync;\n\t}\n\n\tprivate syncQueriesObservable(): Observable<\n\t\tControlMessageType<ControlMessage>\n\t> {\n\t\tif (!this.online) {\n\t\t\treturn Observable.of<ControlMessageType<ControlMessage>>();\n\t\t}\n\n\t\treturn new Observable<ControlMessageType<ControlMessage>>(observer => {\n\t\t\tlet syncQueriesSubscription: ZenObservable.Subscription;\n\n\t\t\tthis.runningProcesses.isOpen &&\n\t\t\t\tthis.runningProcesses.add(async onTerminate => {\n\t\t\t\t\tlet terminated = false;\n\n\t\t\t\t\twhile (!observer.closed && !terminated) {\n\t\t\t\t\t\tconst count: WeakMap<\n\t\t\t\t\t\t\tPersistentModelConstructor<any>,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnew: number;\n\t\t\t\t\t\t\t\tupdated: number;\n\t\t\t\t\t\t\t\tdeleted: number;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t> = new WeakMap();\n\n\t\t\t\t\t\tconst modelLastSync = await this.getModelsMetadataWithNextFullSync(\n\t\t\t\t\t\t\tDate.now()\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst paginatingModels = new Set(modelLastSync.keys());\n\n\t\t\t\t\t\tlet lastFullSyncStartedAt: number;\n\t\t\t\t\t\tlet syncInterval: number;\n\n\t\t\t\t\t\tlet start: number;\n\t\t\t\t\t\tlet syncDuration: number;\n\t\t\t\t\t\tlet lastStartedAt: number;\n\t\t\t\t\t\tawait new Promise<void>((resolve, reject) => {\n\t\t\t\t\t\t\tif (!this.runningProcesses.isOpen) resolve();\n\t\t\t\t\t\t\tonTerminate.then(() => resolve());\n\t\t\t\t\t\t\tsyncQueriesSubscription = this.syncQueriesProcessor\n\t\t\t\t\t\t\t\t.start(modelLastSync)\n\t\t\t\t\t\t\t\t.subscribe({\n\t\t\t\t\t\t\t\t\tnext: async ({\n\t\t\t\t\t\t\t\t\t\tnamespace,\n\t\t\t\t\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\t\t\t\t\titems,\n\t\t\t\t\t\t\t\t\t\tdone,\n\t\t\t\t\t\t\t\t\t\tstartedAt,\n\t\t\t\t\t\t\t\t\t\tisFullSync,\n\t\t\t\t\t\t\t\t\t}) => {\n\t\t\t\t\t\t\t\t\t\tconst modelConstructor = this.userModelClasses[\n\t\t\t\t\t\t\t\t\t\t\tmodelDefinition.name\n\t\t\t\t\t\t\t\t\t\t] as PersistentModelConstructor<any>;\n\n\t\t\t\t\t\t\t\t\t\tif (!count.has(modelConstructor)) {\n\t\t\t\t\t\t\t\t\t\t\tcount.set(modelConstructor, {\n\t\t\t\t\t\t\t\t\t\t\t\tnew: 0,\n\t\t\t\t\t\t\t\t\t\t\t\tupdated: 0,\n\t\t\t\t\t\t\t\t\t\t\t\tdeleted: 0,\n\t\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\t\tstart = getNow();\n\t\t\t\t\t\t\t\t\t\t\tlastStartedAt =\n\t\t\t\t\t\t\t\t\t\t\t\tlastStartedAt === undefined\n\t\t\t\t\t\t\t\t\t\t\t\t\t? startedAt\n\t\t\t\t\t\t\t\t\t\t\t\t\t: Math.max(lastStartedAt, startedAt);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t\t\t * If there are mutations in the outbox for a given id, those need to be\n\t\t\t\t\t\t\t\t\t\t * merged individually. Otherwise, we can merge them in batches.\n\t\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\t\tawait this.storage.runExclusive(async storage => {\n\t\t\t\t\t\t\t\t\t\t\tconst idsInOutbox = await this.outbox.getModelIds(\n\t\t\t\t\t\t\t\t\t\t\t\tstorage\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t\tconst oneByOne: ModelInstanceMetadata[] = [];\n\t\t\t\t\t\t\t\t\t\t\tconst page = items.filter(item => {\n\t\t\t\t\t\t\t\t\t\t\t\tconst itemId = getIdentifierValue(\n\t\t\t\t\t\t\t\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\t\t\t\t\t\t\t\titem\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (!idsInOutbox.has(itemId)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\toneByOne.push(item);\n\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\t\tconst opTypeCount: [any, OpType][] = [];\n\n\t\t\t\t\t\t\t\t\t\t\tfor (const item of oneByOne) {\n\t\t\t\t\t\t\t\t\t\t\t\tconst opType = await this.modelMerger.merge(\n\t\t\t\t\t\t\t\t\t\t\t\t\tstorage,\n\t\t\t\t\t\t\t\t\t\t\t\t\titem,\n\t\t\t\t\t\t\t\t\t\t\t\t\tmodelDefinition\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (opType !== undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\t\topTypeCount.push([item, opType]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\topTypeCount.push(\n\t\t\t\t\t\t\t\t\t\t\t\t...(await this.modelMerger.mergePage(\n\t\t\t\t\t\t\t\t\t\t\t\t\tstorage,\n\t\t\t\t\t\t\t\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\t\t\t\t\t\t\t\tpage,\n\t\t\t\t\t\t\t\t\t\t\t\t\tmodelDefinition\n\t\t\t\t\t\t\t\t\t\t\t\t))\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t\tconst counts = count.get(modelConstructor)!;\n\n\t\t\t\t\t\t\t\t\t\t\topTypeCount.forEach(([, opType]) => {\n\t\t\t\t\t\t\t\t\t\t\t\tswitch (opType) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tcase OpType.INSERT:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcounts.new++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\tcase OpType.UPDATE:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcounts.updated++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\tcase OpType.DELETE:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcounts.deleted++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new Error(`Invalid opType ${opType}`);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\tif (done) {\n\t\t\t\t\t\t\t\t\t\t\tconst { name: modelName } = modelDefinition;\n\n\t\t\t\t\t\t\t\t\t\t\t//#region update last sync for type\n\t\t\t\t\t\t\t\t\t\t\tlet modelMetadata = await this.getModelMetadata(\n\t\t\t\t\t\t\t\t\t\t\t\tnamespace,\n\t\t\t\t\t\t\t\t\t\t\t\tmodelName\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t\tconst { lastFullSync, fullSyncInterval } = modelMetadata;\n\n\t\t\t\t\t\t\t\t\t\t\tsyncInterval = fullSyncInterval;\n\n\t\t\t\t\t\t\t\t\t\t\tlastFullSyncStartedAt =\n\t\t\t\t\t\t\t\t\t\t\t\tlastFullSyncStartedAt === undefined\n\t\t\t\t\t\t\t\t\t\t\t\t\t? lastFullSync!\n\t\t\t\t\t\t\t\t\t\t\t\t\t: Math.max(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlastFullSyncStartedAt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tisFullSync ? startedAt : lastFullSync!\n\t\t\t\t\t\t\t\t\t\t\t\t\t  );\n\n\t\t\t\t\t\t\t\t\t\t\tmodelMetadata = (\n\t\t\t\t\t\t\t\t\t\t\t\tthis.modelClasses\n\t\t\t\t\t\t\t\t\t\t\t\t\t.ModelMetadata as PersistentModelConstructor<ModelMetadata>\n\t\t\t\t\t\t\t\t\t\t\t).copyOf(modelMetadata, draft => {\n\t\t\t\t\t\t\t\t\t\t\t\tdraft.lastSync = startedAt;\n\t\t\t\t\t\t\t\t\t\t\t\tdraft.lastFullSync = isFullSync\n\t\t\t\t\t\t\t\t\t\t\t\t\t? startedAt\n\t\t\t\t\t\t\t\t\t\t\t\t\t: modelMetadata.lastFullSync;\n\t\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\t\tawait this.storage.save(\n\t\t\t\t\t\t\t\t\t\t\t\tmodelMetadata,\n\t\t\t\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\t\t\t\townSymbol\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t//#endregion\n\n\t\t\t\t\t\t\t\t\t\t\tconst counts = count.get(modelConstructor);\n\n\t\t\t\t\t\t\t\t\t\t\tthis.modelSyncedStatus.set(modelConstructor, true);\n\n\t\t\t\t\t\t\t\t\t\t\tobserver.next({\n\t\t\t\t\t\t\t\t\t\t\t\ttype: ControlMessage.SYNC_ENGINE_MODEL_SYNCED,\n\t\t\t\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tmodel: modelConstructor,\n\t\t\t\t\t\t\t\t\t\t\t\t\tisFullSync,\n\t\t\t\t\t\t\t\t\t\t\t\t\tisDeltaSync: !isFullSync,\n\t\t\t\t\t\t\t\t\t\t\t\t\tcounts,\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\t\tpaginatingModels.delete(modelDefinition);\n\n\t\t\t\t\t\t\t\t\t\t\tif (paginatingModels.size === 0) {\n\t\t\t\t\t\t\t\t\t\t\t\tsyncDuration = getNow() - start;\n\t\t\t\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t\t\t\t\tobserver.next({\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: ControlMessage.SYNC_ENGINE_SYNC_QUERIES_READY,\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\tsyncQueriesSubscription.unsubscribe();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\terror: error => {\n\t\t\t\t\t\t\t\t\t\tobserver.error(error);\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tobserver.next({\n\t\t\t\t\t\t\t\ttype: ControlMessage.SYNC_ENGINE_SYNC_QUERIES_STARTED,\n\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\tmodels: Array.from(paginatingModels).map(({ name }) => name),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// null is cast to 0 resulting in unexpected behavior.\n\t\t\t\t\t\t// undefined in arithmetic operations results in NaN also resulting in unexpected behavior.\n\t\t\t\t\t\t// If lastFullSyncStartedAt is null this is the first sync.\n\t\t\t\t\t\t// Assume lastStartedAt is is also newest full sync.\n\t\t\t\t\t\tlet msNextFullSync;\n\t\t\t\t\t\tif (!lastFullSyncStartedAt!) {\n\t\t\t\t\t\t\tmsNextFullSync = syncInterval! - syncDuration!;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmsNextFullSync =\n\t\t\t\t\t\t\t\tlastFullSyncStartedAt! +\n\t\t\t\t\t\t\t\tsyncInterval! -\n\t\t\t\t\t\t\t\t(lastStartedAt! + syncDuration!);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t`Next fullSync in ${msNextFullSync / 1000} seconds. (${new Date(\n\t\t\t\t\t\t\t\tDate.now() + msNextFullSync\n\t\t\t\t\t\t\t)})`\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// TODO: create `BackgroundProcessManager.sleep()` ... but, need to put\n\t\t\t\t\t\t// a lot of thought into what that contract looks like to\n\t\t\t\t\t\t//  support possible use-cases:\n\t\t\t\t\t\t//\n\t\t\t\t\t\t//  1. non-cancelable\n\t\t\t\t\t\t//  2. cancelable, unsleep on exit()\n\t\t\t\t\t\t//  3. cancelable, throw Error on exit()\n\t\t\t\t\t\t//  4. cancelable, callback first on exit()?\n\t\t\t\t\t\t//  5. ... etc. ? ...\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// TLDR; this is a lot of complexity here for a sleep(),\n\t\t\t\t\t\t// but, it's not clear to me yet how to support an\n\t\t\t\t\t\t// extensible, centralized cancelable `sleep()` elegantly.\n\t\t\t\t\t\tawait this.runningProcesses.add(async onTerminate => {\n\t\t\t\t\t\t\tlet sleepTimer;\n\t\t\t\t\t\t\tlet unsleep;\n\n\t\t\t\t\t\t\tconst sleep = new Promise(_unsleep => {\n\t\t\t\t\t\t\t\tunsleep = _unsleep;\n\t\t\t\t\t\t\t\tsleepTimer = setTimeout(unsleep, msNextFullSync);\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tonTerminate.then(() => {\n\t\t\t\t\t\t\t\tterminated = true;\n\t\t\t\t\t\t\t\tthis.syncQueriesObservableStartSleeping();\n\t\t\t\t\t\t\t\tunsleep();\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tthis.unsleepSyncQueriesObservable = unsleep;\n\t\t\t\t\t\t\tthis.syncQueriesObservableStartSleeping();\n\t\t\t\t\t\t\treturn sleep;\n\t\t\t\t\t\t}, 'syncQueriesObservable sleep');\n\n\t\t\t\t\t\tthis.unsleepSyncQueriesObservable = null;\n\t\t\t\t\t\tthis.waitForSleepState = new Promise(resolve => {\n\t\t\t\t\t\t\tthis.syncQueriesObservableStartSleeping = resolve;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}, 'syncQueriesObservable main');\n\t\t});\n\t}\n\n\tprivate disconnectionHandler(): (msg: string) => void {\n\t\treturn (msg: string) => {\n\t\t\t// This implementation is tied to AWSAppSyncRealTimeProvider 'Connection closed', 'Timeout disconnect' msg\n\t\t\tif (\n\t\t\t\tPUBSUB_CONTROL_MSG.CONNECTION_CLOSED === msg ||\n\t\t\t\tPUBSUB_CONTROL_MSG.TIMEOUT_DISCONNECT === msg\n\t\t\t) {\n\t\t\t\tthis.datastoreConnectivity.socketDisconnected();\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic unsubscribeConnectivity() {\n\t\tthis.datastoreConnectivity.unsubscribe();\n\t}\n\n\t/**\n\t * Stops all subscription activities and resolves when all activies report\n\t * that they're disconnected, done retrying, etc..\n\t */\n\tpublic async stop() {\n\t\tlogger.debug('stopping sync engine');\n\n\t\t/**\n\t\t * Gracefully disconnecting subscribers first just prevents *more* work\n\t\t * from entering the pipelines.\n\t\t */\n\t\tthis.unsubscribeConnectivity();\n\n\t\t/**\n\t\t * Stop listening for websocket connection disruption\n\t\t */\n\t\tthis.stopDisruptionListener && this.stopDisruptionListener();\n\n\t\t/**\n\t\t * aggressively shut down any lingering background processes.\n\t\t * some of this might be semi-redundant with unsubscribing. however,\n\t\t * unsubscribing doesn't allow us to wait for settling.\n\t\t * (Whereas `stop()` does.)\n\t\t */\n\n\t\tawait this.mutationsProcessor.stop();\n\t\tawait this.subscriptionsProcessor.stop();\n\t\tawait this.datastoreConnectivity.stop();\n\t\tawait this.syncQueriesProcessor.stop();\n\t\tawait this.runningProcesses.close();\n\t\tawait this.runningProcesses.open();\n\n\t\tlogger.debug('sync engine stopped and ready to restart');\n\t}\n\n\tprivate async setupModels(params: StartParams) {\n\t\tconst { fullSyncInterval } = params;\n\t\tconst ModelMetadataConstructor = this.modelClasses\n\t\t\t.ModelMetadata as PersistentModelConstructor<ModelMetadata>;\n\n\t\tconst models: [string, SchemaModel][] = [];\n\t\tlet savedModel;\n\n\t\tObject.values(this.schema.namespaces).forEach(namespace => {\n\t\t\tObject.values(namespace.models)\n\t\t\t\t.filter(({ syncable }) => syncable)\n\t\t\t\t.forEach(model => {\n\t\t\t\t\tmodels.push([namespace.name, model]);\n\t\t\t\t\tif (namespace.name === USER) {\n\t\t\t\t\t\tconst modelConstructor = this.userModelClasses[\n\t\t\t\t\t\t\tmodel.name\n\t\t\t\t\t\t] as PersistentModelConstructor<any>;\n\t\t\t\t\t\tthis.modelSyncedStatus.set(modelConstructor, false);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t});\n\n\t\tconst promises = models.map(async ([namespace, model]) => {\n\t\t\tconst modelMetadata = await this.getModelMetadata(namespace, model.name);\n\t\t\tconst syncPredicate = ModelPredicateCreator.getPredicates(\n\t\t\t\tthis.syncPredicates.get(model)!,\n\t\t\t\tfalse\n\t\t\t);\n\t\t\tconst lastSyncPredicate = syncPredicate\n\t\t\t\t? JSON.stringify(syncPredicate)\n\t\t\t\t: null;\n\n\t\t\tif (modelMetadata === undefined) {\n\t\t\t\t[[savedModel]] = await this.storage.save(\n\t\t\t\t\tthis.modelInstanceCreator(ModelMetadataConstructor, {\n\t\t\t\t\t\tmodel: model.name,\n\t\t\t\t\t\tnamespace,\n\t\t\t\t\t\tlastSync: null!,\n\t\t\t\t\t\tfullSyncInterval,\n\t\t\t\t\t\tlastFullSync: null!,\n\t\t\t\t\t\tlastSyncPredicate,\n\t\t\t\t\t}),\n\t\t\t\t\tundefined,\n\t\t\t\t\townSymbol\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tconst prevSyncPredicate = modelMetadata.lastSyncPredicate\n\t\t\t\t\t? modelMetadata.lastSyncPredicate\n\t\t\t\t\t: null;\n\t\t\t\tconst syncPredicateUpdated = prevSyncPredicate !== lastSyncPredicate;\n\n\t\t\t\t[[savedModel]] = await this.storage.save(\n\t\t\t\t\tModelMetadataConstructor.copyOf(modelMetadata, draft => {\n\t\t\t\t\t\tdraft.fullSyncInterval = fullSyncInterval;\n\t\t\t\t\t\t// perform a base sync if the syncPredicate changed in between calls to DataStore.start\n\t\t\t\t\t\t// ensures that the local store contains all the data specified by the syncExpression\n\t\t\t\t\t\tif (syncPredicateUpdated) {\n\t\t\t\t\t\t\tdraft.lastSync = null!;\n\t\t\t\t\t\t\tdraft.lastFullSync = null!;\n\t\t\t\t\t\t\t(draft.lastSyncPredicate as any) = lastSyncPredicate;\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn savedModel;\n\t\t});\n\n\t\tconst result: Record<string, ModelMetadata> = {};\n\t\tfor (const modelMetadata of await Promise.all(promises)) {\n\t\t\tconst { model: modelName } = modelMetadata;\n\n\t\t\tresult[modelName] = modelMetadata;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate async getModelsMetadata(): Promise<ModelMetadata[]> {\n\t\tconst ModelMetadata = this.modelClasses\n\t\t\t.ModelMetadata as PersistentModelConstructor<ModelMetadata>;\n\n\t\tconst modelsMetadata = await this.storage.query(ModelMetadata);\n\n\t\treturn modelsMetadata;\n\t}\n\n\tprivate async getModelMetadata(\n\t\tnamespace: string,\n\t\tmodel: string\n\t): Promise<ModelMetadata> {\n\t\tconst ModelMetadata = this.modelClasses\n\t\t\t.ModelMetadata as PersistentModelConstructor<ModelMetadata>;\n\n\t\tconst predicate = ModelPredicateCreator.createFromAST<ModelMetadata>(\n\t\t\tthis.schema.namespaces[SYNC].models[ModelMetadata.name],\n\t\t\t{ and: [{ namespace: { eq: namespace } }, { model: { eq: model } }] }\n\t\t);\n\n\t\tconst [modelMetadata] = await this.storage.query(ModelMetadata, predicate, {\n\t\t\tpage: 0,\n\t\t\tlimit: 1,\n\t\t});\n\n\t\treturn modelMetadata;\n\t}\n\n\tprivate getModelDefinition(\n\t\tmodelConstructor: PersistentModelConstructor<any>\n\t): SchemaModel {\n\t\tconst namespaceName = this.namespaceResolver(modelConstructor);\n\n\t\tconst modelDefinition =\n\t\t\tthis.schema.namespaces[namespaceName].models[modelConstructor.name];\n\n\t\treturn modelDefinition;\n\t}\n\n\tstatic getNamespace() {\n\t\tconst namespace: SchemaNamespace = {\n\t\t\tname: SYNC,\n\t\t\trelationships: {},\n\t\t\tenums: {\n\t\t\t\tOperationType: {\n\t\t\t\t\tname: 'OperationType',\n\t\t\t\t\tvalues: ['CREATE', 'UPDATE', 'DELETE'],\n\t\t\t\t},\n\t\t\t},\n\t\t\tnonModels: {},\n\t\t\tmodels: {\n\t\t\t\tMutationEvent: {\n\t\t\t\t\tname: 'MutationEvent',\n\t\t\t\t\tpluralName: 'MutationEvents',\n\t\t\t\t\tsyncable: false,\n\t\t\t\t\tfields: {\n\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\tname: 'id',\n\t\t\t\t\t\t\ttype: 'ID',\n\t\t\t\t\t\t\tisRequired: true,\n\t\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tmodel: {\n\t\t\t\t\t\t\tname: 'model',\n\t\t\t\t\t\t\ttype: 'String',\n\t\t\t\t\t\t\tisRequired: true,\n\t\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\tname: 'data',\n\t\t\t\t\t\t\ttype: 'String',\n\t\t\t\t\t\t\tisRequired: true,\n\t\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tmodelId: {\n\t\t\t\t\t\t\tname: 'modelId',\n\t\t\t\t\t\t\ttype: 'String',\n\t\t\t\t\t\t\tisRequired: true,\n\t\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t\t},\n\t\t\t\t\t\toperation: {\n\t\t\t\t\t\t\tname: 'operation',\n\t\t\t\t\t\t\ttype: {\n\t\t\t\t\t\t\t\tenum: 'Operationtype',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t\t\tisRequired: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcondition: {\n\t\t\t\t\t\t\tname: 'condition',\n\t\t\t\t\t\t\ttype: 'String',\n\t\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t\t\tisRequired: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tModelMetadata: {\n\t\t\t\t\tname: 'ModelMetadata',\n\t\t\t\t\tpluralName: 'ModelsMetadata',\n\t\t\t\t\tsyncable: false,\n\t\t\t\t\tfields: {\n\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\tname: 'id',\n\t\t\t\t\t\t\ttype: 'ID',\n\t\t\t\t\t\t\tisRequired: true,\n\t\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnamespace: {\n\t\t\t\t\t\t\tname: 'namespace',\n\t\t\t\t\t\t\ttype: 'String',\n\t\t\t\t\t\t\tisRequired: true,\n\t\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tmodel: {\n\t\t\t\t\t\t\tname: 'model',\n\t\t\t\t\t\t\ttype: 'String',\n\t\t\t\t\t\t\tisRequired: true,\n\t\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tlastSync: {\n\t\t\t\t\t\t\tname: 'lastSync',\n\t\t\t\t\t\t\ttype: 'Int',\n\t\t\t\t\t\t\tisRequired: false,\n\t\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tlastFullSync: {\n\t\t\t\t\t\t\tname: 'lastFullSync',\n\t\t\t\t\t\t\ttype: 'Int',\n\t\t\t\t\t\t\tisRequired: false,\n\t\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfullSyncInterval: {\n\t\t\t\t\t\t\tname: 'fullSyncInterval',\n\t\t\t\t\t\t\ttype: 'Int',\n\t\t\t\t\t\t\tisRequired: true,\n\t\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tlastSyncPredicate: {\n\t\t\t\t\t\t\tname: 'lastSyncPredicate',\n\t\t\t\t\t\t\ttype: 'String',\n\t\t\t\t\t\t\tisRequired: false,\n\t\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t\treturn namespace;\n\t}\n\n\t/**\n\t * listen for websocket connection disruption\n\t *\n\t * May indicate there was a period of time where messages\n\t * from AppSync were missed. A sync needs to be triggered to\n\t * retrieve the missed data.\n\t */\n\tprivate startDisruptionListener() {\n\t\treturn Hub.listen('api', (data: any) => {\n\t\t\tif (\n\t\t\t\tdata.source === 'PubSub' &&\n\t\t\t\tdata.payload.event === PUBSUB_CONNECTION_STATE_CHANGE\n\t\t\t) {\n\t\t\t\tconst connectionState = data.payload.data\n\t\t\t\t\t.connectionState as ConnectionState;\n\n\t\t\t\tswitch (connectionState) {\n\t\t\t\t\t// Do not need to listen for ConnectionDisruptedPendingNetwork\n\t\t\t\t\t// Normal network reconnection logic will handle the sync\n\t\t\t\t\tcase ConnectionState.ConnectionDisrupted:\n\t\t\t\t\t\tthis.connectionDisrupted = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ConnectionState.Connected:\n\t\t\t\t\t\tif (this.connectionDisrupted) {\n\t\t\t\t\t\t\tthis.scheduleSync();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.connectionDisrupted = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/*\n\t * Schedule a sync to start when syncQueriesObservable enters sleep state\n\t * Start sync immediately if syncQueriesObservable is already in sleep state\n\t */\n\tprivate scheduleSync() {\n\t\treturn (\n\t\t\tthis.runningProcesses.isOpen &&\n\t\t\tthis.runningProcesses.add(() =>\n\t\t\t\tthis.waitForSleepState.then(() => {\n\t\t\t\t\t// unsleepSyncQueriesObservable will be set if waitForSleepState has resolved\n\t\t\t\t\tthis.unsleepSyncQueriesObservable!();\n\t\t\t\t})\n\t\t\t)\n\t\t);\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}