{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { KinesisClient } from \"./KinesisClient\";\nimport { AddTagsToStreamCommand } from \"./commands/AddTagsToStreamCommand\";\nimport { CreateStreamCommand } from \"./commands/CreateStreamCommand\";\nimport { DecreaseStreamRetentionPeriodCommand } from \"./commands/DecreaseStreamRetentionPeriodCommand\";\nimport { DeleteStreamCommand } from \"./commands/DeleteStreamCommand\";\nimport { DeregisterStreamConsumerCommand } from \"./commands/DeregisterStreamConsumerCommand\";\nimport { DescribeLimitsCommand } from \"./commands/DescribeLimitsCommand\";\nimport { DescribeStreamCommand } from \"./commands/DescribeStreamCommand\";\nimport { DescribeStreamConsumerCommand } from \"./commands/DescribeStreamConsumerCommand\";\nimport { DescribeStreamSummaryCommand } from \"./commands/DescribeStreamSummaryCommand\";\nimport { DisableEnhancedMonitoringCommand } from \"./commands/DisableEnhancedMonitoringCommand\";\nimport { EnableEnhancedMonitoringCommand } from \"./commands/EnableEnhancedMonitoringCommand\";\nimport { GetRecordsCommand } from \"./commands/GetRecordsCommand\";\nimport { GetShardIteratorCommand } from \"./commands/GetShardIteratorCommand\";\nimport { IncreaseStreamRetentionPeriodCommand } from \"./commands/IncreaseStreamRetentionPeriodCommand\";\nimport { ListShardsCommand } from \"./commands/ListShardsCommand\";\nimport { ListStreamConsumersCommand } from \"./commands/ListStreamConsumersCommand\";\nimport { ListStreamsCommand } from \"./commands/ListStreamsCommand\";\nimport { ListTagsForStreamCommand } from \"./commands/ListTagsForStreamCommand\";\nimport { MergeShardsCommand } from \"./commands/MergeShardsCommand\";\nimport { PutRecordCommand } from \"./commands/PutRecordCommand\";\nimport { PutRecordsCommand } from \"./commands/PutRecordsCommand\";\nimport { RegisterStreamConsumerCommand } from \"./commands/RegisterStreamConsumerCommand\";\nimport { RemoveTagsFromStreamCommand } from \"./commands/RemoveTagsFromStreamCommand\";\nimport { SplitShardCommand } from \"./commands/SplitShardCommand\";\nimport { StartStreamEncryptionCommand } from \"./commands/StartStreamEncryptionCommand\";\nimport { StopStreamEncryptionCommand } from \"./commands/StopStreamEncryptionCommand\";\nimport { SubscribeToShardCommand } from \"./commands/SubscribeToShardCommand\";\nimport { UpdateShardCountCommand } from \"./commands/UpdateShardCountCommand\";\n/**\n * <fullname>Amazon Kinesis Data Streams Service API Reference</fullname>\n *         <p>Amazon Kinesis Data Streams is a managed service that scales elastically for\n *             real-time processing of streaming big data.</p>\n */\nvar Kinesis = /** @class */function (_super) {\n  __extends(Kinesis, _super);\n  function Kinesis() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Kinesis.prototype.addTagsToStream = function (args, optionsOrCb, cb) {\n    var command = new AddTagsToStreamCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(\"Expect http options but get \" + typeof optionsOrCb);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  };\n  Kinesis.prototype.createStream = function (args, optionsOrCb, cb) {\n    var command = new CreateStreamCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(\"Expect http options but get \" + typeof optionsOrCb);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  };\n  Kinesis.prototype.decreaseStreamRetentionPeriod = function (args, optionsOrCb, cb) {\n    var command = new DecreaseStreamRetentionPeriodCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(\"Expect http options but get \" + typeof optionsOrCb);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  };\n  Kinesis.prototype.deleteStream = function (args, optionsOrCb, cb) {\n    var command = new DeleteStreamCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(\"Expect http options but get \" + typeof optionsOrCb);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  };\n  Kinesis.prototype.deregisterStreamConsumer = function (args, optionsOrCb, cb) {\n    var command = new DeregisterStreamConsumerCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(\"Expect http options but get \" + typeof optionsOrCb);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  };\n  Kinesis.prototype.describeLimits = function (args, optionsOrCb, cb) {\n    var command = new DescribeLimitsCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(\"Expect http options but get \" + typeof optionsOrCb);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  };\n  Kinesis.prototype.describeStream = function (args, optionsOrCb, cb) {\n    var command = new DescribeStreamCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(\"Expect http options but get \" + typeof optionsOrCb);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  };\n  Kinesis.prototype.describeStreamConsumer = function (args, optionsOrCb, cb) {\n    var command = new DescribeStreamConsumerCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(\"Expect http options but get \" + typeof optionsOrCb);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  };\n  Kinesis.prototype.describeStreamSummary = function (args, optionsOrCb, cb) {\n    var command = new DescribeStreamSummaryCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(\"Expect http options but get \" + typeof optionsOrCb);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  };\n  Kinesis.prototype.disableEnhancedMonitoring = function (args, optionsOrCb, cb) {\n    var command = new DisableEnhancedMonitoringCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(\"Expect http options but get \" + typeof optionsOrCb);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  };\n  Kinesis.prototype.enableEnhancedMonitoring = function (args, optionsOrCb, cb) {\n    var command = new EnableEnhancedMonitoringCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(\"Expect http options but get \" + typeof optionsOrCb);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  };\n  Kinesis.prototype.getRecords = function (args, optionsOrCb, cb) {\n    var command = new GetRecordsCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(\"Expect http options but get \" + typeof optionsOrCb);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  };\n  Kinesis.prototype.getShardIterator = function (args, optionsOrCb, cb) {\n    var command = new GetShardIteratorCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(\"Expect http options but get \" + typeof optionsOrCb);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  };\n  Kinesis.prototype.increaseStreamRetentionPeriod = function (args, optionsOrCb, cb) {\n    var command = new IncreaseStreamRetentionPeriodCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(\"Expect http options but get \" + typeof optionsOrCb);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  };\n  Kinesis.prototype.listShards = function (args, optionsOrCb, cb) {\n    var command = new ListShardsCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(\"Expect http options but get \" + typeof optionsOrCb);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  };\n  Kinesis.prototype.listStreamConsumers = function (args, optionsOrCb, cb) {\n    var command = new ListStreamConsumersCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(\"Expect http options but get \" + typeof optionsOrCb);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  };\n  Kinesis.prototype.listStreams = function (args, optionsOrCb, cb) {\n    var command = new ListStreamsCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(\"Expect http options but get \" + typeof optionsOrCb);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  };\n  Kinesis.prototype.listTagsForStream = function (args, optionsOrCb, cb) {\n    var command = new ListTagsForStreamCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(\"Expect http options but get \" + typeof optionsOrCb);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  };\n  Kinesis.prototype.mergeShards = function (args, optionsOrCb, cb) {\n    var command = new MergeShardsCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(\"Expect http options but get \" + typeof optionsOrCb);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  };\n  Kinesis.prototype.putRecord = function (args, optionsOrCb, cb) {\n    var command = new PutRecordCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(\"Expect http options but get \" + typeof optionsOrCb);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  };\n  Kinesis.prototype.putRecords = function (args, optionsOrCb, cb) {\n    var command = new PutRecordsCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(\"Expect http options but get \" + typeof optionsOrCb);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  };\n  Kinesis.prototype.registerStreamConsumer = function (args, optionsOrCb, cb) {\n    var command = new RegisterStreamConsumerCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(\"Expect http options but get \" + typeof optionsOrCb);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  };\n  Kinesis.prototype.removeTagsFromStream = function (args, optionsOrCb, cb) {\n    var command = new RemoveTagsFromStreamCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(\"Expect http options but get \" + typeof optionsOrCb);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  };\n  Kinesis.prototype.splitShard = function (args, optionsOrCb, cb) {\n    var command = new SplitShardCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(\"Expect http options but get \" + typeof optionsOrCb);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  };\n  Kinesis.prototype.startStreamEncryption = function (args, optionsOrCb, cb) {\n    var command = new StartStreamEncryptionCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(\"Expect http options but get \" + typeof optionsOrCb);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  };\n  Kinesis.prototype.stopStreamEncryption = function (args, optionsOrCb, cb) {\n    var command = new StopStreamEncryptionCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(\"Expect http options but get \" + typeof optionsOrCb);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  };\n  Kinesis.prototype.subscribeToShard = function (args, optionsOrCb, cb) {\n    var command = new SubscribeToShardCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(\"Expect http options but get \" + typeof optionsOrCb);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  };\n  Kinesis.prototype.updateShardCount = function (args, optionsOrCb, cb) {\n    var command = new UpdateShardCountCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(\"Expect http options but get \" + typeof optionsOrCb);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  };\n  return Kinesis;\n}(KinesisClient);\nexport { Kinesis };","map":{"version":3,"names":["KinesisClient","AddTagsToStreamCommand","CreateStreamCommand","DecreaseStreamRetentionPeriodCommand","DeleteStreamCommand","DeregisterStreamConsumerCommand","DescribeLimitsCommand","DescribeStreamCommand","DescribeStreamConsumerCommand","DescribeStreamSummaryCommand","DisableEnhancedMonitoringCommand","EnableEnhancedMonitoringCommand","GetRecordsCommand","GetShardIteratorCommand","IncreaseStreamRetentionPeriodCommand","ListShardsCommand","ListStreamConsumersCommand","ListStreamsCommand","ListTagsForStreamCommand","MergeShardsCommand","PutRecordCommand","PutRecordsCommand","RegisterStreamConsumerCommand","RemoveTagsFromStreamCommand","SplitShardCommand","StartStreamEncryptionCommand","StopStreamEncryptionCommand","SubscribeToShardCommand","UpdateShardCountCommand","Kinesis","_super","__extends","prototype","addTagsToStream","args","optionsOrCb","cb","command","send","Error","createStream","decreaseStreamRetentionPeriod","deleteStream","deregisterStreamConsumer","describeLimits","describeStream","describeStreamConsumer","describeStreamSummary","disableEnhancedMonitoring","enableEnhancedMonitoring","getRecords","getShardIterator","increaseStreamRetentionPeriod","listShards","listStreamConsumers","listStreams","listTagsForStream","mergeShards","putRecord","putRecords","registerStreamConsumer","removeTagsFromStream","splitShard","startStreamEncryption","stopStreamEncryption","subscribeToShard","updateShardCount"],"sources":["/Users/yannellym/Desktop/iwantapet/node_modules/@aws-sdk/client-kinesis/Kinesis.ts"],"sourcesContent":["import { KinesisClient } from \"./KinesisClient\";\nimport {\n  AddTagsToStreamCommand,\n  AddTagsToStreamCommandInput,\n  AddTagsToStreamCommandOutput,\n} from \"./commands/AddTagsToStreamCommand\";\nimport {\n  CreateStreamCommand,\n  CreateStreamCommandInput,\n  CreateStreamCommandOutput,\n} from \"./commands/CreateStreamCommand\";\nimport {\n  DecreaseStreamRetentionPeriodCommand,\n  DecreaseStreamRetentionPeriodCommandInput,\n  DecreaseStreamRetentionPeriodCommandOutput,\n} from \"./commands/DecreaseStreamRetentionPeriodCommand\";\nimport {\n  DeleteStreamCommand,\n  DeleteStreamCommandInput,\n  DeleteStreamCommandOutput,\n} from \"./commands/DeleteStreamCommand\";\nimport {\n  DeregisterStreamConsumerCommand,\n  DeregisterStreamConsumerCommandInput,\n  DeregisterStreamConsumerCommandOutput,\n} from \"./commands/DeregisterStreamConsumerCommand\";\nimport {\n  DescribeLimitsCommand,\n  DescribeLimitsCommandInput,\n  DescribeLimitsCommandOutput,\n} from \"./commands/DescribeLimitsCommand\";\nimport {\n  DescribeStreamCommand,\n  DescribeStreamCommandInput,\n  DescribeStreamCommandOutput,\n} from \"./commands/DescribeStreamCommand\";\nimport {\n  DescribeStreamConsumerCommand,\n  DescribeStreamConsumerCommandInput,\n  DescribeStreamConsumerCommandOutput,\n} from \"./commands/DescribeStreamConsumerCommand\";\nimport {\n  DescribeStreamSummaryCommand,\n  DescribeStreamSummaryCommandInput,\n  DescribeStreamSummaryCommandOutput,\n} from \"./commands/DescribeStreamSummaryCommand\";\nimport {\n  DisableEnhancedMonitoringCommand,\n  DisableEnhancedMonitoringCommandInput,\n  DisableEnhancedMonitoringCommandOutput,\n} from \"./commands/DisableEnhancedMonitoringCommand\";\nimport {\n  EnableEnhancedMonitoringCommand,\n  EnableEnhancedMonitoringCommandInput,\n  EnableEnhancedMonitoringCommandOutput,\n} from \"./commands/EnableEnhancedMonitoringCommand\";\nimport { GetRecordsCommand, GetRecordsCommandInput, GetRecordsCommandOutput } from \"./commands/GetRecordsCommand\";\nimport {\n  GetShardIteratorCommand,\n  GetShardIteratorCommandInput,\n  GetShardIteratorCommandOutput,\n} from \"./commands/GetShardIteratorCommand\";\nimport {\n  IncreaseStreamRetentionPeriodCommand,\n  IncreaseStreamRetentionPeriodCommandInput,\n  IncreaseStreamRetentionPeriodCommandOutput,\n} from \"./commands/IncreaseStreamRetentionPeriodCommand\";\nimport { ListShardsCommand, ListShardsCommandInput, ListShardsCommandOutput } from \"./commands/ListShardsCommand\";\nimport {\n  ListStreamConsumersCommand,\n  ListStreamConsumersCommandInput,\n  ListStreamConsumersCommandOutput,\n} from \"./commands/ListStreamConsumersCommand\";\nimport { ListStreamsCommand, ListStreamsCommandInput, ListStreamsCommandOutput } from \"./commands/ListStreamsCommand\";\nimport {\n  ListTagsForStreamCommand,\n  ListTagsForStreamCommandInput,\n  ListTagsForStreamCommandOutput,\n} from \"./commands/ListTagsForStreamCommand\";\nimport { MergeShardsCommand, MergeShardsCommandInput, MergeShardsCommandOutput } from \"./commands/MergeShardsCommand\";\nimport { PutRecordCommand, PutRecordCommandInput, PutRecordCommandOutput } from \"./commands/PutRecordCommand\";\nimport { PutRecordsCommand, PutRecordsCommandInput, PutRecordsCommandOutput } from \"./commands/PutRecordsCommand\";\nimport {\n  RegisterStreamConsumerCommand,\n  RegisterStreamConsumerCommandInput,\n  RegisterStreamConsumerCommandOutput,\n} from \"./commands/RegisterStreamConsumerCommand\";\nimport {\n  RemoveTagsFromStreamCommand,\n  RemoveTagsFromStreamCommandInput,\n  RemoveTagsFromStreamCommandOutput,\n} from \"./commands/RemoveTagsFromStreamCommand\";\nimport { SplitShardCommand, SplitShardCommandInput, SplitShardCommandOutput } from \"./commands/SplitShardCommand\";\nimport {\n  StartStreamEncryptionCommand,\n  StartStreamEncryptionCommandInput,\n  StartStreamEncryptionCommandOutput,\n} from \"./commands/StartStreamEncryptionCommand\";\nimport {\n  StopStreamEncryptionCommand,\n  StopStreamEncryptionCommandInput,\n  StopStreamEncryptionCommandOutput,\n} from \"./commands/StopStreamEncryptionCommand\";\nimport {\n  SubscribeToShardCommand,\n  SubscribeToShardCommandInput,\n  SubscribeToShardCommandOutput,\n} from \"./commands/SubscribeToShardCommand\";\nimport {\n  UpdateShardCountCommand,\n  UpdateShardCountCommandInput,\n  UpdateShardCountCommandOutput,\n} from \"./commands/UpdateShardCountCommand\";\nimport { HttpHandlerOptions as __HttpHandlerOptions } from \"@aws-sdk/types\";\n\n/**\n * <fullname>Amazon Kinesis Data Streams Service API Reference</fullname>\n *         <p>Amazon Kinesis Data Streams is a managed service that scales elastically for\n *             real-time processing of streaming big data.</p>\n */\nexport class Kinesis extends KinesisClient {\n  /**\n   * <p>Adds or updates tags for the specified Kinesis data stream. Each time you invoke\n   *             this operation, you can specify up to 10 tags. If you want to add more than 10 tags to\n   *             your stream, you can invoke this operation multiple times. In total, each stream can\n   *             have up to 50 tags.</p>\n   *         <p>If tags have already been assigned to the stream, <code>AddTagsToStream</code>\n   *             overwrites any existing tags that correspond to the specified tag keys.</p>\n   *         <p>\n   *             <a>AddTagsToStream</a> has a limit of five transactions per second per\n   *             account.</p>\n   */\n  public addTagsToStream(\n    args: AddTagsToStreamCommandInput,\n    options?: __HttpHandlerOptions\n  ): Promise<AddTagsToStreamCommandOutput>;\n  public addTagsToStream(\n    args: AddTagsToStreamCommandInput,\n    cb: (err: any, data?: AddTagsToStreamCommandOutput) => void\n  ): void;\n  public addTagsToStream(\n    args: AddTagsToStreamCommandInput,\n    options: __HttpHandlerOptions,\n    cb: (err: any, data?: AddTagsToStreamCommandOutput) => void\n  ): void;\n  public addTagsToStream(\n    args: AddTagsToStreamCommandInput,\n    optionsOrCb?: __HttpHandlerOptions | ((err: any, data?: AddTagsToStreamCommandOutput) => void),\n    cb?: (err: any, data?: AddTagsToStreamCommandOutput) => void\n  ): Promise<AddTagsToStreamCommandOutput> | void {\n    const command = new AddTagsToStreamCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(`Expect http options but get ${typeof optionsOrCb}`);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  }\n\n  /**\n   * <p>Creates a Kinesis data stream. A stream captures and transports data records that\n   *             are continuously emitted from different data sources or <i>producers</i>.\n   *             Scale-out within a stream is explicitly supported by means of shards, which are uniquely\n   *             identified groups of data records in a stream.</p>\n   *         <p>You specify and control the number of shards that a stream is composed of. Each\n   *             shard can support reads up to five transactions per second, up to a maximum data read\n   *             total of 2 MiB per second. Each shard can support writes up to 1,000 records per second,\n   *             up to a maximum data write total of 1 MiB per second. If the amount of data input\n   *             increases or decreases, you can add or remove shards.</p>\n   *         <p>The stream name identifies the stream. The name is scoped to the AWS account used\n   *             by the application. It is also scoped by AWS Region. That is, two streams in two\n   *             different accounts can have the same name, and two streams in the same account, but in\n   *             two different Regions, can have the same name.</p>\n   *         <p>\n   *             <code>CreateStream</code> is an asynchronous operation. Upon receiving a\n   *                 <code>CreateStream</code> request, Kinesis Data Streams immediately returns and sets\n   *             the stream status to <code>CREATING</code>. After the stream is created, Kinesis Data\n   *             Streams sets the stream status to <code>ACTIVE</code>. You should perform read and write\n   *             operations only on an <code>ACTIVE</code> stream. </p>\n   *         <p>You receive a <code>LimitExceededException</code> when making a\n   *                 <code>CreateStream</code> request when you try to do one of the following:</p>\n   *         <ul>\n   *             <li>\n   *\n   *                 <p>Have more than five streams in the <code>CREATING</code> state at any point\n   *                     in time.</p>\n   *             </li>\n   *             <li>\n   *\n   *                 <p>Create more shards than are authorized for your account.</p>\n   *             </li>\n   *          </ul>\n   *         <p>For the default shard limit for an AWS account, see <a href=\"https://docs.aws.amazon.com/kinesis/latest/dev/service-sizes-and-limits.html\">Amazon Kinesis Data Streams\n   *                 Limits</a> in the <i>Amazon Kinesis Data Streams Developer\n   *                 Guide</i>. To increase this limit, <a href=\"https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html\">contact AWS\n   *             Support</a>.</p>\n   *         <p>You can use <code>DescribeStream</code> to check the stream status, which is\n   *             returned in <code>StreamStatus</code>.</p>\n   *         <p>\n   *             <a>CreateStream</a> has a limit of five transactions per second per\n   *             account.</p>\n   */\n  public createStream(\n    args: CreateStreamCommandInput,\n    options?: __HttpHandlerOptions\n  ): Promise<CreateStreamCommandOutput>;\n  public createStream(args: CreateStreamCommandInput, cb: (err: any, data?: CreateStreamCommandOutput) => void): void;\n  public createStream(\n    args: CreateStreamCommandInput,\n    options: __HttpHandlerOptions,\n    cb: (err: any, data?: CreateStreamCommandOutput) => void\n  ): void;\n  public createStream(\n    args: CreateStreamCommandInput,\n    optionsOrCb?: __HttpHandlerOptions | ((err: any, data?: CreateStreamCommandOutput) => void),\n    cb?: (err: any, data?: CreateStreamCommandOutput) => void\n  ): Promise<CreateStreamCommandOutput> | void {\n    const command = new CreateStreamCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(`Expect http options but get ${typeof optionsOrCb}`);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  }\n\n  /**\n   * <p>Decreases the Kinesis data stream's retention period, which is the length of time\n   *             data records are accessible after they are added to the stream. The minimum value of a\n   *             stream's retention period is 24 hours.</p>\n   *         <p>This operation may result in lost data. For example, if the stream's retention\n   *             period is 48 hours and is decreased to 24 hours, any data already in the stream that is\n   *             older than 24 hours is inaccessible.</p>\n   */\n  public decreaseStreamRetentionPeriod(\n    args: DecreaseStreamRetentionPeriodCommandInput,\n    options?: __HttpHandlerOptions\n  ): Promise<DecreaseStreamRetentionPeriodCommandOutput>;\n  public decreaseStreamRetentionPeriod(\n    args: DecreaseStreamRetentionPeriodCommandInput,\n    cb: (err: any, data?: DecreaseStreamRetentionPeriodCommandOutput) => void\n  ): void;\n  public decreaseStreamRetentionPeriod(\n    args: DecreaseStreamRetentionPeriodCommandInput,\n    options: __HttpHandlerOptions,\n    cb: (err: any, data?: DecreaseStreamRetentionPeriodCommandOutput) => void\n  ): void;\n  public decreaseStreamRetentionPeriod(\n    args: DecreaseStreamRetentionPeriodCommandInput,\n    optionsOrCb?: __HttpHandlerOptions | ((err: any, data?: DecreaseStreamRetentionPeriodCommandOutput) => void),\n    cb?: (err: any, data?: DecreaseStreamRetentionPeriodCommandOutput) => void\n  ): Promise<DecreaseStreamRetentionPeriodCommandOutput> | void {\n    const command = new DecreaseStreamRetentionPeriodCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(`Expect http options but get ${typeof optionsOrCb}`);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  }\n\n  /**\n   * <p>Deletes a Kinesis data stream and all its shards and data. You must shut down any\n   *             applications that are operating on the stream before you delete the stream. If an\n   *             application attempts to operate on a deleted stream, it receives the exception\n   *                 <code>ResourceNotFoundException</code>.</p>\n   *         <p>If the stream is in the <code>ACTIVE</code> state, you can delete it. After a\n   *                 <code>DeleteStream</code> request, the specified stream is in the\n   *                 <code>DELETING</code> state until Kinesis Data Streams completes the\n   *             deletion.</p>\n   *         <p>\n   *             <b>Note:</b> Kinesis Data Streams might continue to accept\n   *             data read and write operations, such as <a>PutRecord</a>, <a>PutRecords</a>, and <a>GetRecords</a>, on a stream in the\n   *                 <code>DELETING</code> state until the stream deletion is complete.</p>\n   *         <p>When you delete a stream, any shards in that stream are also deleted, and any tags\n   *             are dissociated from the stream.</p>\n   *         <p>You can use the <a>DescribeStream</a> operation to check the state of\n   *             the stream, which is returned in <code>StreamStatus</code>.</p>\n   *         <p>\n   *             <a>DeleteStream</a> has a limit of five transactions per second per\n   *             account.</p>\n   */\n  public deleteStream(\n    args: DeleteStreamCommandInput,\n    options?: __HttpHandlerOptions\n  ): Promise<DeleteStreamCommandOutput>;\n  public deleteStream(args: DeleteStreamCommandInput, cb: (err: any, data?: DeleteStreamCommandOutput) => void): void;\n  public deleteStream(\n    args: DeleteStreamCommandInput,\n    options: __HttpHandlerOptions,\n    cb: (err: any, data?: DeleteStreamCommandOutput) => void\n  ): void;\n  public deleteStream(\n    args: DeleteStreamCommandInput,\n    optionsOrCb?: __HttpHandlerOptions | ((err: any, data?: DeleteStreamCommandOutput) => void),\n    cb?: (err: any, data?: DeleteStreamCommandOutput) => void\n  ): Promise<DeleteStreamCommandOutput> | void {\n    const command = new DeleteStreamCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(`Expect http options but get ${typeof optionsOrCb}`);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  }\n\n  /**\n   * <p>To deregister a consumer, provide its ARN. Alternatively, you can provide the ARN of\n   *             the data stream and the name you gave the consumer when you registered it. You may also\n   *             provide all three parameters, as long as they don't conflict with each other. If you\n   *             don't know the name or ARN of the consumer that you want to deregister, you can use the\n   *                 <a>ListStreamConsumers</a> operation to get a list of the descriptions of\n   *             all the consumers that are currently registered with a given data stream. The\n   *             description of a consumer contains its name and ARN.</p>\n   *         <p>This operation has a limit of five transactions per second per stream.</p>\n   */\n  public deregisterStreamConsumer(\n    args: DeregisterStreamConsumerCommandInput,\n    options?: __HttpHandlerOptions\n  ): Promise<DeregisterStreamConsumerCommandOutput>;\n  public deregisterStreamConsumer(\n    args: DeregisterStreamConsumerCommandInput,\n    cb: (err: any, data?: DeregisterStreamConsumerCommandOutput) => void\n  ): void;\n  public deregisterStreamConsumer(\n    args: DeregisterStreamConsumerCommandInput,\n    options: __HttpHandlerOptions,\n    cb: (err: any, data?: DeregisterStreamConsumerCommandOutput) => void\n  ): void;\n  public deregisterStreamConsumer(\n    args: DeregisterStreamConsumerCommandInput,\n    optionsOrCb?: __HttpHandlerOptions | ((err: any, data?: DeregisterStreamConsumerCommandOutput) => void),\n    cb?: (err: any, data?: DeregisterStreamConsumerCommandOutput) => void\n  ): Promise<DeregisterStreamConsumerCommandOutput> | void {\n    const command = new DeregisterStreamConsumerCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(`Expect http options but get ${typeof optionsOrCb}`);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  }\n\n  /**\n   * <p>Describes the shard limits and usage for the account.</p>\n   *         <p>If you update your account limits, the old limits might be returned for a few\n   *             minutes.</p>\n   *         <p>This operation has a limit of one transaction per second per account.</p>\n   */\n  public describeLimits(\n    args: DescribeLimitsCommandInput,\n    options?: __HttpHandlerOptions\n  ): Promise<DescribeLimitsCommandOutput>;\n  public describeLimits(\n    args: DescribeLimitsCommandInput,\n    cb: (err: any, data?: DescribeLimitsCommandOutput) => void\n  ): void;\n  public describeLimits(\n    args: DescribeLimitsCommandInput,\n    options: __HttpHandlerOptions,\n    cb: (err: any, data?: DescribeLimitsCommandOutput) => void\n  ): void;\n  public describeLimits(\n    args: DescribeLimitsCommandInput,\n    optionsOrCb?: __HttpHandlerOptions | ((err: any, data?: DescribeLimitsCommandOutput) => void),\n    cb?: (err: any, data?: DescribeLimitsCommandOutput) => void\n  ): Promise<DescribeLimitsCommandOutput> | void {\n    const command = new DescribeLimitsCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(`Expect http options but get ${typeof optionsOrCb}`);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  }\n\n  /**\n   * <p>Describes the specified Kinesis data stream.</p>\n   *\n   *         <p>The information returned includes the stream name, Amazon Resource Name (ARN),\n   *             creation time, enhanced metric configuration, and shard map. The shard map is an array\n   *             of shard objects. For each shard object, there is the hash key and sequence number\n   *             ranges that the shard spans, and the IDs of any earlier shards that played in a role in\n   *             creating the shard. Every record ingested in the stream is identified by a sequence\n   *             number, which is assigned when the record is put into the stream.</p>\n   *\n   *         <p>You can limit the number of shards returned by each call. For more information, see\n   *                 <a href=\"https://docs.aws.amazon.com/kinesis/latest/dev/kinesis-using-sdk-java-retrieve-shards.html\">Retrieving\n   *                 Shards from a Stream</a> in the <i>Amazon Kinesis Data Streams Developer\n   *                 Guide</i>.</p>\n   *         <p>There are no guarantees about the chronological order shards returned. To process\n   *             shards in chronological order, use the ID of the parent shard to track the lineage to\n   *             the oldest shard.</p>\n   *         <p>This operation has a limit of 10 transactions per second per account.</p>\n   */\n  public describeStream(\n    args: DescribeStreamCommandInput,\n    options?: __HttpHandlerOptions\n  ): Promise<DescribeStreamCommandOutput>;\n  public describeStream(\n    args: DescribeStreamCommandInput,\n    cb: (err: any, data?: DescribeStreamCommandOutput) => void\n  ): void;\n  public describeStream(\n    args: DescribeStreamCommandInput,\n    options: __HttpHandlerOptions,\n    cb: (err: any, data?: DescribeStreamCommandOutput) => void\n  ): void;\n  public describeStream(\n    args: DescribeStreamCommandInput,\n    optionsOrCb?: __HttpHandlerOptions | ((err: any, data?: DescribeStreamCommandOutput) => void),\n    cb?: (err: any, data?: DescribeStreamCommandOutput) => void\n  ): Promise<DescribeStreamCommandOutput> | void {\n    const command = new DescribeStreamCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(`Expect http options but get ${typeof optionsOrCb}`);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  }\n\n  /**\n   * <p>To get the description of a registered consumer, provide the ARN of the consumer.\n   *             Alternatively, you can provide the ARN of the data stream and the name you gave the\n   *             consumer when you registered it. You may also provide all three parameters, as long as\n   *             they don't conflict with each other. If you don't know the name or ARN of the consumer\n   *             that you want to describe, you can use the <a>ListStreamConsumers</a>\n   *             operation to get a list of the descriptions of all the consumers that are currently\n   *             registered with a given data stream.</p>\n   *         <p>This operation has a limit of 20 transactions per second per stream.</p>\n   */\n  public describeStreamConsumer(\n    args: DescribeStreamConsumerCommandInput,\n    options?: __HttpHandlerOptions\n  ): Promise<DescribeStreamConsumerCommandOutput>;\n  public describeStreamConsumer(\n    args: DescribeStreamConsumerCommandInput,\n    cb: (err: any, data?: DescribeStreamConsumerCommandOutput) => void\n  ): void;\n  public describeStreamConsumer(\n    args: DescribeStreamConsumerCommandInput,\n    options: __HttpHandlerOptions,\n    cb: (err: any, data?: DescribeStreamConsumerCommandOutput) => void\n  ): void;\n  public describeStreamConsumer(\n    args: DescribeStreamConsumerCommandInput,\n    optionsOrCb?: __HttpHandlerOptions | ((err: any, data?: DescribeStreamConsumerCommandOutput) => void),\n    cb?: (err: any, data?: DescribeStreamConsumerCommandOutput) => void\n  ): Promise<DescribeStreamConsumerCommandOutput> | void {\n    const command = new DescribeStreamConsumerCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(`Expect http options but get ${typeof optionsOrCb}`);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  }\n\n  /**\n   * <p>Provides a summarized description of the specified Kinesis data stream without the\n   *             shard list.</p>\n   *         <p>The information returned includes the stream name, Amazon Resource Name (ARN),\n   *             status, record retention period, approximate creation time, monitoring, encryption\n   *             details, and open shard count. </p>\n   *         <p>\n   *             <a>DescribeStreamSummary</a> has a limit of 20 transactions per second\n   *             per account.</p>\n   */\n  public describeStreamSummary(\n    args: DescribeStreamSummaryCommandInput,\n    options?: __HttpHandlerOptions\n  ): Promise<DescribeStreamSummaryCommandOutput>;\n  public describeStreamSummary(\n    args: DescribeStreamSummaryCommandInput,\n    cb: (err: any, data?: DescribeStreamSummaryCommandOutput) => void\n  ): void;\n  public describeStreamSummary(\n    args: DescribeStreamSummaryCommandInput,\n    options: __HttpHandlerOptions,\n    cb: (err: any, data?: DescribeStreamSummaryCommandOutput) => void\n  ): void;\n  public describeStreamSummary(\n    args: DescribeStreamSummaryCommandInput,\n    optionsOrCb?: __HttpHandlerOptions | ((err: any, data?: DescribeStreamSummaryCommandOutput) => void),\n    cb?: (err: any, data?: DescribeStreamSummaryCommandOutput) => void\n  ): Promise<DescribeStreamSummaryCommandOutput> | void {\n    const command = new DescribeStreamSummaryCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(`Expect http options but get ${typeof optionsOrCb}`);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  }\n\n  /**\n   * <p>Disables enhanced monitoring.</p>\n   */\n  public disableEnhancedMonitoring(\n    args: DisableEnhancedMonitoringCommandInput,\n    options?: __HttpHandlerOptions\n  ): Promise<DisableEnhancedMonitoringCommandOutput>;\n  public disableEnhancedMonitoring(\n    args: DisableEnhancedMonitoringCommandInput,\n    cb: (err: any, data?: DisableEnhancedMonitoringCommandOutput) => void\n  ): void;\n  public disableEnhancedMonitoring(\n    args: DisableEnhancedMonitoringCommandInput,\n    options: __HttpHandlerOptions,\n    cb: (err: any, data?: DisableEnhancedMonitoringCommandOutput) => void\n  ): void;\n  public disableEnhancedMonitoring(\n    args: DisableEnhancedMonitoringCommandInput,\n    optionsOrCb?: __HttpHandlerOptions | ((err: any, data?: DisableEnhancedMonitoringCommandOutput) => void),\n    cb?: (err: any, data?: DisableEnhancedMonitoringCommandOutput) => void\n  ): Promise<DisableEnhancedMonitoringCommandOutput> | void {\n    const command = new DisableEnhancedMonitoringCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(`Expect http options but get ${typeof optionsOrCb}`);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  }\n\n  /**\n   * <p>Enables enhanced Kinesis data stream monitoring for shard-level metrics.</p>\n   */\n  public enableEnhancedMonitoring(\n    args: EnableEnhancedMonitoringCommandInput,\n    options?: __HttpHandlerOptions\n  ): Promise<EnableEnhancedMonitoringCommandOutput>;\n  public enableEnhancedMonitoring(\n    args: EnableEnhancedMonitoringCommandInput,\n    cb: (err: any, data?: EnableEnhancedMonitoringCommandOutput) => void\n  ): void;\n  public enableEnhancedMonitoring(\n    args: EnableEnhancedMonitoringCommandInput,\n    options: __HttpHandlerOptions,\n    cb: (err: any, data?: EnableEnhancedMonitoringCommandOutput) => void\n  ): void;\n  public enableEnhancedMonitoring(\n    args: EnableEnhancedMonitoringCommandInput,\n    optionsOrCb?: __HttpHandlerOptions | ((err: any, data?: EnableEnhancedMonitoringCommandOutput) => void),\n    cb?: (err: any, data?: EnableEnhancedMonitoringCommandOutput) => void\n  ): Promise<EnableEnhancedMonitoringCommandOutput> | void {\n    const command = new EnableEnhancedMonitoringCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(`Expect http options but get ${typeof optionsOrCb}`);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  }\n\n  /**\n   * <p>Gets data records from a Kinesis data stream's shard.</p>\n   *         <p>Specify a shard iterator using the <code>ShardIterator</code> parameter. The shard\n   *             iterator specifies the position in the shard from which you want to start reading data\n   *             records sequentially. If there are no records available in the portion of the shard that\n   *             the iterator points to, <a>GetRecords</a> returns an empty list. It might\n   *             take multiple calls to get to a portion of the shard that contains records.</p>\n   *         <p>You can scale by provisioning multiple shards per stream while considering service\n   *             limits (for more information, see <a href=\"https://docs.aws.amazon.com/kinesis/latest/dev/service-sizes-and-limits.html\">Amazon Kinesis Data Streams\n   *                 Limits</a> in the <i>Amazon Kinesis Data Streams Developer\n   *                 Guide</i>). Your application should have one thread per shard, each reading\n   *             continuously from its stream. To read from a stream continually, call <a>GetRecords</a> in a loop. Use <a>GetShardIterator</a> to get the\n   *             shard iterator to specify in the first <a>GetRecords</a> call. <a>GetRecords</a> returns a new shard iterator in\n   *                 <code>NextShardIterator</code>. Specify the shard iterator returned in\n   *                 <code>NextShardIterator</code> in subsequent calls to <a>GetRecords</a>.\n   *             If the shard has been closed, the shard iterator can't return more data and <a>GetRecords</a> returns <code>null</code> in <code>NextShardIterator</code>.\n   *             You can terminate the loop when the shard is closed, or when the shard iterator reaches\n   *             the record with the sequence number or other attribute that marks it as the last record\n   *             to process.</p>\n   *         <p>Each data record can be up to 1 MiB in size, and each shard can read up to 2 MiB\n   *             per second. You can ensure that your calls don't exceed the maximum supported size or\n   *             throughput by using the <code>Limit</code> parameter to specify the maximum number of\n   *             records that <a>GetRecords</a> can return. Consider your average record size\n   *             when determining this limit. The maximum number of records that can be returned per call\n   *             is 10,000.</p>\n   *\n   *         <p>The size of the data returned by <a>GetRecords</a> varies depending on\n   *             the utilization of the shard. The maximum size of data that <a>GetRecords</a>\n   *             can return is 10 MiB. If a call returns this amount of data, subsequent calls made\n   *             within the next 5 seconds throw <code>ProvisionedThroughputExceededException</code>. If\n   *             there is insufficient provisioned throughput on the stream, subsequent calls made within\n   *             the next 1 second throw <code>ProvisionedThroughputExceededException</code>. <a>GetRecords</a> doesn't return any data when it throws an exception. For this\n   *             reason, we recommend that you wait 1 second between calls to <a>GetRecords</a>. However, it's possible that the application will get exceptions for longer than 1\n   *             second.</p>\n   *         <p>To detect whether the application is falling behind in processing, you can use the\n   *                 <code>MillisBehindLatest</code> response attribute. You can also monitor the stream\n   *             using CloudWatch metrics and other mechanisms (see <a href=\"https://docs.aws.amazon.com/kinesis/latest/dev/monitoring.html\">Monitoring</a> in the <i>Amazon\n   *                 Kinesis Data Streams Developer Guide</i>).</p>\n   *         <p>Each Amazon Kinesis record includes a value,\n   *                 <code>ApproximateArrivalTimestamp</code>, that is set when a stream successfully\n   *             receives and stores a record. This is commonly referred to as a server-side time stamp,\n   *             whereas a client-side time stamp is set when a data producer creates or sends the record\n   *             to a stream (a data producer is any data source putting data records into a stream, for\n   *             example with <a>PutRecords</a>). The time stamp has millisecond precision.\n   *             There are no guarantees about the time stamp accuracy, or that the time stamp is always\n   *             increasing. For example, records in a shard or across a stream might have time stamps\n   *             that are out of order.</p>\n   *         <p>This operation has a limit of five transactions per second per shard.</p>\n   */\n  public getRecords(args: GetRecordsCommandInput, options?: __HttpHandlerOptions): Promise<GetRecordsCommandOutput>;\n  public getRecords(args: GetRecordsCommandInput, cb: (err: any, data?: GetRecordsCommandOutput) => void): void;\n  public getRecords(\n    args: GetRecordsCommandInput,\n    options: __HttpHandlerOptions,\n    cb: (err: any, data?: GetRecordsCommandOutput) => void\n  ): void;\n  public getRecords(\n    args: GetRecordsCommandInput,\n    optionsOrCb?: __HttpHandlerOptions | ((err: any, data?: GetRecordsCommandOutput) => void),\n    cb?: (err: any, data?: GetRecordsCommandOutput) => void\n  ): Promise<GetRecordsCommandOutput> | void {\n    const command = new GetRecordsCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(`Expect http options but get ${typeof optionsOrCb}`);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  }\n\n  /**\n   * <p>Gets an Amazon Kinesis shard iterator. A shard iterator expires 5 minutes after it\n   *             is returned to the requester.</p>\n   *         <p>A shard iterator specifies the shard position from which to start reading data\n   *             records sequentially. The position is specified using the sequence number of a data\n   *             record in a shard. A sequence number is the identifier associated with every record\n   *             ingested in the stream, and is assigned when a record is put into the stream. Each\n   *             stream has one or more shards.</p>\n   *         <p>You must specify the shard iterator type. For example, you can set the\n   *                 <code>ShardIteratorType</code> parameter to read exactly from the position denoted\n   *             by a specific sequence number by using the <code>AT_SEQUENCE_NUMBER</code> shard\n   *             iterator type. Alternatively, the parameter can read right after the sequence number by\n   *             using the <code>AFTER_SEQUENCE_NUMBER</code> shard iterator type, using sequence numbers\n   *             returned by earlier calls to <a>PutRecord</a>, <a>PutRecords</a>,\n   *                 <a>GetRecords</a>, or <a>DescribeStream</a>. In the request,\n   *             you can specify the shard iterator type <code>AT_TIMESTAMP</code> to read records from\n   *             an arbitrary point in time, <code>TRIM_HORIZON</code> to cause\n   *                 <code>ShardIterator</code> to point to the last untrimmed record in the shard in the\n   *             system (the oldest data record in the shard), or <code>LATEST</code> so that you always\n   *             read the most recent data in the shard. </p>\n   *         <p>When you read repeatedly from a stream, use a <a>GetShardIterator</a>\n   *             request to get the first shard iterator for use in your first <a>GetRecords</a> request and for subsequent reads use the shard iterator returned by the <a>GetRecords</a> request in <code>NextShardIterator</code>. A new shard\n   *             iterator is returned by every <a>GetRecords</a> request in\n   *                 <code>NextShardIterator</code>, which you use in the <code>ShardIterator</code>\n   *             parameter of the next <a>GetRecords</a> request. </p>\n   *         <p>If a <a>GetShardIterator</a> request is made too often, you receive a\n   *                 <code>ProvisionedThroughputExceededException</code>. For more information about\n   *             throughput limits, see <a>GetRecords</a>, and <a href=\"https://docs.aws.amazon.com/kinesis/latest/dev/service-sizes-and-limits.html\">Streams Limits</a> in the\n   *                 <i>Amazon Kinesis Data Streams Developer Guide</i>.</p>\n   *         <p>If the shard is closed, <a>GetShardIterator</a> returns a valid iterator\n   *             for the last sequence number of the shard. A shard can be closed as a result of using\n   *                 <a>SplitShard</a> or <a>MergeShards</a>.</p>\n   *         <p>\n   *             <a>GetShardIterator</a> has a limit of five transactions per second per\n   *             account per open shard.</p>\n   */\n  public getShardIterator(\n    args: GetShardIteratorCommandInput,\n    options?: __HttpHandlerOptions\n  ): Promise<GetShardIteratorCommandOutput>;\n  public getShardIterator(\n    args: GetShardIteratorCommandInput,\n    cb: (err: any, data?: GetShardIteratorCommandOutput) => void\n  ): void;\n  public getShardIterator(\n    args: GetShardIteratorCommandInput,\n    options: __HttpHandlerOptions,\n    cb: (err: any, data?: GetShardIteratorCommandOutput) => void\n  ): void;\n  public getShardIterator(\n    args: GetShardIteratorCommandInput,\n    optionsOrCb?: __HttpHandlerOptions | ((err: any, data?: GetShardIteratorCommandOutput) => void),\n    cb?: (err: any, data?: GetShardIteratorCommandOutput) => void\n  ): Promise<GetShardIteratorCommandOutput> | void {\n    const command = new GetShardIteratorCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(`Expect http options but get ${typeof optionsOrCb}`);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  }\n\n  /**\n   * <p>Increases the Kinesis data stream's retention period, which is the length of time\n   *             data records are accessible after they are added to the stream. The maximum value of a\n   *             stream's retention period is 168 hours (7 days).</p>\n   *         <p>If you choose a longer stream retention period, this operation increases the time\n   *             period during which records that have not yet expired are accessible. However, it does\n   *             not make previous, expired data (older than the stream's previous retention period)\n   *             accessible after the operation has been called. For example, if a stream's retention\n   *             period is set to 24 hours and is increased to 168 hours, any data that is older than 24\n   *             hours remains inaccessible to consumer applications.</p>\n   */\n  public increaseStreamRetentionPeriod(\n    args: IncreaseStreamRetentionPeriodCommandInput,\n    options?: __HttpHandlerOptions\n  ): Promise<IncreaseStreamRetentionPeriodCommandOutput>;\n  public increaseStreamRetentionPeriod(\n    args: IncreaseStreamRetentionPeriodCommandInput,\n    cb: (err: any, data?: IncreaseStreamRetentionPeriodCommandOutput) => void\n  ): void;\n  public increaseStreamRetentionPeriod(\n    args: IncreaseStreamRetentionPeriodCommandInput,\n    options: __HttpHandlerOptions,\n    cb: (err: any, data?: IncreaseStreamRetentionPeriodCommandOutput) => void\n  ): void;\n  public increaseStreamRetentionPeriod(\n    args: IncreaseStreamRetentionPeriodCommandInput,\n    optionsOrCb?: __HttpHandlerOptions | ((err: any, data?: IncreaseStreamRetentionPeriodCommandOutput) => void),\n    cb?: (err: any, data?: IncreaseStreamRetentionPeriodCommandOutput) => void\n  ): Promise<IncreaseStreamRetentionPeriodCommandOutput> | void {\n    const command = new IncreaseStreamRetentionPeriodCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(`Expect http options but get ${typeof optionsOrCb}`);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  }\n\n  /**\n   * <p>Lists the shards in a stream and provides information about each shard. This\n   *             operation has a limit of 100 transactions per second per data stream.</p>\n   *         <important>\n   *             <p>This API is a new operation that is used by the Amazon Kinesis Client Library\n   *                 (KCL). If you have a fine-grained IAM policy that only allows specific operations,\n   *                 you must update your policy to allow calls to this API. For more information, see\n   *                     <a href=\"https://docs.aws.amazon.com/streams/latest/dev/controlling-access.html\">Controlling Access to Amazon Kinesis Data Streams Resources Using\n   *                 IAM</a>.</p>\n   *         </important>\n   */\n  public listShards(args: ListShardsCommandInput, options?: __HttpHandlerOptions): Promise<ListShardsCommandOutput>;\n  public listShards(args: ListShardsCommandInput, cb: (err: any, data?: ListShardsCommandOutput) => void): void;\n  public listShards(\n    args: ListShardsCommandInput,\n    options: __HttpHandlerOptions,\n    cb: (err: any, data?: ListShardsCommandOutput) => void\n  ): void;\n  public listShards(\n    args: ListShardsCommandInput,\n    optionsOrCb?: __HttpHandlerOptions | ((err: any, data?: ListShardsCommandOutput) => void),\n    cb?: (err: any, data?: ListShardsCommandOutput) => void\n  ): Promise<ListShardsCommandOutput> | void {\n    const command = new ListShardsCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(`Expect http options but get ${typeof optionsOrCb}`);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  }\n\n  /**\n   * <p>Lists the consumers registered to receive data from a stream using enhanced fan-out,\n   *             and provides information about each consumer.</p>\n   *         <p>This operation has a limit of 5 transactions per second per stream.</p>\n   */\n  public listStreamConsumers(\n    args: ListStreamConsumersCommandInput,\n    options?: __HttpHandlerOptions\n  ): Promise<ListStreamConsumersCommandOutput>;\n  public listStreamConsumers(\n    args: ListStreamConsumersCommandInput,\n    cb: (err: any, data?: ListStreamConsumersCommandOutput) => void\n  ): void;\n  public listStreamConsumers(\n    args: ListStreamConsumersCommandInput,\n    options: __HttpHandlerOptions,\n    cb: (err: any, data?: ListStreamConsumersCommandOutput) => void\n  ): void;\n  public listStreamConsumers(\n    args: ListStreamConsumersCommandInput,\n    optionsOrCb?: __HttpHandlerOptions | ((err: any, data?: ListStreamConsumersCommandOutput) => void),\n    cb?: (err: any, data?: ListStreamConsumersCommandOutput) => void\n  ): Promise<ListStreamConsumersCommandOutput> | void {\n    const command = new ListStreamConsumersCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(`Expect http options but get ${typeof optionsOrCb}`);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  }\n\n  /**\n   * <p>Lists your Kinesis data streams.</p>\n   *         <p>The number of streams may be too large to return from a single call to\n   *                 <code>ListStreams</code>. You can limit the number of returned streams using the\n   *                 <code>Limit</code> parameter. If you do not specify a value for the\n   *                 <code>Limit</code> parameter, Kinesis Data Streams uses the default limit, which is\n   *             currently 10.</p>\n   *         <p>You can detect if there are more streams available to list by using the\n   *                 <code>HasMoreStreams</code> flag from the returned output. If there are more streams\n   *             available, you can request more streams by using the name of the last stream returned by\n   *             the <code>ListStreams</code> request in the <code>ExclusiveStartStreamName</code>\n   *             parameter in a subsequent request to <code>ListStreams</code>. The group of stream names\n   *             returned by the subsequent request is then added to the list. You can continue this\n   *             process until all the stream names have been collected in the list. </p>\n   *         <p>\n   *             <a>ListStreams</a> has a limit of five transactions per second per\n   *             account.</p>\n   */\n  public listStreams(args: ListStreamsCommandInput, options?: __HttpHandlerOptions): Promise<ListStreamsCommandOutput>;\n  public listStreams(args: ListStreamsCommandInput, cb: (err: any, data?: ListStreamsCommandOutput) => void): void;\n  public listStreams(\n    args: ListStreamsCommandInput,\n    options: __HttpHandlerOptions,\n    cb: (err: any, data?: ListStreamsCommandOutput) => void\n  ): void;\n  public listStreams(\n    args: ListStreamsCommandInput,\n    optionsOrCb?: __HttpHandlerOptions | ((err: any, data?: ListStreamsCommandOutput) => void),\n    cb?: (err: any, data?: ListStreamsCommandOutput) => void\n  ): Promise<ListStreamsCommandOutput> | void {\n    const command = new ListStreamsCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(`Expect http options but get ${typeof optionsOrCb}`);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  }\n\n  /**\n   * <p>Lists the tags for the specified Kinesis data stream. This operation has a limit of\n   *             five transactions per second per account.</p>\n   */\n  public listTagsForStream(\n    args: ListTagsForStreamCommandInput,\n    options?: __HttpHandlerOptions\n  ): Promise<ListTagsForStreamCommandOutput>;\n  public listTagsForStream(\n    args: ListTagsForStreamCommandInput,\n    cb: (err: any, data?: ListTagsForStreamCommandOutput) => void\n  ): void;\n  public listTagsForStream(\n    args: ListTagsForStreamCommandInput,\n    options: __HttpHandlerOptions,\n    cb: (err: any, data?: ListTagsForStreamCommandOutput) => void\n  ): void;\n  public listTagsForStream(\n    args: ListTagsForStreamCommandInput,\n    optionsOrCb?: __HttpHandlerOptions | ((err: any, data?: ListTagsForStreamCommandOutput) => void),\n    cb?: (err: any, data?: ListTagsForStreamCommandOutput) => void\n  ): Promise<ListTagsForStreamCommandOutput> | void {\n    const command = new ListTagsForStreamCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(`Expect http options but get ${typeof optionsOrCb}`);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  }\n\n  /**\n   * <p>Merges two adjacent shards in a Kinesis data stream and combines them into a single\n   *             shard to reduce the stream's capacity to ingest and transport data. Two shards are\n   *             considered adjacent if the union of the hash key ranges for the two shards form a\n   *             contiguous set with no gaps. For example, if you have two shards, one with a hash key\n   *             range of 276...381 and the other with a hash key range of 382...454, then you could\n   *             merge these two shards into a single shard that would have a hash key range of\n   *             276...454. After the merge, the single child shard receives data for all hash key values\n   *             covered by the two parent shards.</p>\n   *         <p>\n   *             <code>MergeShards</code> is called when there is a need to reduce the overall capacity\n   *             of a stream because of excess capacity that is not being used. You must specify the\n   *             shard to be merged and the adjacent shard for a stream. For more information about\n   *             merging shards, see <a href=\"https://docs.aws.amazon.com/kinesis/latest/dev/kinesis-using-sdk-java-resharding-merge.html\">Merge Two\n   *                 Shards</a> in the <i>Amazon Kinesis Data Streams Developer\n   *                 Guide</i>.</p>\n   *         <p>If the stream is in the <code>ACTIVE</code> state, you can call\n   *                 <code>MergeShards</code>. If a stream is in the <code>CREATING</code>,\n   *                 <code>UPDATING</code>, or <code>DELETING</code> state, <code>MergeShards</code>\n   *             returns a <code>ResourceInUseException</code>. If the specified stream does not exist,\n   *                 <code>MergeShards</code> returns a <code>ResourceNotFoundException</code>. </p>\n   *         <p>You can use <a>DescribeStream</a> to check the state of the stream,\n   *             which is returned in <code>StreamStatus</code>.</p>\n   *         <p>\n   *             <code>MergeShards</code> is an asynchronous operation. Upon receiving a\n   *                 <code>MergeShards</code> request, Amazon Kinesis Data Streams immediately returns a\n   *             response and sets the <code>StreamStatus</code> to <code>UPDATING</code>. After the\n   *             operation is completed, Kinesis Data Streams sets the <code>StreamStatus</code> to\n   *                 <code>ACTIVE</code>. Read and write operations continue to work while the stream is\n   *             in the <code>UPDATING</code> state. </p>\n   *         <p>You use <a>DescribeStream</a> to determine the shard IDs that are\n   *             specified in the <code>MergeShards</code> request. </p>\n   *         <p>If you try to operate on too many streams in parallel using <a>CreateStream</a>, <a>DeleteStream</a>, <code>MergeShards</code>,\n   *             or <a>SplitShard</a>, you receive a <code>LimitExceededException</code>. </p>\n   *         <p>\n   *             <code>MergeShards</code> has a limit of five transactions per second per\n   *             account.</p>\n   */\n  public mergeShards(args: MergeShardsCommandInput, options?: __HttpHandlerOptions): Promise<MergeShardsCommandOutput>;\n  public mergeShards(args: MergeShardsCommandInput, cb: (err: any, data?: MergeShardsCommandOutput) => void): void;\n  public mergeShards(\n    args: MergeShardsCommandInput,\n    options: __HttpHandlerOptions,\n    cb: (err: any, data?: MergeShardsCommandOutput) => void\n  ): void;\n  public mergeShards(\n    args: MergeShardsCommandInput,\n    optionsOrCb?: __HttpHandlerOptions | ((err: any, data?: MergeShardsCommandOutput) => void),\n    cb?: (err: any, data?: MergeShardsCommandOutput) => void\n  ): Promise<MergeShardsCommandOutput> | void {\n    const command = new MergeShardsCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(`Expect http options but get ${typeof optionsOrCb}`);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  }\n\n  /**\n   * <p>Writes a single data record into an Amazon Kinesis data stream. Call\n   *                 <code>PutRecord</code> to send data into the stream for real-time ingestion and\n   *             subsequent processing, one record at a time. Each shard can support writes up to 1,000\n   *             records per second, up to a maximum data write total of 1 MiB per second.</p>\n   *         <p>You must specify the name of the stream that captures, stores, and transports the\n   *             data; a partition key; and the data blob itself.</p>\n   *         <p>The data blob can be any type of data; for example, a segment from a log file,\n   *             geographic/location data, website clickstream data, and so on.</p>\n   *         <p>The partition key is used by Kinesis Data Streams to distribute data across shards.\n   *             Kinesis Data Streams segregates the data records that belong to a stream into multiple\n   *             shards, using the partition key associated with each data record to determine the shard\n   *             to which a given data record belongs.</p>\n   *         <p>Partition keys are Unicode strings, with a maximum length limit of 256 characters\n   *             for each key. An MD5 hash function is used to map partition keys to 128-bit integer\n   *             values and to map associated data records to shards using the hash key ranges of the\n   *             shards. You can override hashing the partition key to determine the shard by explicitly\n   *             specifying a hash value using the <code>ExplicitHashKey</code> parameter. For more\n   *             information, see <a href=\"https://docs.aws.amazon.com/kinesis/latest/dev/developing-producers-with-sdk.html#kinesis-using-sdk-java-add-data-to-stream\">Adding Data to a Stream</a> in the <i>Amazon Kinesis Data Streams\n   *                 Developer Guide</i>.</p>\n   *         <p>\n   *             <code>PutRecord</code> returns the shard ID of where the data record was placed and the\n   *             sequence number that was assigned to the data record.</p>\n   *         <p>Sequence numbers increase over time and are specific to a shard within a stream,\n   *             not across all shards within a stream. To guarantee strictly increasing ordering, write\n   *             serially to a shard and use the <code>SequenceNumberForOrdering</code> parameter. For\n   *             more information, see <a href=\"https://docs.aws.amazon.com/kinesis/latest/dev/developing-producers-with-sdk.html#kinesis-using-sdk-java-add-data-to-stream\">Adding Data to a Stream</a> in the <i>Amazon Kinesis Data Streams\n   *                 Developer Guide</i>.</p>\n   *         <important>\n   *             <p>After you write a record to a stream, you cannot modify that record or its order\n   *                 within the stream.</p>\n   *         </important>\n   *         <p>If a <code>PutRecord</code> request cannot be processed because of insufficient\n   *             provisioned throughput on the shard involved in the request, <code>PutRecord</code>\n   *             throws <code>ProvisionedThroughputExceededException</code>. </p>\n   *         <p>By default, data records are accessible for 24 hours from the time that they are\n   *             added to a stream. You can use <a>IncreaseStreamRetentionPeriod</a> or <a>DecreaseStreamRetentionPeriod</a> to modify this retention period.</p>\n   */\n  public putRecord(args: PutRecordCommandInput, options?: __HttpHandlerOptions): Promise<PutRecordCommandOutput>;\n  public putRecord(args: PutRecordCommandInput, cb: (err: any, data?: PutRecordCommandOutput) => void): void;\n  public putRecord(\n    args: PutRecordCommandInput,\n    options: __HttpHandlerOptions,\n    cb: (err: any, data?: PutRecordCommandOutput) => void\n  ): void;\n  public putRecord(\n    args: PutRecordCommandInput,\n    optionsOrCb?: __HttpHandlerOptions | ((err: any, data?: PutRecordCommandOutput) => void),\n    cb?: (err: any, data?: PutRecordCommandOutput) => void\n  ): Promise<PutRecordCommandOutput> | void {\n    const command = new PutRecordCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(`Expect http options but get ${typeof optionsOrCb}`);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  }\n\n  /**\n   * <p>Writes multiple data records into a Kinesis data stream in a single call (also\n   *             referred to as a <code>PutRecords</code> request). Use this operation to send data into\n   *             the stream for data ingestion and processing. </p>\n   *         <p>Each <code>PutRecords</code> request can support up to 500 records. Each record in\n   *             the request can be as large as 1 MiB, up to a limit of 5 MiB for the entire request,\n   *             including partition keys. Each shard can support writes up to 1,000 records per second,\n   *             up to a maximum data write total of 1 MiB per second.</p>\n   *         <p>You must specify the name of the stream that captures, stores, and transports the\n   *             data; and an array of request <code>Records</code>, with each record in the array\n   *             requiring a partition key and data blob. The record size limit applies to the total size\n   *             of the partition key and data blob.</p>\n   *         <p>The data blob can be any type of data; for example, a segment from a log file,\n   *             geographic/location data, website clickstream data, and so on.</p>\n   *         <p>The partition key is used by Kinesis Data Streams as input to a hash function that\n   *             maps the partition key and associated data to a specific shard. An MD5 hash function is\n   *             used to map partition keys to 128-bit integer values and to map associated data records\n   *             to shards. As a result of this hashing mechanism, all data records with the same\n   *             partition key map to the same shard within the stream. For more information, see <a href=\"https://docs.aws.amazon.com/kinesis/latest/dev/developing-producers-with-sdk.html#kinesis-using-sdk-java-add-data-to-stream\">Adding Data to a Stream</a> in the <i>Amazon Kinesis Data Streams\n   *                 Developer Guide</i>.</p>\n   *         <p>Each record in the <code>Records</code> array may include an optional parameter,\n   *                 <code>ExplicitHashKey</code>, which overrides the partition key to shard mapping.\n   *             This parameter allows a data producer to determine explicitly the shard where the record\n   *             is stored. For more information, see <a href=\"https://docs.aws.amazon.com/kinesis/latest/dev/developing-producers-with-sdk.html#kinesis-using-sdk-java-putrecords\">Adding Multiple Records with PutRecords</a> in the <i>Amazon Kinesis\n   *                 Data Streams Developer Guide</i>.</p>\n   *         <p>The <code>PutRecords</code> response includes an array of response\n   *                 <code>Records</code>. Each record in the response array directly correlates with a\n   *             record in the request array using natural ordering, from the top to the bottom of the\n   *             request and response. The response <code>Records</code> array always includes the same\n   *             number of records as the request array.</p>\n   *         <p>The response <code>Records</code> array includes both successfully and\n   *             unsuccessfully processed records. Kinesis Data Streams attempts to process all records\n   *             in each <code>PutRecords</code> request. A single record failure does not stop the\n   *             processing of subsequent records. As a result, PutRecords doesn't guarantee the ordering\n   *             of records. If you need to read records in the same order they are written to the\n   *             stream, use <a>PutRecord</a> instead of <code>PutRecords</code>, and write to\n   *             the same shard.</p>\n   *         <p>A successfully processed record includes <code>ShardId</code> and\n   *                 <code>SequenceNumber</code> values. The <code>ShardId</code> parameter identifies\n   *             the shard in the stream where the record is stored. The <code>SequenceNumber</code>\n   *             parameter is an identifier assigned to the put record, unique to all records in the\n   *             stream.</p>\n   *         <p>An unsuccessfully processed record includes <code>ErrorCode</code> and\n   *                 <code>ErrorMessage</code> values. <code>ErrorCode</code> reflects the type of error\n   *             and can be one of the following values:\n   *                 <code>ProvisionedThroughputExceededException</code> or <code>InternalFailure</code>.\n   *                 <code>ErrorMessage</code> provides more detailed information about the\n   *                 <code>ProvisionedThroughputExceededException</code> exception including the account\n   *             ID, stream name, and shard ID of the record that was throttled. For more information\n   *             about partially successful responses, see <a href=\"https://docs.aws.amazon.com/kinesis/latest/dev/kinesis-using-sdk-java-add-data-to-stream.html#kinesis-using-sdk-java-putrecords\">Adding Multiple Records with PutRecords</a> in the <i>Amazon Kinesis\n   *                 Data Streams Developer Guide</i>.</p>\n   *         <important>\n   *             <p>After you write a record to a stream, you cannot modify that record or its order\n   *                 within the stream.</p>\n   *         </important>\n   *         <p>By default, data records are accessible for 24 hours from the time that they are\n   *             added to a stream. You can use <a>IncreaseStreamRetentionPeriod</a> or <a>DecreaseStreamRetentionPeriod</a> to modify this retention period.</p>\n   */\n  public putRecords(args: PutRecordsCommandInput, options?: __HttpHandlerOptions): Promise<PutRecordsCommandOutput>;\n  public putRecords(args: PutRecordsCommandInput, cb: (err: any, data?: PutRecordsCommandOutput) => void): void;\n  public putRecords(\n    args: PutRecordsCommandInput,\n    options: __HttpHandlerOptions,\n    cb: (err: any, data?: PutRecordsCommandOutput) => void\n  ): void;\n  public putRecords(\n    args: PutRecordsCommandInput,\n    optionsOrCb?: __HttpHandlerOptions | ((err: any, data?: PutRecordsCommandOutput) => void),\n    cb?: (err: any, data?: PutRecordsCommandOutput) => void\n  ): Promise<PutRecordsCommandOutput> | void {\n    const command = new PutRecordsCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(`Expect http options but get ${typeof optionsOrCb}`);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  }\n\n  /**\n   * <p>Registers a consumer with a Kinesis data stream. When you use this operation, the\n   *             consumer you register can then call <a>SubscribeToShard</a> to receive data\n   *             from the stream using enhanced fan-out, at a rate of up to 2 MiB per second for every\n   *             shard you subscribe to. This rate is unaffected by the total number of consumers that\n   *             read from the same stream.</p>\n   *         <p>You can register up to 20 consumers per stream. A given consumer can only be\n   *             registered with one stream at a time.</p>\n   *         <p>For an example of how to use this operations, see <a href=\"/streams/latest/dev/building-enhanced-consumers-api.html\">Enhanced Fan-Out\n   *                 Using the Kinesis Data Streams API</a>.</p>\n   *         <p>The use of this operation has a limit of five transactions per second per account.\n   *             Also, only 5 consumers can be created simultaneously. In other words, you cannot have\n   *             more than 5 consumers in a <code>CREATING</code> status at the same time. Registering a\n   *             6th consumer while there are 5 in a <code>CREATING</code> status results in a\n   *                 <code>LimitExceededException</code>.</p>\n   */\n  public registerStreamConsumer(\n    args: RegisterStreamConsumerCommandInput,\n    options?: __HttpHandlerOptions\n  ): Promise<RegisterStreamConsumerCommandOutput>;\n  public registerStreamConsumer(\n    args: RegisterStreamConsumerCommandInput,\n    cb: (err: any, data?: RegisterStreamConsumerCommandOutput) => void\n  ): void;\n  public registerStreamConsumer(\n    args: RegisterStreamConsumerCommandInput,\n    options: __HttpHandlerOptions,\n    cb: (err: any, data?: RegisterStreamConsumerCommandOutput) => void\n  ): void;\n  public registerStreamConsumer(\n    args: RegisterStreamConsumerCommandInput,\n    optionsOrCb?: __HttpHandlerOptions | ((err: any, data?: RegisterStreamConsumerCommandOutput) => void),\n    cb?: (err: any, data?: RegisterStreamConsumerCommandOutput) => void\n  ): Promise<RegisterStreamConsumerCommandOutput> | void {\n    const command = new RegisterStreamConsumerCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(`Expect http options but get ${typeof optionsOrCb}`);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  }\n\n  /**\n   * <p>Removes tags from the specified Kinesis data stream. Removed tags are deleted and\n   *             cannot be recovered after this operation successfully completes.</p>\n   *         <p>If you specify a tag that does not exist, it is ignored.</p>\n   *         <p>\n   *             <a>RemoveTagsFromStream</a> has a limit of five transactions per second per\n   *             account.</p>\n   */\n  public removeTagsFromStream(\n    args: RemoveTagsFromStreamCommandInput,\n    options?: __HttpHandlerOptions\n  ): Promise<RemoveTagsFromStreamCommandOutput>;\n  public removeTagsFromStream(\n    args: RemoveTagsFromStreamCommandInput,\n    cb: (err: any, data?: RemoveTagsFromStreamCommandOutput) => void\n  ): void;\n  public removeTagsFromStream(\n    args: RemoveTagsFromStreamCommandInput,\n    options: __HttpHandlerOptions,\n    cb: (err: any, data?: RemoveTagsFromStreamCommandOutput) => void\n  ): void;\n  public removeTagsFromStream(\n    args: RemoveTagsFromStreamCommandInput,\n    optionsOrCb?: __HttpHandlerOptions | ((err: any, data?: RemoveTagsFromStreamCommandOutput) => void),\n    cb?: (err: any, data?: RemoveTagsFromStreamCommandOutput) => void\n  ): Promise<RemoveTagsFromStreamCommandOutput> | void {\n    const command = new RemoveTagsFromStreamCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(`Expect http options but get ${typeof optionsOrCb}`);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  }\n\n  /**\n   * <p>Splits a shard into two new shards in the Kinesis data stream, to increase the\n   *             stream's capacity to ingest and transport data. <code>SplitShard</code> is called when\n   *             there is a need to increase the overall capacity of a stream because of an expected\n   *             increase in the volume of data records being ingested. </p>\n   *         <p>You can also use <code>SplitShard</code> when a shard appears to be approaching its\n   *             maximum utilization; for example, the producers sending data into the specific shard are\n   *             suddenly sending more than previously anticipated. You can also call\n   *                 <code>SplitShard</code> to increase stream capacity, so that more Kinesis Data\n   *             Streams applications can simultaneously read data from the stream for real-time\n   *             processing. </p>\n   *         <p>You must specify the shard to be split and the new hash key, which is the position\n   *             in the shard where the shard gets split in two. In many cases, the new hash key might be\n   *             the average of the beginning and ending hash key, but it can be any hash key value in\n   *             the range being mapped into the shard. For more information, see <a href=\"https://docs.aws.amazon.com/kinesis/latest/dev/kinesis-using-sdk-java-resharding-split.html\">Split a\n   *                 Shard</a> in the <i>Amazon Kinesis Data Streams Developer\n   *                 Guide</i>.</p>\n   *         <p>You can use <a>DescribeStream</a> to determine the shard ID and hash key\n   *             values for the <code>ShardToSplit</code> and <code>NewStartingHashKey</code> parameters\n   *             that are specified in the <code>SplitShard</code> request.</p>\n   *         <p>\n   *             <code>SplitShard</code> is an asynchronous operation. Upon receiving a\n   *                 <code>SplitShard</code> request, Kinesis Data Streams immediately returns a response\n   *             and sets the stream status to <code>UPDATING</code>. After the operation is completed,\n   *             Kinesis Data Streams sets the stream status to <code>ACTIVE</code>. Read and write\n   *             operations continue to work while the stream is in the <code>UPDATING</code> state. </p>\n   *         <p>You can use <code>DescribeStream</code> to check the status of the stream, which is\n   *             returned in <code>StreamStatus</code>. If the stream is in the <code>ACTIVE</code>\n   *             state, you can call <code>SplitShard</code>. If a stream is in <code>CREATING</code> or\n   *                 <code>UPDATING</code> or <code>DELETING</code> states, <code>DescribeStream</code>\n   *             returns a <code>ResourceInUseException</code>.</p>\n   *         <p>If the specified stream does not exist, <code>DescribeStream</code> returns a\n   *                 <code>ResourceNotFoundException</code>. If you try to create more shards than are\n   *             authorized for your account, you receive a <code>LimitExceededException</code>. </p>\n   *         <p>For the default shard limit for an AWS account, see <a href=\"https://docs.aws.amazon.com/kinesis/latest/dev/service-sizes-and-limits.html\">Kinesis Data Streams\n   *                 Limits</a> in the <i>Amazon Kinesis Data Streams Developer\n   *                 Guide</i>. To increase this limit, <a href=\"https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html\">contact AWS\n   *             Support</a>.</p>\n   *         <p>If you try to operate on too many streams simultaneously using <a>CreateStream</a>, <a>DeleteStream</a>, <a>MergeShards</a>, and/or <a>SplitShard</a>, you receive a\n   *                 <code>LimitExceededException</code>. </p>\n   *         <p>\n   *             <code>SplitShard</code> has a limit of five transactions per second per\n   *             account.</p>\n   */\n  public splitShard(args: SplitShardCommandInput, options?: __HttpHandlerOptions): Promise<SplitShardCommandOutput>;\n  public splitShard(args: SplitShardCommandInput, cb: (err: any, data?: SplitShardCommandOutput) => void): void;\n  public splitShard(\n    args: SplitShardCommandInput,\n    options: __HttpHandlerOptions,\n    cb: (err: any, data?: SplitShardCommandOutput) => void\n  ): void;\n  public splitShard(\n    args: SplitShardCommandInput,\n    optionsOrCb?: __HttpHandlerOptions | ((err: any, data?: SplitShardCommandOutput) => void),\n    cb?: (err: any, data?: SplitShardCommandOutput) => void\n  ): Promise<SplitShardCommandOutput> | void {\n    const command = new SplitShardCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(`Expect http options but get ${typeof optionsOrCb}`);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  }\n\n  /**\n   * <p>Enables or updates server-side encryption using an AWS KMS key for a specified\n   *             stream. </p>\n   *         <p>Starting encryption is an asynchronous operation. Upon receiving the request,\n   *             Kinesis Data Streams returns immediately and sets the status of the stream to\n   *                 <code>UPDATING</code>. After the update is complete, Kinesis Data Streams sets the\n   *             status of the stream back to <code>ACTIVE</code>. Updating or applying encryption\n   *             normally takes a few seconds to complete, but it can take minutes. You can continue to\n   *             read and write data to your stream while its status is <code>UPDATING</code>. Once the\n   *             status of the stream is <code>ACTIVE</code>, encryption begins for records written to\n   *             the stream. </p>\n   *         <p>API Limits: You can successfully apply a new AWS KMS key for server-side encryption\n   *             25 times in a rolling 24-hour period.</p>\n   *         <p>Note: It can take up to 5 seconds after the stream is in an <code>ACTIVE</code>\n   *             status before all records written to the stream are encrypted. After you enable\n   *             encryption, you can verify that encryption is applied by inspecting the API response\n   *             from <code>PutRecord</code> or <code>PutRecords</code>.</p>\n   */\n  public startStreamEncryption(\n    args: StartStreamEncryptionCommandInput,\n    options?: __HttpHandlerOptions\n  ): Promise<StartStreamEncryptionCommandOutput>;\n  public startStreamEncryption(\n    args: StartStreamEncryptionCommandInput,\n    cb: (err: any, data?: StartStreamEncryptionCommandOutput) => void\n  ): void;\n  public startStreamEncryption(\n    args: StartStreamEncryptionCommandInput,\n    options: __HttpHandlerOptions,\n    cb: (err: any, data?: StartStreamEncryptionCommandOutput) => void\n  ): void;\n  public startStreamEncryption(\n    args: StartStreamEncryptionCommandInput,\n    optionsOrCb?: __HttpHandlerOptions | ((err: any, data?: StartStreamEncryptionCommandOutput) => void),\n    cb?: (err: any, data?: StartStreamEncryptionCommandOutput) => void\n  ): Promise<StartStreamEncryptionCommandOutput> | void {\n    const command = new StartStreamEncryptionCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(`Expect http options but get ${typeof optionsOrCb}`);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  }\n\n  /**\n   * <p>Disables server-side encryption for a specified stream. </p>\n   *         <p>Stopping encryption is an asynchronous operation. Upon receiving the request,\n   *             Kinesis Data Streams returns immediately and sets the status of the stream to\n   *                 <code>UPDATING</code>. After the update is complete, Kinesis Data Streams sets the\n   *             status of the stream back to <code>ACTIVE</code>. Stopping encryption normally takes a\n   *             few seconds to complete, but it can take minutes. You can continue to read and write\n   *             data to your stream while its status is <code>UPDATING</code>. Once the status of the\n   *             stream is <code>ACTIVE</code>, records written to the stream are no longer encrypted by\n   *             Kinesis Data Streams. </p>\n   *         <p>API Limits: You can successfully disable server-side encryption 25 times in a\n   *             rolling 24-hour period. </p>\n   *         <p>Note: It can take up to 5 seconds after the stream is in an <code>ACTIVE</code>\n   *             status before all records written to the stream are no longer subject to encryption.\n   *             After you disabled encryption, you can verify that encryption is not applied by\n   *             inspecting the API response from <code>PutRecord</code> or\n   *             <code>PutRecords</code>.</p>\n   */\n  public stopStreamEncryption(\n    args: StopStreamEncryptionCommandInput,\n    options?: __HttpHandlerOptions\n  ): Promise<StopStreamEncryptionCommandOutput>;\n  public stopStreamEncryption(\n    args: StopStreamEncryptionCommandInput,\n    cb: (err: any, data?: StopStreamEncryptionCommandOutput) => void\n  ): void;\n  public stopStreamEncryption(\n    args: StopStreamEncryptionCommandInput,\n    options: __HttpHandlerOptions,\n    cb: (err: any, data?: StopStreamEncryptionCommandOutput) => void\n  ): void;\n  public stopStreamEncryption(\n    args: StopStreamEncryptionCommandInput,\n    optionsOrCb?: __HttpHandlerOptions | ((err: any, data?: StopStreamEncryptionCommandOutput) => void),\n    cb?: (err: any, data?: StopStreamEncryptionCommandOutput) => void\n  ): Promise<StopStreamEncryptionCommandOutput> | void {\n    const command = new StopStreamEncryptionCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(`Expect http options but get ${typeof optionsOrCb}`);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  }\n\n  /**\n   * <p>This operation establishes an HTTP/2 connection between the consumer you specify in\n   *             the <code>ConsumerARN</code> parameter and the shard you specify in the\n   *                 <code>ShardId</code> parameter. After the connection is successfully established,\n   *             Kinesis Data Streams pushes records from the shard to the consumer over this connection.\n   *             Before you call this operation, call <a>RegisterStreamConsumer</a> to\n   *             register the consumer with Kinesis Data Streams.</p>\n   *         <p>When the <code>SubscribeToShard</code> call succeeds, your consumer starts receiving\n   *             events of type <a>SubscribeToShardEvent</a> over the HTTP/2 connection for up\n   *             to 5 minutes, after which time you need to call <code>SubscribeToShard</code> again to\n   *             renew the subscription if you want to continue to receive records.</p>\n   *         <p>You can make one call to <code>SubscribeToShard</code> per second per registered\n   *             consumer per shard. For example, if you have a 4000 shard stream and two registered\n   *             stream consumers, you can make one <code>SubscribeToShard</code> request per second for\n   *             each combination of shard and registered consumer, allowing you to subscribe both\n   *             consumers to all 4000 shards in one second. </p>\n   *         <p>If you call <code>SubscribeToShard</code> again with the same <code>ConsumerARN</code>\n   *             and <code>ShardId</code> within 5 seconds of a successful call, you'll get a\n   *                 <code>ResourceInUseException</code>. If you call <code>SubscribeToShard</code> 5\n   *             seconds or more after a successful call, the first connection will expire and the second\n   *             call will take over the subscription.</p>\n   *         <p>For an example of how to use this operations, see <a href=\"/streams/latest/dev/building-enhanced-consumers-api.html\">Enhanced Fan-Out\n   *                 Using the Kinesis Data Streams API</a>.</p>\n   */\n  public subscribeToShard(\n    args: SubscribeToShardCommandInput,\n    options?: __HttpHandlerOptions\n  ): Promise<SubscribeToShardCommandOutput>;\n  public subscribeToShard(\n    args: SubscribeToShardCommandInput,\n    cb: (err: any, data?: SubscribeToShardCommandOutput) => void\n  ): void;\n  public subscribeToShard(\n    args: SubscribeToShardCommandInput,\n    options: __HttpHandlerOptions,\n    cb: (err: any, data?: SubscribeToShardCommandOutput) => void\n  ): void;\n  public subscribeToShard(\n    args: SubscribeToShardCommandInput,\n    optionsOrCb?: __HttpHandlerOptions | ((err: any, data?: SubscribeToShardCommandOutput) => void),\n    cb?: (err: any, data?: SubscribeToShardCommandOutput) => void\n  ): Promise<SubscribeToShardCommandOutput> | void {\n    const command = new SubscribeToShardCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(`Expect http options but get ${typeof optionsOrCb}`);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  }\n\n  /**\n   * <p>Updates the shard count of the specified stream to the specified number of\n   *             shards.</p>\n   *         <p>Updating the shard count is an asynchronous operation. Upon receiving the request,\n   *             Kinesis Data Streams returns immediately and sets the status of the stream to\n   *                 <code>UPDATING</code>. After the update is complete, Kinesis Data Streams sets the\n   *             status of the stream back to <code>ACTIVE</code>. Depending on the size of the stream,\n   *             the scaling action could take a few minutes to complete. You can continue to read and\n   *             write data to your stream while its status is <code>UPDATING</code>.</p>\n   *         <p>To update the shard count, Kinesis Data Streams performs splits or merges on\n   *             individual shards. This can cause short-lived shards to be created, in addition to the\n   *             final shards. These short-lived shards count towards your total shard limit for your\n   *             account in the Region.</p>\n   *         <p>When using this operation, we recommend that you specify a target shard count that\n   *             is a multiple of 25% (25%, 50%, 75%, 100%). You can specify any target value within your\n   *             shard limit. However, if you specify a target that isn't a multiple of 25%, the scaling\n   *             action might take longer to complete. </p>\n   *         <p>This operation has the following default limits. By default, you cannot do the\n   *             following:</p>\n   *         <ul>\n   *             <li>\n   *                 <p>Scale more than ten times per rolling 24-hour period per stream</p>\n   *             </li>\n   *             <li>\n   *                 <p>Scale up to more than double your current shard count for a\n   *                     stream</p>\n   *             </li>\n   *             <li>\n   *                 <p>Scale down below half your current shard count for a stream</p>\n   *             </li>\n   *             <li>\n   *                 <p>Scale up to more than 500 shards in a stream</p>\n   *             </li>\n   *             <li>\n   *                 <p>Scale a stream with more than 500 shards down unless the result is less\n   *                     than 500 shards</p>\n   *             </li>\n   *             <li>\n   *                 <p>Scale up to more than the shard limit for your account</p>\n   *             </li>\n   *          </ul>\n   *         <p>For the default limits for an AWS account, see <a href=\"https://docs.aws.amazon.com/kinesis/latest/dev/service-sizes-and-limits.html\">Streams Limits</a> in the\n   *                 <i>Amazon Kinesis Data Streams Developer Guide</i>. To request an\n   *             increase in the call rate limit, the shard limit for this API, or your overall shard\n   *             limit, use the <a href=\"https://console.aws.amazon.com/support/v1#/case/create?issueType=service-limit-increase&limitType=service-code-kinesis\">limits form</a>.</p>\n   */\n  public updateShardCount(\n    args: UpdateShardCountCommandInput,\n    options?: __HttpHandlerOptions\n  ): Promise<UpdateShardCountCommandOutput>;\n  public updateShardCount(\n    args: UpdateShardCountCommandInput,\n    cb: (err: any, data?: UpdateShardCountCommandOutput) => void\n  ): void;\n  public updateShardCount(\n    args: UpdateShardCountCommandInput,\n    options: __HttpHandlerOptions,\n    cb: (err: any, data?: UpdateShardCountCommandOutput) => void\n  ): void;\n  public updateShardCount(\n    args: UpdateShardCountCommandInput,\n    optionsOrCb?: __HttpHandlerOptions | ((err: any, data?: UpdateShardCountCommandOutput) => void),\n    cb?: (err: any, data?: UpdateShardCountCommandOutput) => void\n  ): Promise<UpdateShardCountCommandOutput> | void {\n    const command = new UpdateShardCountCommand(args);\n    if (typeof optionsOrCb === \"function\") {\n      this.send(command, optionsOrCb);\n    } else if (typeof cb === \"function\") {\n      if (typeof optionsOrCb !== \"object\") throw new Error(`Expect http options but get ${typeof optionsOrCb}`);\n      this.send(command, optionsOrCb || {}, cb);\n    } else {\n      return this.send(command, optionsOrCb);\n    }\n  }\n}\n"],"mappings":";AAAA,SAASA,aAAa,QAAQ,iBAAiB;AAC/C,SACEC,sBAAsB,QAGjB,mCAAmC;AAC1C,SACEC,mBAAmB,QAGd,gCAAgC;AACvC,SACEC,oCAAoC,QAG/B,iDAAiD;AACxD,SACEC,mBAAmB,QAGd,gCAAgC;AACvC,SACEC,+BAA+B,QAG1B,4CAA4C;AACnD,SACEC,qBAAqB,QAGhB,kCAAkC;AACzC,SACEC,qBAAqB,QAGhB,kCAAkC;AACzC,SACEC,6BAA6B,QAGxB,0CAA0C;AACjD,SACEC,4BAA4B,QAGvB,yCAAyC;AAChD,SACEC,gCAAgC,QAG3B,6CAA6C;AACpD,SACEC,+BAA+B,QAG1B,4CAA4C;AACnD,SAASC,iBAAiB,QAAyD,8BAA8B;AACjH,SACEC,uBAAuB,QAGlB,oCAAoC;AAC3C,SACEC,oCAAoC,QAG/B,iDAAiD;AACxD,SAASC,iBAAiB,QAAyD,8BAA8B;AACjH,SACEC,0BAA0B,QAGrB,uCAAuC;AAC9C,SAASC,kBAAkB,QAA2D,+BAA+B;AACrH,SACEC,wBAAwB,QAGnB,qCAAqC;AAC5C,SAASC,kBAAkB,QAA2D,+BAA+B;AACrH,SAASC,gBAAgB,QAAuD,6BAA6B;AAC7G,SAASC,iBAAiB,QAAyD,8BAA8B;AACjH,SACEC,6BAA6B,QAGxB,0CAA0C;AACjD,SACEC,2BAA2B,QAGtB,wCAAwC;AAC/C,SAASC,iBAAiB,QAAyD,8BAA8B;AACjH,SACEC,4BAA4B,QAGvB,yCAAyC;AAChD,SACEC,2BAA2B,QAGtB,wCAAwC;AAC/C,SACEC,uBAAuB,QAGlB,oCAAoC;AAC3C,SACEC,uBAAuB,QAGlB,oCAAoC;AAG3C;;;;;AAKA,IAAAC,OAAA,0BAAAC,MAAA;EAA6BC,SAAA,CAAAF,OAAA,EAAAC,MAAA;EAA7B,SAAAD,QAAA;;EAs0CA;EA7yCSA,OAAA,CAAAG,SAAA,CAAAC,eAAe,GAAtB,UACEC,IAAiC,EACjCC,WAA8F,EAC9FC,EAA4D;IAE5D,IAAMC,OAAO,GAAG,IAAIpC,sBAAsB,CAACiC,IAAI,CAAC;IAChD,IAAI,OAAOC,WAAW,KAAK,UAAU,EAAE;MACrC,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;KAChC,MAAM,IAAI,OAAOC,EAAE,KAAK,UAAU,EAAE;MACnC,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE,MAAM,IAAII,KAAK,CAAC,iCAA+B,OAAOJ,WAAa,CAAC;MACzG,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,IAAI,EAAE,EAAEC,EAAE,CAAC;KAC1C,MAAM;MACL,OAAO,IAAI,CAACE,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;;EAE1C,CAAC;EAuDMN,OAAA,CAAAG,SAAA,CAAAQ,YAAY,GAAnB,UACEN,IAA8B,EAC9BC,WAA2F,EAC3FC,EAAyD;IAEzD,IAAMC,OAAO,GAAG,IAAInC,mBAAmB,CAACgC,IAAI,CAAC;IAC7C,IAAI,OAAOC,WAAW,KAAK,UAAU,EAAE;MACrC,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;KAChC,MAAM,IAAI,OAAOC,EAAE,KAAK,UAAU,EAAE;MACnC,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE,MAAM,IAAII,KAAK,CAAC,iCAA+B,OAAOJ,WAAa,CAAC;MACzG,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,IAAI,EAAE,EAAEC,EAAE,CAAC;KAC1C,MAAM;MACL,OAAO,IAAI,CAACE,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;;EAE1C,CAAC;EAuBMN,OAAA,CAAAG,SAAA,CAAAS,6BAA6B,GAApC,UACEP,IAA+C,EAC/CC,WAA4G,EAC5GC,EAA0E;IAE1E,IAAMC,OAAO,GAAG,IAAIlC,oCAAoC,CAAC+B,IAAI,CAAC;IAC9D,IAAI,OAAOC,WAAW,KAAK,UAAU,EAAE;MACrC,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;KAChC,MAAM,IAAI,OAAOC,EAAE,KAAK,UAAU,EAAE;MACnC,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE,MAAM,IAAII,KAAK,CAAC,iCAA+B,OAAOJ,WAAa,CAAC;MACzG,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,IAAI,EAAE,EAAEC,EAAE,CAAC;KAC1C,MAAM;MACL,OAAO,IAAI,CAACE,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;;EAE1C,CAAC;EAiCMN,OAAA,CAAAG,SAAA,CAAAU,YAAY,GAAnB,UACER,IAA8B,EAC9BC,WAA2F,EAC3FC,EAAyD;IAEzD,IAAMC,OAAO,GAAG,IAAIjC,mBAAmB,CAAC8B,IAAI,CAAC;IAC7C,IAAI,OAAOC,WAAW,KAAK,UAAU,EAAE;MACrC,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;KAChC,MAAM,IAAI,OAAOC,EAAE,KAAK,UAAU,EAAE;MACnC,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE,MAAM,IAAII,KAAK,CAAC,iCAA+B,OAAOJ,WAAa,CAAC;MACzG,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,IAAI,EAAE,EAAEC,EAAE,CAAC;KAC1C,MAAM;MACL,OAAO,IAAI,CAACE,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;;EAE1C,CAAC;EAyBMN,OAAA,CAAAG,SAAA,CAAAW,wBAAwB,GAA/B,UACET,IAA0C,EAC1CC,WAAuG,EACvGC,EAAqE;IAErE,IAAMC,OAAO,GAAG,IAAIhC,+BAA+B,CAAC6B,IAAI,CAAC;IACzD,IAAI,OAAOC,WAAW,KAAK,UAAU,EAAE;MACrC,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;KAChC,MAAM,IAAI,OAAOC,EAAE,KAAK,UAAU,EAAE;MACnC,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE,MAAM,IAAII,KAAK,CAAC,iCAA+B,OAAOJ,WAAa,CAAC;MACzG,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,IAAI,EAAE,EAAEC,EAAE,CAAC;KAC1C,MAAM;MACL,OAAO,IAAI,CAACE,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;;EAE1C,CAAC;EAqBMN,OAAA,CAAAG,SAAA,CAAAY,cAAc,GAArB,UACEV,IAAgC,EAChCC,WAA6F,EAC7FC,EAA2D;IAE3D,IAAMC,OAAO,GAAG,IAAI/B,qBAAqB,CAAC4B,IAAI,CAAC;IAC/C,IAAI,OAAOC,WAAW,KAAK,UAAU,EAAE;MACrC,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;KAChC,MAAM,IAAI,OAAOC,EAAE,KAAK,UAAU,EAAE;MACnC,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE,MAAM,IAAII,KAAK,CAAC,iCAA+B,OAAOJ,WAAa,CAAC;MACzG,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,IAAI,EAAE,EAAEC,EAAE,CAAC;KAC1C,MAAM;MACL,OAAO,IAAI,CAACE,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;;EAE1C,CAAC;EAkCMN,OAAA,CAAAG,SAAA,CAAAa,cAAc,GAArB,UACEX,IAAgC,EAChCC,WAA6F,EAC7FC,EAA2D;IAE3D,IAAMC,OAAO,GAAG,IAAI9B,qBAAqB,CAAC2B,IAAI,CAAC;IAC/C,IAAI,OAAOC,WAAW,KAAK,UAAU,EAAE;MACrC,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;KAChC,MAAM,IAAI,OAAOC,EAAE,KAAK,UAAU,EAAE;MACnC,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE,MAAM,IAAII,KAAK,CAAC,iCAA+B,OAAOJ,WAAa,CAAC;MACzG,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,IAAI,EAAE,EAAEC,EAAE,CAAC;KAC1C,MAAM;MACL,OAAO,IAAI,CAACE,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;;EAE1C,CAAC;EAyBMN,OAAA,CAAAG,SAAA,CAAAc,sBAAsB,GAA7B,UACEZ,IAAwC,EACxCC,WAAqG,EACrGC,EAAmE;IAEnE,IAAMC,OAAO,GAAG,IAAI7B,6BAA6B,CAAC0B,IAAI,CAAC;IACvD,IAAI,OAAOC,WAAW,KAAK,UAAU,EAAE;MACrC,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;KAChC,MAAM,IAAI,OAAOC,EAAE,KAAK,UAAU,EAAE;MACnC,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE,MAAM,IAAII,KAAK,CAAC,iCAA+B,OAAOJ,WAAa,CAAC;MACzG,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,IAAI,EAAE,EAAEC,EAAE,CAAC;KAC1C,MAAM;MACL,OAAO,IAAI,CAACE,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;;EAE1C,CAAC;EAyBMN,OAAA,CAAAG,SAAA,CAAAe,qBAAqB,GAA5B,UACEb,IAAuC,EACvCC,WAAoG,EACpGC,EAAkE;IAElE,IAAMC,OAAO,GAAG,IAAI5B,4BAA4B,CAACyB,IAAI,CAAC;IACtD,IAAI,OAAOC,WAAW,KAAK,UAAU,EAAE;MACrC,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;KAChC,MAAM,IAAI,OAAOC,EAAE,KAAK,UAAU,EAAE;MACnC,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE,MAAM,IAAII,KAAK,CAAC,iCAA+B,OAAOJ,WAAa,CAAC;MACzG,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,IAAI,EAAE,EAAEC,EAAE,CAAC;KAC1C,MAAM;MACL,OAAO,IAAI,CAACE,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;;EAE1C,CAAC;EAkBMN,OAAA,CAAAG,SAAA,CAAAgB,yBAAyB,GAAhC,UACEd,IAA2C,EAC3CC,WAAwG,EACxGC,EAAsE;IAEtE,IAAMC,OAAO,GAAG,IAAI3B,gCAAgC,CAACwB,IAAI,CAAC;IAC1D,IAAI,OAAOC,WAAW,KAAK,UAAU,EAAE;MACrC,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;KAChC,MAAM,IAAI,OAAOC,EAAE,KAAK,UAAU,EAAE;MACnC,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE,MAAM,IAAII,KAAK,CAAC,iCAA+B,OAAOJ,WAAa,CAAC;MACzG,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,IAAI,EAAE,EAAEC,EAAE,CAAC;KAC1C,MAAM;MACL,OAAO,IAAI,CAACE,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;;EAE1C,CAAC;EAkBMN,OAAA,CAAAG,SAAA,CAAAiB,wBAAwB,GAA/B,UACEf,IAA0C,EAC1CC,WAAuG,EACvGC,EAAqE;IAErE,IAAMC,OAAO,GAAG,IAAI1B,+BAA+B,CAACuB,IAAI,CAAC;IACzD,IAAI,OAAOC,WAAW,KAAK,UAAU,EAAE;MACrC,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;KAChC,MAAM,IAAI,OAAOC,EAAE,KAAK,UAAU,EAAE;MACnC,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE,MAAM,IAAII,KAAK,CAAC,iCAA+B,OAAOJ,WAAa,CAAC;MACzG,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,IAAI,EAAE,EAAEC,EAAE,CAAC;KAC1C,MAAM;MACL,OAAO,IAAI,CAACE,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;;EAE1C,CAAC;EA0DMN,OAAA,CAAAG,SAAA,CAAAkB,UAAU,GAAjB,UACEhB,IAA4B,EAC5BC,WAAyF,EACzFC,EAAuD;IAEvD,IAAMC,OAAO,GAAG,IAAIzB,iBAAiB,CAACsB,IAAI,CAAC;IAC3C,IAAI,OAAOC,WAAW,KAAK,UAAU,EAAE;MACrC,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;KAChC,MAAM,IAAI,OAAOC,EAAE,KAAK,UAAU,EAAE;MACnC,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE,MAAM,IAAII,KAAK,CAAC,iCAA+B,OAAOJ,WAAa,CAAC;MACzG,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,IAAI,EAAE,EAAEC,EAAE,CAAC;KAC1C,MAAM;MACL,OAAO,IAAI,CAACE,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;;EAE1C,CAAC;EAmDMN,OAAA,CAAAG,SAAA,CAAAmB,gBAAgB,GAAvB,UACEjB,IAAkC,EAClCC,WAA+F,EAC/FC,EAA6D;IAE7D,IAAMC,OAAO,GAAG,IAAIxB,uBAAuB,CAACqB,IAAI,CAAC;IACjD,IAAI,OAAOC,WAAW,KAAK,UAAU,EAAE;MACrC,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;KAChC,MAAM,IAAI,OAAOC,EAAE,KAAK,UAAU,EAAE;MACnC,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE,MAAM,IAAII,KAAK,CAAC,iCAA+B,OAAOJ,WAAa,CAAC;MACzG,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,IAAI,EAAE,EAAEC,EAAE,CAAC;KAC1C,MAAM;MACL,OAAO,IAAI,CAACE,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;;EAE1C,CAAC;EA0BMN,OAAA,CAAAG,SAAA,CAAAoB,6BAA6B,GAApC,UACElB,IAA+C,EAC/CC,WAA4G,EAC5GC,EAA0E;IAE1E,IAAMC,OAAO,GAAG,IAAIvB,oCAAoC,CAACoB,IAAI,CAAC;IAC9D,IAAI,OAAOC,WAAW,KAAK,UAAU,EAAE;MACrC,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;KAChC,MAAM,IAAI,OAAOC,EAAE,KAAK,UAAU,EAAE;MACnC,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE,MAAM,IAAII,KAAK,CAAC,iCAA+B,OAAOJ,WAAa,CAAC;MACzG,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,IAAI,EAAE,EAAEC,EAAE,CAAC;KAC1C,MAAM;MACL,OAAO,IAAI,CAACE,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;;EAE1C,CAAC;EAoBMN,OAAA,CAAAG,SAAA,CAAAqB,UAAU,GAAjB,UACEnB,IAA4B,EAC5BC,WAAyF,EACzFC,EAAuD;IAEvD,IAAMC,OAAO,GAAG,IAAItB,iBAAiB,CAACmB,IAAI,CAAC;IAC3C,IAAI,OAAOC,WAAW,KAAK,UAAU,EAAE;MACrC,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;KAChC,MAAM,IAAI,OAAOC,EAAE,KAAK,UAAU,EAAE;MACnC,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE,MAAM,IAAII,KAAK,CAAC,iCAA+B,OAAOJ,WAAa,CAAC;MACzG,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,IAAI,EAAE,EAAEC,EAAE,CAAC;KAC1C,MAAM;MACL,OAAO,IAAI,CAACE,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;;EAE1C,CAAC;EAoBMN,OAAA,CAAAG,SAAA,CAAAsB,mBAAmB,GAA1B,UACEpB,IAAqC,EACrCC,WAAkG,EAClGC,EAAgE;IAEhE,IAAMC,OAAO,GAAG,IAAIrB,0BAA0B,CAACkB,IAAI,CAAC;IACpD,IAAI,OAAOC,WAAW,KAAK,UAAU,EAAE;MACrC,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;KAChC,MAAM,IAAI,OAAOC,EAAE,KAAK,UAAU,EAAE;MACnC,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE,MAAM,IAAII,KAAK,CAAC,iCAA+B,OAAOJ,WAAa,CAAC;MACzG,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,IAAI,EAAE,EAAEC,EAAE,CAAC;KAC1C,MAAM;MACL,OAAO,IAAI,CAACE,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;;EAE1C,CAAC;EA2BMN,OAAA,CAAAG,SAAA,CAAAuB,WAAW,GAAlB,UACErB,IAA6B,EAC7BC,WAA0F,EAC1FC,EAAwD;IAExD,IAAMC,OAAO,GAAG,IAAIpB,kBAAkB,CAACiB,IAAI,CAAC;IAC5C,IAAI,OAAOC,WAAW,KAAK,UAAU,EAAE;MACrC,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;KAChC,MAAM,IAAI,OAAOC,EAAE,KAAK,UAAU,EAAE;MACnC,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE,MAAM,IAAII,KAAK,CAAC,iCAA+B,OAAOJ,WAAa,CAAC;MACzG,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,IAAI,EAAE,EAAEC,EAAE,CAAC;KAC1C,MAAM;MACL,OAAO,IAAI,CAACE,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;;EAE1C,CAAC;EAmBMN,OAAA,CAAAG,SAAA,CAAAwB,iBAAiB,GAAxB,UACEtB,IAAmC,EACnCC,WAAgG,EAChGC,EAA8D;IAE9D,IAAMC,OAAO,GAAG,IAAInB,wBAAwB,CAACgB,IAAI,CAAC;IAClD,IAAI,OAAOC,WAAW,KAAK,UAAU,EAAE;MACrC,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;KAChC,MAAM,IAAI,OAAOC,EAAE,KAAK,UAAU,EAAE;MACnC,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE,MAAM,IAAII,KAAK,CAAC,iCAA+B,OAAOJ,WAAa,CAAC;MACzG,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,IAAI,EAAE,EAAEC,EAAE,CAAC;KAC1C,MAAM;MACL,OAAO,IAAI,CAACE,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;;EAE1C,CAAC;EA+CMN,OAAA,CAAAG,SAAA,CAAAyB,WAAW,GAAlB,UACEvB,IAA6B,EAC7BC,WAA0F,EAC1FC,EAAwD;IAExD,IAAMC,OAAO,GAAG,IAAIlB,kBAAkB,CAACe,IAAI,CAAC;IAC5C,IAAI,OAAOC,WAAW,KAAK,UAAU,EAAE;MACrC,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;KAChC,MAAM,IAAI,OAAOC,EAAE,KAAK,UAAU,EAAE;MACnC,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE,MAAM,IAAII,KAAK,CAAC,iCAA+B,OAAOJ,WAAa,CAAC;MACzG,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,IAAI,EAAE,EAAEC,EAAE,CAAC;KAC1C,MAAM;MACL,OAAO,IAAI,CAACE,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;;EAE1C,CAAC;EA+CMN,OAAA,CAAAG,SAAA,CAAA0B,SAAS,GAAhB,UACExB,IAA2B,EAC3BC,WAAwF,EACxFC,EAAsD;IAEtD,IAAMC,OAAO,GAAG,IAAIjB,gBAAgB,CAACc,IAAI,CAAC;IAC1C,IAAI,OAAOC,WAAW,KAAK,UAAU,EAAE;MACrC,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;KAChC,MAAM,IAAI,OAAOC,EAAE,KAAK,UAAU,EAAE;MACnC,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE,MAAM,IAAII,KAAK,CAAC,iCAA+B,OAAOJ,WAAa,CAAC;MACzG,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,IAAI,EAAE,EAAEC,EAAE,CAAC;KAC1C,MAAM;MACL,OAAO,IAAI,CAACE,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;;EAE1C,CAAC;EAmEMN,OAAA,CAAAG,SAAA,CAAA2B,UAAU,GAAjB,UACEzB,IAA4B,EAC5BC,WAAyF,EACzFC,EAAuD;IAEvD,IAAMC,OAAO,GAAG,IAAIhB,iBAAiB,CAACa,IAAI,CAAC;IAC3C,IAAI,OAAOC,WAAW,KAAK,UAAU,EAAE;MACrC,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;KAChC,MAAM,IAAI,OAAOC,EAAE,KAAK,UAAU,EAAE;MACnC,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE,MAAM,IAAII,KAAK,CAAC,iCAA+B,OAAOJ,WAAa,CAAC;MACzG,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,IAAI,EAAE,EAAEC,EAAE,CAAC;KAC1C,MAAM;MACL,OAAO,IAAI,CAACE,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;;EAE1C,CAAC;EA+BMN,OAAA,CAAAG,SAAA,CAAA4B,sBAAsB,GAA7B,UACE1B,IAAwC,EACxCC,WAAqG,EACrGC,EAAmE;IAEnE,IAAMC,OAAO,GAAG,IAAIf,6BAA6B,CAACY,IAAI,CAAC;IACvD,IAAI,OAAOC,WAAW,KAAK,UAAU,EAAE;MACrC,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;KAChC,MAAM,IAAI,OAAOC,EAAE,KAAK,UAAU,EAAE;MACnC,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE,MAAM,IAAII,KAAK,CAAC,iCAA+B,OAAOJ,WAAa,CAAC;MACzG,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,IAAI,EAAE,EAAEC,EAAE,CAAC;KAC1C,MAAM;MACL,OAAO,IAAI,CAACE,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;;EAE1C,CAAC;EAuBMN,OAAA,CAAAG,SAAA,CAAA6B,oBAAoB,GAA3B,UACE3B,IAAsC,EACtCC,WAAmG,EACnGC,EAAiE;IAEjE,IAAMC,OAAO,GAAG,IAAId,2BAA2B,CAACW,IAAI,CAAC;IACrD,IAAI,OAAOC,WAAW,KAAK,UAAU,EAAE;MACrC,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;KAChC,MAAM,IAAI,OAAOC,EAAE,KAAK,UAAU,EAAE;MACnC,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE,MAAM,IAAII,KAAK,CAAC,iCAA+B,OAAOJ,WAAa,CAAC;MACzG,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,IAAI,EAAE,EAAEC,EAAE,CAAC;KAC1C,MAAM;MACL,OAAO,IAAI,CAACE,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;;EAE1C,CAAC;EAqDMN,OAAA,CAAAG,SAAA,CAAA8B,UAAU,GAAjB,UACE5B,IAA4B,EAC5BC,WAAyF,EACzFC,EAAuD;IAEvD,IAAMC,OAAO,GAAG,IAAIb,iBAAiB,CAACU,IAAI,CAAC;IAC3C,IAAI,OAAOC,WAAW,KAAK,UAAU,EAAE;MACrC,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;KAChC,MAAM,IAAI,OAAOC,EAAE,KAAK,UAAU,EAAE;MACnC,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE,MAAM,IAAII,KAAK,CAAC,iCAA+B,OAAOJ,WAAa,CAAC;MACzG,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,IAAI,EAAE,EAAEC,EAAE,CAAC;KAC1C,MAAM;MACL,OAAO,IAAI,CAACE,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;;EAE1C,CAAC;EAiCMN,OAAA,CAAAG,SAAA,CAAA+B,qBAAqB,GAA5B,UACE7B,IAAuC,EACvCC,WAAoG,EACpGC,EAAkE;IAElE,IAAMC,OAAO,GAAG,IAAIZ,4BAA4B,CAACS,IAAI,CAAC;IACtD,IAAI,OAAOC,WAAW,KAAK,UAAU,EAAE;MACrC,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;KAChC,MAAM,IAAI,OAAOC,EAAE,KAAK,UAAU,EAAE;MACnC,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE,MAAM,IAAII,KAAK,CAAC,iCAA+B,OAAOJ,WAAa,CAAC;MACzG,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,IAAI,EAAE,EAAEC,EAAE,CAAC;KAC1C,MAAM;MACL,OAAO,IAAI,CAACE,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;;EAE1C,CAAC;EAiCMN,OAAA,CAAAG,SAAA,CAAAgC,oBAAoB,GAA3B,UACE9B,IAAsC,EACtCC,WAAmG,EACnGC,EAAiE;IAEjE,IAAMC,OAAO,GAAG,IAAIX,2BAA2B,CAACQ,IAAI,CAAC;IACrD,IAAI,OAAOC,WAAW,KAAK,UAAU,EAAE;MACrC,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;KAChC,MAAM,IAAI,OAAOC,EAAE,KAAK,UAAU,EAAE;MACnC,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE,MAAM,IAAII,KAAK,CAAC,iCAA+B,OAAOJ,WAAa,CAAC;MACzG,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,IAAI,EAAE,EAAEC,EAAE,CAAC;KAC1C,MAAM;MACL,OAAO,IAAI,CAACE,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;;EAE1C,CAAC;EAuCMN,OAAA,CAAAG,SAAA,CAAAiC,gBAAgB,GAAvB,UACE/B,IAAkC,EAClCC,WAA+F,EAC/FC,EAA6D;IAE7D,IAAMC,OAAO,GAAG,IAAIV,uBAAuB,CAACO,IAAI,CAAC;IACjD,IAAI,OAAOC,WAAW,KAAK,UAAU,EAAE;MACrC,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;KAChC,MAAM,IAAI,OAAOC,EAAE,KAAK,UAAU,EAAE;MACnC,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE,MAAM,IAAII,KAAK,CAAC,iCAA+B,OAAOJ,WAAa,CAAC;MACzG,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,IAAI,EAAE,EAAEC,EAAE,CAAC;KAC1C,MAAM;MACL,OAAO,IAAI,CAACE,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;;EAE1C,CAAC;EA6DMN,OAAA,CAAAG,SAAA,CAAAkC,gBAAgB,GAAvB,UACEhC,IAAkC,EAClCC,WAA+F,EAC/FC,EAA6D;IAE7D,IAAMC,OAAO,GAAG,IAAIT,uBAAuB,CAACM,IAAI,CAAC;IACjD,IAAI,OAAOC,WAAW,KAAK,UAAU,EAAE;MACrC,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;KAChC,MAAM,IAAI,OAAOC,EAAE,KAAK,UAAU,EAAE;MACnC,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE,MAAM,IAAII,KAAK,CAAC,iCAA+B,OAAOJ,WAAa,CAAC;MACzG,IAAI,CAACG,IAAI,CAACD,OAAO,EAAEF,WAAW,IAAI,EAAE,EAAEC,EAAE,CAAC;KAC1C,MAAM;MACL,OAAO,IAAI,CAACE,IAAI,CAACD,OAAO,EAAEF,WAAW,CAAC;;EAE1C,CAAC;EACH,OAAAN,OAAC;AAAD,CAAC,CAt0C4B7B,aAAa"},"metadata":{},"sourceType":"module","externalDependencies":[]}