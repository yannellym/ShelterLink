{"ast":null,"code":"/**\n * Copyright (c) 2017, Philip Walton <philip@philipwalton.com>\n */\nimport { closest } from './closest';\nimport { matches } from './matches';\n/**\n * Delegates the handling of events for an element matching a selector to an\n * ancestor of the matching element.\n * @param {!Node} ancestor The ancestor element to add the listener to.\n * @param {string} eventType The event type to listen to.\n * @param {string} selector A CSS selector to match against child elements.\n * @param {!Function} callback A function to run any time the event happens.\n * @param {Object=} opts A configuration options object. The available options:\n *     - useCapture<boolean>: If true, bind to the event capture phase.\n *     - deep<boolean>: If true, delegate into shadow trees.\n * @return {Object} The delegate object. It contains a destroy method.\n */\nexport function delegate(ancestor, eventType, selector, callback, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  // Defines the event listener.\n  var listener = function (event) {\n    var delegateTarget;\n    // If opts.composed is true and the event originated from inside a Shadow\n    // tree, check the composed path nodes.\n    if (opts['composed'] && typeof event['composedPath'] === 'function') {\n      var composedPath = event.composedPath();\n      for (var i = 0, node = void 0; node = composedPath[i]; i++) {\n        if (node.nodeType === 1 && matches(node, selector)) {\n          delegateTarget = node;\n        }\n      }\n    } else {\n      // Otherwise check the parents.\n      delegateTarget = closest(event.target, selector, true);\n    }\n    if (delegateTarget) {\n      callback.call(delegateTarget, event, delegateTarget);\n    }\n  };\n  ancestor.addEventListener(eventType, listener, opts['useCapture']);\n  return {\n    destroy: function () {\n      ancestor.removeEventListener(eventType, listener, opts['useCapture']);\n    }\n  };\n}","map":{"version":3,"names":["closest","matches","delegate","ancestor","eventType","selector","callback","opts","listener","event","delegateTarget","composedPath","i","node","nodeType","target","call","addEventListener","destroy","removeEventListener"],"sources":["/Users/yannellym/Desktop/iwantapet/node_modules/@aws-amplify/analytics/src/vendor/dom-utils/delegate.ts"],"sourcesContent":["/**\n * Copyright (c) 2017, Philip Walton <philip@philipwalton.com>\n */\n\nimport { closest } from './closest';\nimport { matches } from './matches';\n\n/**\n * Delegates the handling of events for an element matching a selector to an\n * ancestor of the matching element.\n * @param {!Node} ancestor The ancestor element to add the listener to.\n * @param {string} eventType The event type to listen to.\n * @param {string} selector A CSS selector to match against child elements.\n * @param {!Function} callback A function to run any time the event happens.\n * @param {Object=} opts A configuration options object. The available options:\n *     - useCapture<boolean>: If true, bind to the event capture phase.\n *     - deep<boolean>: If true, delegate into shadow trees.\n * @return {Object} The delegate object. It contains a destroy method.\n */\nexport function delegate(ancestor, eventType, selector, callback, opts = {}) {\n\t// Defines the event listener.\n\tconst listener = function(event) {\n\t\tlet delegateTarget;\n\n\t\t// If opts.composed is true and the event originated from inside a Shadow\n\t\t// tree, check the composed path nodes.\n\t\tif (opts['composed'] && typeof event['composedPath'] === 'function') {\n\t\t\tconst composedPath = event.composedPath();\n\t\t\tfor (let i = 0, node; (node = composedPath[i]); i++) {\n\t\t\t\tif (node.nodeType === 1 && matches(node, selector)) {\n\t\t\t\t\tdelegateTarget = node;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Otherwise check the parents.\n\t\t\tdelegateTarget = closest(event.target, selector, true);\n\t\t}\n\n\t\tif (delegateTarget) {\n\t\t\tcallback.call(delegateTarget, event, delegateTarget);\n\t\t}\n\t};\n\n\tancestor.addEventListener(eventType, listener, opts['useCapture']);\n\n\treturn {\n\t\tdestroy: () => {\n\t\t\tancestor.removeEventListener(eventType, listener, opts['useCapture']);\n\t\t},\n\t};\n}\n"],"mappings":"AAAA;;;AAIA,SAASA,OAAO,QAAQ,WAAW;AACnC,SAASC,OAAO,QAAQ,WAAW;AAEnC;;;;;;;;;;;;AAYA,OAAM,SAAUC,QAAQA,CAACC,QAAQ,EAAEC,SAAS,EAAEC,QAAQ,EAAEC,QAAQ,EAAEC,IAAS;EAAT,IAAAA,IAAA;IAAAA,IAAA,KAAS;EAAA;EAC1E;EACA,IAAMC,QAAQ,GAAG,SAAAA,CAASC,KAAK;IAC9B,IAAIC,cAAc;IAElB;IACA;IACA,IAAIH,IAAI,CAAC,UAAU,CAAC,IAAI,OAAOE,KAAK,CAAC,cAAc,CAAC,KAAK,UAAU,EAAE;MACpE,IAAME,YAAY,GAAGF,KAAK,CAACE,YAAY,EAAE;MACzC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,IAAI,WAAGA,IAAI,GAAGF,YAAY,CAACC,CAAC,CAAC,EAAGA,CAAC,EAAE,EAAE;QACpD,IAAIC,IAAI,CAACC,QAAQ,KAAK,CAAC,IAAIb,OAAO,CAACY,IAAI,EAAER,QAAQ,CAAC,EAAE;UACnDK,cAAc,GAAGG,IAAI;;;KAGvB,MAAM;MACN;MACAH,cAAc,GAAGV,OAAO,CAACS,KAAK,CAACM,MAAM,EAAEV,QAAQ,EAAE,IAAI,CAAC;;IAGvD,IAAIK,cAAc,EAAE;MACnBJ,QAAQ,CAACU,IAAI,CAACN,cAAc,EAAED,KAAK,EAAEC,cAAc,CAAC;;EAEtD,CAAC;EAEDP,QAAQ,CAACc,gBAAgB,CAACb,SAAS,EAAEI,QAAQ,EAAED,IAAI,CAAC,YAAY,CAAC,CAAC;EAElE,OAAO;IACNW,OAAO,EAAE,SAAAA,CAAA;MACRf,QAAQ,CAACgB,mBAAmB,CAACf,SAAS,EAAEI,QAAQ,EAAED,IAAI,CAAC,YAAY,CAAC,CAAC;IACtE;GACA;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}