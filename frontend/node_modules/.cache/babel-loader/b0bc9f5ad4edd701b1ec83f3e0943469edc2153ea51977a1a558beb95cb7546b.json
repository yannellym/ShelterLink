{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Framework } from './types';\nimport { detect } from './detection';\n// We want to cache detection since the framework won't change\nvar frameworkCache;\nexport var frameworkChangeObservers = [];\n// Setup the detection reset tracking / timeout delays\nvar resetTriggered = false;\nvar SSR_RESET_TIMEOUT = 10; // ms\nvar WEB_RESET_TIMEOUT = 10; // ms\nvar PRIME_FRAMEWORK_DELAY = 1000; // ms\nexport var detectFramework = function () {\n  if (!frameworkCache) {\n    frameworkCache = detect();\n    if (resetTriggered) {\n      // The final run of detectFramework:\n      // Starting from this point, the `frameworkCache` becomes \"final\".\n      // So we don't need to notify the observers again so the observer\n      // can be removed after the final notice.\n      while (frameworkChangeObservers.length) {\n        frameworkChangeObservers.pop()();\n      }\n    } else {\n      // The first run of detectFramework:\n      // Every time we update the cache, call each observer function\n      frameworkChangeObservers.forEach(function (fcn) {\n        return fcn();\n      });\n    }\n    // Retry once for either Unknown type after a delay (explained below)\n    resetTimeout(Framework.ServerSideUnknown, SSR_RESET_TIMEOUT);\n    resetTimeout(Framework.WebUnknown, WEB_RESET_TIMEOUT);\n  }\n  return frameworkCache;\n};\n/**\n * @internal Setup observer callback that will be called everytime the framework changes\n */\nexport var observeFrameworkChanges = function (fcn) {\n  // When the `frameworkCache` won't be updated again, we ignore all incoming\n  // observers.\n  if (resetTriggered) {\n    return;\n  }\n  frameworkChangeObservers.push(fcn);\n};\nexport function clearCache() {\n  frameworkCache = undefined;\n}\n// For a framework type and a delay amount, setup the event to re-detect\n//   During the runtime boot, it is possible that framework detection will\n//   be triggered before the framework has made modifications to the\n//   global/window/etc needed for detection. When no framework is detected\n//   we will reset and try again to ensure we don't use a cached\n//   non-framework detection result for all requests.\nfunction resetTimeout(framework, delay) {\n  if (frameworkCache === framework && !resetTriggered) {\n    setTimeout(function () {\n      clearCache();\n      resetTriggered = true;\n      setTimeout(detectFramework, PRIME_FRAMEWORK_DELAY);\n    }, delay);\n  }\n}","map":{"version":3,"names":["Framework","detect","frameworkCache","frameworkChangeObservers","resetTriggered","SSR_RESET_TIMEOUT","WEB_RESET_TIMEOUT","PRIME_FRAMEWORK_DELAY","detectFramework","length","pop","forEach","fcn","resetTimeout","ServerSideUnknown","WebUnknown","observeFrameworkChanges","push","clearCache","undefined","framework","delay","setTimeout"],"sources":["/Users/yannellym/Desktop/iwantapet/node_modules/@aws-amplify/core/lib-esm/Platform/detectFramework.js"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Framework } from './types';\nimport { detect } from './detection';\n// We want to cache detection since the framework won't change\nvar frameworkCache;\nexport var frameworkChangeObservers = [];\n// Setup the detection reset tracking / timeout delays\nvar resetTriggered = false;\nvar SSR_RESET_TIMEOUT = 10; // ms\nvar WEB_RESET_TIMEOUT = 10; // ms\nvar PRIME_FRAMEWORK_DELAY = 1000; // ms\nexport var detectFramework = function () {\n    if (!frameworkCache) {\n        frameworkCache = detect();\n        if (resetTriggered) {\n            // The final run of detectFramework:\n            // Starting from this point, the `frameworkCache` becomes \"final\".\n            // So we don't need to notify the observers again so the observer\n            // can be removed after the final notice.\n            while (frameworkChangeObservers.length) {\n                frameworkChangeObservers.pop()();\n            }\n        }\n        else {\n            // The first run of detectFramework:\n            // Every time we update the cache, call each observer function\n            frameworkChangeObservers.forEach(function (fcn) { return fcn(); });\n        }\n        // Retry once for either Unknown type after a delay (explained below)\n        resetTimeout(Framework.ServerSideUnknown, SSR_RESET_TIMEOUT);\n        resetTimeout(Framework.WebUnknown, WEB_RESET_TIMEOUT);\n    }\n    return frameworkCache;\n};\n/**\n * @internal Setup observer callback that will be called everytime the framework changes\n */\nexport var observeFrameworkChanges = function (fcn) {\n    // When the `frameworkCache` won't be updated again, we ignore all incoming\n    // observers.\n    if (resetTriggered) {\n        return;\n    }\n    frameworkChangeObservers.push(fcn);\n};\nexport function clearCache() {\n    frameworkCache = undefined;\n}\n// For a framework type and a delay amount, setup the event to re-detect\n//   During the runtime boot, it is possible that framework detection will\n//   be triggered before the framework has made modifications to the\n//   global/window/etc needed for detection. When no framework is detected\n//   we will reset and try again to ensure we don't use a cached\n//   non-framework detection result for all requests.\nfunction resetTimeout(framework, delay) {\n    if (frameworkCache === framework && !resetTriggered) {\n        setTimeout(function () {\n            clearCache();\n            resetTriggered = true;\n            setTimeout(detectFramework, PRIME_FRAMEWORK_DELAY);\n        }, delay);\n    }\n}\n"],"mappings":"AAAA;AACA;AACA,SAASA,SAAS,QAAQ,SAAS;AACnC,SAASC,MAAM,QAAQ,aAAa;AACpC;AACA,IAAIC,cAAc;AAClB,OAAO,IAAIC,wBAAwB,GAAG,EAAE;AACxC;AACA,IAAIC,cAAc,GAAG,KAAK;AAC1B,IAAIC,iBAAiB,GAAG,EAAE,CAAC,CAAC;AAC5B,IAAIC,iBAAiB,GAAG,EAAE,CAAC,CAAC;AAC5B,IAAIC,qBAAqB,GAAG,IAAI,CAAC,CAAC;AAClC,OAAO,IAAIC,eAAe,GAAG,SAAAA,CAAA,EAAY;EACrC,IAAI,CAACN,cAAc,EAAE;IACjBA,cAAc,GAAGD,MAAM,CAAC,CAAC;IACzB,IAAIG,cAAc,EAAE;MAChB;MACA;MACA;MACA;MACA,OAAOD,wBAAwB,CAACM,MAAM,EAAE;QACpCN,wBAAwB,CAACO,GAAG,CAAC,CAAC,CAAC,CAAC;MACpC;IACJ,CAAC,MACI;MACD;MACA;MACAP,wBAAwB,CAACQ,OAAO,CAAC,UAAUC,GAAG,EAAE;QAAE,OAAOA,GAAG,CAAC,CAAC;MAAE,CAAC,CAAC;IACtE;IACA;IACAC,YAAY,CAACb,SAAS,CAACc,iBAAiB,EAAET,iBAAiB,CAAC;IAC5DQ,YAAY,CAACb,SAAS,CAACe,UAAU,EAAET,iBAAiB,CAAC;EACzD;EACA,OAAOJ,cAAc;AACzB,CAAC;AACD;AACA;AACA;AACA,OAAO,IAAIc,uBAAuB,GAAG,SAAAA,CAAUJ,GAAG,EAAE;EAChD;EACA;EACA,IAAIR,cAAc,EAAE;IAChB;EACJ;EACAD,wBAAwB,CAACc,IAAI,CAACL,GAAG,CAAC;AACtC,CAAC;AACD,OAAO,SAASM,UAAUA,CAAA,EAAG;EACzBhB,cAAc,GAAGiB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASN,YAAYA,CAACO,SAAS,EAAEC,KAAK,EAAE;EACpC,IAAInB,cAAc,KAAKkB,SAAS,IAAI,CAAChB,cAAc,EAAE;IACjDkB,UAAU,CAAC,YAAY;MACnBJ,UAAU,CAAC,CAAC;MACZd,cAAc,GAAG,IAAI;MACrBkB,UAAU,CAACd,eAAe,EAAED,qBAAqB,CAAC;IACtD,CAAC,EAAEc,KAAK,CAAC;EACb;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}