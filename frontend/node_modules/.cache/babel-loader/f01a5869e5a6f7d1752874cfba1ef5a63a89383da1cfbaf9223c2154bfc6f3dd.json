{"ast":null,"code":"import { __assign, __awaiter, __generator, __read, __rest, __values } from \"tslib\";\nimport { InternalAPI } from '@aws-amplify/api/internals';\nimport { Category, ConsoleLogger as Logger, DataStoreAction, jitteredBackoff, NonRetryableError, retry, BackgroundProcessManager } from '@aws-amplify/core';\nimport Observable from 'zen-observable-ts';\nimport { DISCARD, isModelFieldType, isTargetNameAssociation, OpType, ProcessName } from '../../types';\nimport { extractTargetNamesFromSrc, USER, ID } from '../../util';\nimport { buildGraphQLOperation, createMutationInstanceFromModelOperation, getModelAuthModes, TransformerMutationType, getTokenForCustomAuth } from '../utils';\nimport { getMutationErrorType } from './errorMaps';\nvar MAX_ATTEMPTS = 10;\nvar logger = new Logger('DataStore');\nvar MutationProcessor = /** @class */function () {\n  function MutationProcessor(schema, storage, userClasses, outbox, modelInstanceCreator, MutationEvent, amplifyConfig, authModeStrategy, errorHandler, conflictHandler, amplifyContext) {\n    if (amplifyConfig === void 0) {\n      amplifyConfig = {};\n    }\n    this.schema = schema;\n    this.storage = storage;\n    this.userClasses = userClasses;\n    this.outbox = outbox;\n    this.modelInstanceCreator = modelInstanceCreator;\n    this.MutationEvent = MutationEvent;\n    this.amplifyConfig = amplifyConfig;\n    this.authModeStrategy = authModeStrategy;\n    this.errorHandler = errorHandler;\n    this.conflictHandler = conflictHandler;\n    this.amplifyContext = amplifyContext;\n    this.typeQuery = new WeakMap();\n    this.processing = false;\n    this.runningProcesses = new BackgroundProcessManager();\n    this.amplifyContext.InternalAPI = this.amplifyContext.InternalAPI || InternalAPI;\n    this.generateQueries();\n  }\n  MutationProcessor.prototype.generateQueries = function () {\n    var _this = this;\n    Object.values(this.schema.namespaces).forEach(function (namespace) {\n      Object.values(namespace.models).filter(function (_a) {\n        var syncable = _a.syncable;\n        return syncable;\n      }).forEach(function (model) {\n        var _a = __read(buildGraphQLOperation(namespace, model, 'CREATE'), 1),\n          createMutation = _a[0];\n        var _b = __read(buildGraphQLOperation(namespace, model, 'UPDATE'), 1),\n          updateMutation = _b[0];\n        var _c = __read(buildGraphQLOperation(namespace, model, 'DELETE'), 1),\n          deleteMutation = _c[0];\n        _this.typeQuery.set(model, [createMutation, updateMutation, deleteMutation]);\n      });\n    });\n  };\n  MutationProcessor.prototype.isReady = function () {\n    return this.observer !== undefined;\n  };\n  MutationProcessor.prototype.start = function () {\n    var _this = this;\n    this.runningProcesses = new BackgroundProcessManager();\n    var observable = new Observable(function (observer) {\n      _this.observer = observer;\n      try {\n        _this.resume();\n      } catch (error) {\n        logger.error('mutations processor start error', error);\n        throw error;\n      }\n      return _this.runningProcesses.addCleaner(function () {\n        return __awaiter(_this, void 0, void 0, function () {\n          return __generator(this, function (_a) {\n            // The observer has unsubscribed and/or `stop()` has been called.\n            this.removeObserver();\n            this.pause();\n            return [2 /*return*/];\n          });\n        });\n      });\n    });\n\n    return observable;\n  };\n  MutationProcessor.prototype.stop = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.removeObserver();\n            return [4 /*yield*/, this.runningProcesses.close()];\n          case 1:\n            _a.sent();\n            return [4 /*yield*/, this.runningProcesses.open()];\n          case 2:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  MutationProcessor.prototype.removeObserver = function () {\n    var _a, _b;\n    (_b = (_a = this.observer) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);\n    this.observer = undefined;\n  };\n  MutationProcessor.prototype.resume = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.runningProcesses.isOpen && this.runningProcesses.add(function (onTerminate) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var head, namespaceName, _loop_1, this_1, _a;\n                var _this = this;\n                var _b, _c;\n                return __generator(this, function (_d) {\n                  switch (_d.label) {\n                    case 0:\n                      if (this.processing || !this.isReady() || !this.runningProcesses.isOpen) {\n                        return [2 /*return*/];\n                      }\n\n                      this.processing = true;\n                      namespaceName = USER;\n                      _loop_1 = function () {\n                        var model, operation, data, condition, modelConstructor, result, opName, modelDefinition, modelAuthModes, operationAuthModes_1, authModeAttempts_1, authModeRetry_1, error_1, record, hasMore;\n                        var _a;\n                        return __generator(this, function (_b) {\n                          switch (_b.label) {\n                            case 0:\n                              model = head.model, operation = head.operation, data = head.data, condition = head.condition;\n                              modelConstructor = this_1.userClasses[model];\n                              result = undefined;\n                              opName = undefined;\n                              modelDefinition = undefined;\n                              _b.label = 1;\n                            case 1:\n                              _b.trys.push([1, 4,, 5]);\n                              return [4 /*yield*/, getModelAuthModes({\n                                authModeStrategy: this_1.authModeStrategy,\n                                defaultAuthMode: this_1.amplifyConfig.aws_appsync_authenticationType,\n                                modelName: model,\n                                schema: this_1.schema\n                              })];\n                            case 2:\n                              modelAuthModes = _b.sent();\n                              operationAuthModes_1 = modelAuthModes[operation.toUpperCase()];\n                              authModeAttempts_1 = 0;\n                              authModeRetry_1 = function () {\n                                return __awaiter(_this, void 0, void 0, function () {\n                                  var response, error_2, e_1;\n                                  return __generator(this, function (_a) {\n                                    switch (_a.label) {\n                                      case 0:\n                                        _a.trys.push([0, 2,, 9]);\n                                        logger.debug(\"Attempting mutation with authMode: \" + operationAuthModes_1[authModeAttempts_1]);\n                                        return [4 /*yield*/, this.jitteredRetry(namespaceName, model, operation, data, condition, modelConstructor, this.MutationEvent, head, operationAuthModes_1[authModeAttempts_1], onTerminate)];\n                                      case 1:\n                                        response = _a.sent();\n                                        logger.debug(\"Mutation sent successfully with authMode: \" + operationAuthModes_1[authModeAttempts_1]);\n                                        return [2 /*return*/, response];\n                                      case 2:\n                                        error_2 = _a.sent();\n                                        authModeAttempts_1++;\n                                        if (!(authModeAttempts_1 >= operationAuthModes_1.length)) return [3 /*break*/, 7];\n                                        logger.debug(\"Mutation failed with authMode: \" + operationAuthModes_1[authModeAttempts_1 - 1]);\n                                        _a.label = 3;\n                                      case 3:\n                                        _a.trys.push([3, 5,, 6]);\n                                        return [4 /*yield*/, this.errorHandler({\n                                          recoverySuggestion: 'Ensure app code is up to date, auth directives exist and are correct on each model, and that server-side data has not been invalidated by a schema change. If the problem persists, search for or create an issue: https://github.com/aws-amplify/amplify-js/issues',\n                                          localModel: null,\n                                          message: error_2.message,\n                                          model: modelConstructor.name,\n                                          operation: opName,\n                                          errorType: getMutationErrorType(error_2),\n                                          process: ProcessName.sync,\n                                          remoteModel: null,\n                                          cause: error_2\n                                        })];\n                                      case 4:\n                                        _a.sent();\n                                        return [3 /*break*/, 6];\n                                      case 5:\n                                        e_1 = _a.sent();\n                                        logger.error('Mutation error handler failed with:', e_1);\n                                        return [3 /*break*/, 6];\n                                      case 6:\n                                        throw error_2;\n                                      case 7:\n                                        logger.debug(\"Mutation failed with authMode: \" + operationAuthModes_1[authModeAttempts_1 - 1] + \". Retrying with authMode: \" + operationAuthModes_1[authModeAttempts_1]);\n                                        return [4 /*yield*/, authModeRetry_1()];\n                                      case 8:\n                                        return [2 /*return*/, _a.sent()];\n                                      case 9:\n                                        return [2 /*return*/];\n                                    }\n                                  });\n                                });\n                              };\n\n                              return [4 /*yield*/, authModeRetry_1()];\n                            case 3:\n                              _a = __read.apply(void 0, [_b.sent(), 3]), result = _a[0], opName = _a[1], modelDefinition = _a[2];\n                              return [3 /*break*/, 5];\n                            case 4:\n                              error_1 = _b.sent();\n                              if (error_1.message === 'Offline' || error_1.message === 'RetryMutation') {\n                                return [2 /*return*/, \"continue\"];\n                              }\n                              return [3 /*break*/, 5];\n                            case 5:\n                              if (!(result === undefined)) return [3 /*break*/, 7];\n                              logger.debug('done retrying');\n                              return [4 /*yield*/, this_1.storage.runExclusive(function (storage) {\n                                return __awaiter(_this, void 0, void 0, function () {\n                                  return __generator(this, function (_a) {\n                                    switch (_a.label) {\n                                      case 0:\n                                        return [4 /*yield*/, this.outbox.dequeue(storage)];\n                                      case 1:\n                                        _a.sent();\n                                        return [2 /*return*/];\n                                    }\n                                  });\n                                });\n                              })];\n\n                            case 6:\n                              _b.sent();\n                              return [2 /*return*/, \"continue\"];\n                            case 7:\n                              record = result.data[opName];\n                              hasMore = false;\n                              return [4 /*yield*/, this_1.storage.runExclusive(function (storage) {\n                                return __awaiter(_this, void 0, void 0, function () {\n                                  return __generator(this, function (_a) {\n                                    switch (_a.label) {\n                                      case 0:\n                                        // using runExclusive to prevent possible race condition\n                                        // when another record gets enqueued between dequeue and peek\n                                        return [4 /*yield*/, this.outbox.dequeue(storage, record, operation)];\n                                      case 1:\n                                        // using runExclusive to prevent possible race condition\n                                        // when another record gets enqueued between dequeue and peek\n                                        _a.sent();\n                                        return [4 /*yield*/, this.outbox.peek(storage)];\n                                      case 2:\n                                        hasMore = _a.sent() !== undefined;\n                                        return [2 /*return*/];\n                                    }\n                                  });\n                                });\n                              })];\n\n                            case 8:\n                              _b.sent();\n                              (_c = (_b = this_1.observer) === null || _b === void 0 ? void 0 : _b.next) === null || _c === void 0 ? void 0 : _c.call(_b, {\n                                operation: operation,\n                                modelDefinition: modelDefinition,\n                                model: record,\n                                hasMore: hasMore\n                              });\n                              return [2 /*return*/];\n                          }\n                        });\n                      };\n\n                      this_1 = this;\n                      _d.label = 1;\n                    case 1:\n                      _a = this.processing && this.runningProcesses.isOpen;\n                      if (!_a) return [3 /*break*/, 3];\n                      return [4 /*yield*/, this.outbox.peek(this.storage)];\n                    case 2:\n                      _a = (head = _d.sent()) !== undefined;\n                      _d.label = 3;\n                    case 3:\n                      if (!_a) return [3 /*break*/, 5];\n                      return [5 /*yield**/, _loop_1()];\n                    case 4:\n                      _d.sent();\n                      return [3 /*break*/, 1];\n                    case 5:\n                      // pauses itself\n                      this.pause();\n                      return [2 /*return*/];\n                  }\n                });\n              });\n            }, 'mutation resume loop')];\n          case 1:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  MutationProcessor.prototype.jitteredRetry = function (namespaceName, model, operation, data, condition, modelConstructor, MutationEvent, mutationEvent, authMode, onTerminate) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, retry(function (model, operation, data, condition, modelConstructor, MutationEvent, mutationEvent) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var _a, query, variables, graphQLCondition, opName, modelDefinition, authToken, tryWith, attempt, opType, customUserAgentDetails, result, err_1, _b, error, _c, _d, code, retryWith, err_2, _e, _f, opName_1, query_1, authToken_1, serverData, namespace, updatedMutation;\n                var _g;\n                return __generator(this, function (_h) {\n                  switch (_h.label) {\n                    case 0:\n                      _a = __read(this.createQueryVariables(namespaceName, model, operation, data, condition), 5), query = _a[0], variables = _a[1], graphQLCondition = _a[2], opName = _a[3], modelDefinition = _a[4];\n                      return [4 /*yield*/, getTokenForCustomAuth(authMode, this.amplifyConfig)];\n                    case 1:\n                      authToken = _h.sent();\n                      tryWith = {\n                        query: query,\n                        variables: variables,\n                        authMode: authMode,\n                        authToken: authToken\n                      };\n                      attempt = 0;\n                      opType = this.opTypeFromTransformerOperation(operation);\n                      customUserAgentDetails = {\n                        category: Category.DataStore,\n                        action: DataStoreAction.GraphQl\n                      };\n                      _h.label = 2;\n                    case 2:\n                      _h.trys.push([2, 4,, 17]);\n                      return [4 /*yield*/, this.amplifyContext.InternalAPI.graphql(tryWith, undefined, customUserAgentDetails)];\n                    case 3:\n                      result = _h.sent();\n                      // Use `as any` because TypeScript doesn't seem to like passing tuples\n                      // through generic params.\n                      return [2 /*return*/, [result, opName, modelDefinition]];\n                    case 4:\n                      err_1 = _h.sent();\n                      if (!(err_1.errors && err_1.errors.length > 0)) return [3 /*break*/, 15];\n                      _b = __read(err_1.errors, 1), error = _b[0];\n                      _c = error.originalError, _d = (_c === void 0 ? {} : _c).code, code = _d === void 0 ? null : _d;\n                      if (error.errorType === 'Unauthorized') {\n                        throw new NonRetryableError('Unauthorized');\n                      }\n                      if (error.message === 'Network Error' || code === 'ECONNABORTED' // refers to axios timeout error caused by device's bad network condition\n                      ) {\n                        if (!this.processing) {\n                          throw new NonRetryableError('Offline');\n                        }\n                        // TODO: Check errors on different env (react-native or other browsers)\n                        throw new Error('Network Error');\n                      }\n                      if (!(error.errorType === 'ConflictUnhandled')) return [3 /*break*/, 13];\n                      // TODO: add on ConflictConditionalCheck error query last from server\n                      attempt++;\n                      retryWith = void 0;\n                      if (!(attempt > MAX_ATTEMPTS)) return [3 /*break*/, 5];\n                      retryWith = DISCARD;\n                      return [3 /*break*/, 8];\n                    case 5:\n                      _h.trys.push([5, 7,, 8]);\n                      return [4 /*yield*/, this.conflictHandler({\n                        modelConstructor: modelConstructor,\n                        localModel: this.modelInstanceCreator(modelConstructor, variables.input),\n                        remoteModel: this.modelInstanceCreator(modelConstructor, error.data),\n                        operation: opType,\n                        attempts: attempt\n                      })];\n                    case 6:\n                      retryWith = _h.sent();\n                      return [3 /*break*/, 8];\n                    case 7:\n                      err_2 = _h.sent();\n                      logger.warn('conflict trycatch', err_2);\n                      return [3 /*break*/, 17];\n                    case 8:\n                      if (!(retryWith === DISCARD)) return [3 /*break*/, 11];\n                      _e = __read(buildGraphQLOperation(this.schema.namespaces[namespaceName], modelDefinition, 'GET'), 1), _f = __read(_e[0], 3), opName_1 = _f[1], query_1 = _f[2];\n                      return [4 /*yield*/, getTokenForCustomAuth(authMode, this.amplifyConfig)];\n                    case 9:\n                      authToken_1 = _h.sent();\n                      return [4 /*yield*/, this.amplifyContext.InternalAPI.graphql({\n                        query: query_1,\n                        variables: {\n                          id: variables.input.id\n                        },\n                        authMode: authMode,\n                        authToken: authToken_1\n                      }, undefined, customUserAgentDetails)];\n                    case 10:\n                      serverData = _h.sent();\n                      // onTerminate cancel graphql()\n                      return [2 /*return*/, [serverData, opName_1, modelDefinition]];\n                    case 11:\n                      namespace = this.schema.namespaces[namespaceName];\n                      updatedMutation = createMutationInstanceFromModelOperation(namespace.relationships, modelDefinition, opType, modelConstructor, retryWith, graphQLCondition, MutationEvent, this.modelInstanceCreator, mutationEvent.id);\n                      return [4 /*yield*/, this.storage.save(updatedMutation)];\n                    case 12:\n                      _h.sent();\n                      throw new NonRetryableError('RetryMutation');\n                    case 13:\n                      try {\n                        this.errorHandler({\n                          recoverySuggestion: 'Ensure app code is up to date, auth directives exist and are correct on each model, and that server-side data has not been invalidated by a schema change. If the problem persists, search for or create an issue: https://github.com/aws-amplify/amplify-js/issues',\n                          localModel: variables.input,\n                          message: error.message,\n                          operation: operation,\n                          errorType: getMutationErrorType(error),\n                          errorInfo: error.errorInfo,\n                          process: ProcessName.mutate,\n                          cause: error,\n                          remoteModel: error.data ? this.modelInstanceCreator(modelConstructor, error.data) : null\n                        });\n                      } catch (err) {\n                        logger.warn('Mutation error handler failed with:', err);\n                      } finally {\n                        // Return empty tuple, dequeues the mutation\n                        return [2 /*return*/, error.data ? [{\n                          data: (_g = {}, _g[opName] = error.data, _g)\n                        }, opName, modelDefinition] : []];\n                      }\n                      _h.label = 14;\n                    case 14:\n                      return [3 /*break*/, 16];\n                    case 15:\n                      // Catch-all for client-side errors that don't come back in the `GraphQLError` format.\n                      // These errors should not be retried.\n                      throw new NonRetryableError(err_1);\n                    case 16:\n                      return [3 /*break*/, 17];\n                    case 17:\n                      if (tryWith) return [3 /*break*/, 2];\n                      _h.label = 18;\n                    case 18:\n                      return [2 /*return*/];\n                  }\n                });\n              });\n            }, [model, operation, data, condition, modelConstructor, MutationEvent, mutationEvent], safeJitteredBackoff, onTerminate)];\n          case 1:\n            return [2 /*return*/, _a.sent()];\n        }\n      });\n    });\n  };\n  MutationProcessor.prototype.createQueryVariables = function (namespaceName, model, operation, data, condition) {\n    var e_2, _a, e_3, _b, e_4, _c;\n    var _d, _e;\n    var modelDefinition = this.schema.namespaces[namespaceName].models[model];\n    var primaryKey = this.schema.namespaces[namespaceName].keys[model].primaryKey;\n    var auth = (_d = modelDefinition.attributes) === null || _d === void 0 ? void 0 : _d.find(function (a) {\n      return a.type === 'auth';\n    });\n    var ownerFields = ((_e = auth === null || auth === void 0 ? void 0 : auth.properties) === null || _e === void 0 ? void 0 : _e.rules.map(function (rule) {\n      return rule.ownerField;\n    }).filter(function (f) {\n      return f;\n    })) || ['owner'];\n    var queriesTuples = this.typeQuery.get(modelDefinition);\n    var _f = __read(queriesTuples.find(function (_a) {\n        var _b = __read(_a, 1),\n          transformerMutationType = _b[0];\n        return transformerMutationType === operation;\n      }), 3),\n      opName = _f[1],\n      query = _f[2];\n    var _g = JSON.parse(data),\n      _version = _g._version,\n      parsedData = __rest(_g, [\"_version\"]);\n    // include all the fields that comprise a custom PK if one is specified\n    var deleteInput = {};\n    if (primaryKey === null || primaryKey === void 0 ? void 0 : primaryKey.length) {\n      try {\n        for (var primaryKey_1 = __values(primaryKey), primaryKey_1_1 = primaryKey_1.next(); !primaryKey_1_1.done; primaryKey_1_1 = primaryKey_1.next()) {\n          var pkField = primaryKey_1_1.value;\n          deleteInput[pkField] = parsedData[pkField];\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (primaryKey_1_1 && !primaryKey_1_1.done && (_a = primaryKey_1.return)) _a.call(primaryKey_1);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    } else {\n      deleteInput[ID] = parsedData.id;\n    }\n    var mutationInput;\n    if (operation === TransformerMutationType.DELETE) {\n      // For DELETE mutations, only the key(s) are included in the input\n      mutationInput = deleteInput;\n    } else {\n      // Otherwise, we construct the mutation input with the following logic\n      mutationInput = {};\n      var modelFields = Object.values(modelDefinition.fields);\n      try {\n        for (var modelFields_1 = __values(modelFields), modelFields_1_1 = modelFields_1.next(); !modelFields_1_1.done; modelFields_1_1 = modelFields_1.next()) {\n          var _h = modelFields_1_1.value,\n            name_1 = _h.name,\n            type = _h.type,\n            association = _h.association,\n            isReadOnly = _h.isReadOnly;\n          // omit readonly fields. cloud storage doesn't need them and won't take them!\n          if (isReadOnly) {\n            continue;\n          }\n          // omit owner fields if it's `null`. cloud storage doesn't allow it.\n          if (ownerFields.includes(name_1) && parsedData[name_1] === null) {\n            continue;\n          }\n          // model fields should be stripped out from the input\n          if (isModelFieldType(type)) {\n            // except for belongs to relations - we need to replace them with the correct foreign key(s)\n            if (isTargetNameAssociation(association) && association.connectionType === 'BELONGS_TO') {\n              var targetNames = extractTargetNamesFromSrc(association);\n              if (targetNames) {\n                try {\n                  // instead of including the connected model itself, we add its key(s) to the mutation input\n                  for (var targetNames_1 = (e_4 = void 0, __values(targetNames)), targetNames_1_1 = targetNames_1.next(); !targetNames_1_1.done; targetNames_1_1 = targetNames_1.next()) {\n                    var targetName = targetNames_1_1.value;\n                    mutationInput[targetName] = parsedData[targetName];\n                  }\n                } catch (e_4_1) {\n                  e_4 = {\n                    error: e_4_1\n                  };\n                } finally {\n                  try {\n                    if (targetNames_1_1 && !targetNames_1_1.done && (_c = targetNames_1.return)) _c.call(targetNames_1);\n                  } finally {\n                    if (e_4) throw e_4.error;\n                  }\n                }\n              }\n            }\n            continue;\n          }\n          // scalar fields / non-model types\n          if (operation === TransformerMutationType.UPDATE) {\n            if (!parsedData.hasOwnProperty(name_1)) {\n              // for update mutations - strip out a field if it's unchanged\n              continue;\n            }\n          }\n          // all other fields are added to the input object\n          mutationInput[name_1] = parsedData[name_1];\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (modelFields_1_1 && !modelFields_1_1.done && (_b = modelFields_1.return)) _b.call(modelFields_1);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n    }\n    // Build mutation variables input object\n    var input = __assign(__assign({}, mutationInput), {\n      _version: _version\n    });\n    var graphQLCondition = JSON.parse(condition);\n    var variables = __assign({\n      input: input\n    }, operation === TransformerMutationType.CREATE ? {} : {\n      condition: Object.keys(graphQLCondition).length > 0 ? graphQLCondition : null\n    });\n    return [query, variables, graphQLCondition, opName, modelDefinition];\n  };\n  MutationProcessor.prototype.opTypeFromTransformerOperation = function (operation) {\n    switch (operation) {\n      case TransformerMutationType.CREATE:\n        return OpType.INSERT;\n      case TransformerMutationType.DELETE:\n        return OpType.DELETE;\n      case TransformerMutationType.UPDATE:\n        return OpType.UPDATE;\n      case TransformerMutationType.GET:\n        // Intentionally blank\n        break;\n      default:\n        throw new Error(\"Invalid operation \" + operation);\n    }\n    // because it makes TS happy ...\n    return undefined;\n  };\n  MutationProcessor.prototype.pause = function () {\n    this.processing = false;\n  };\n  return MutationProcessor;\n}();\nvar MAX_RETRY_DELAY_MS = 5 * 60 * 1000;\nvar originalJitteredBackoff = jitteredBackoff(MAX_RETRY_DELAY_MS);\n/**\n * @private\n * Internal use of Amplify only.\n *\n * Wraps the jittered backoff calculation to retry Network Errors indefinitely.\n * Backs off according to original jittered retry logic until the original retry\n * logic hits its max. After this occurs, if the error is a Network Error, we\n * ignore the attempt count and return MAX_RETRY_DELAY_MS to retry forever (until\n * the request succeeds).\n *\n * @param attempt ignored\n * @param _args ignored\n * @param error tested to see if `.message` is 'Network Error'\n * @returns number | false :\n */\nexport var safeJitteredBackoff = function (attempt, _args, error) {\n  var attemptResult = originalJitteredBackoff(attempt);\n  // If this is the last attempt and it is a network error, we retry indefinitively every 5 minutes\n  if (attemptResult === false && (error === null || error === void 0 ? void 0 : error.message) === 'Network Error') {\n    return MAX_RETRY_DELAY_MS;\n  }\n  return attemptResult;\n};\nexport { MutationProcessor };","map":{"version":3,"names":["InternalAPI","Category","ConsoleLogger","Logger","DataStoreAction","jitteredBackoff","NonRetryableError","retry","BackgroundProcessManager","Observable","DISCARD","isModelFieldType","isTargetNameAssociation","OpType","ProcessName","extractTargetNamesFromSrc","USER","ID","buildGraphQLOperation","createMutationInstanceFromModelOperation","getModelAuthModes","TransformerMutationType","getTokenForCustomAuth","getMutationErrorType","MAX_ATTEMPTS","logger","MutationProcessor","schema","storage","userClasses","outbox","modelInstanceCreator","MutationEvent","amplifyConfig","authModeStrategy","errorHandler","conflictHandler","amplifyContext","typeQuery","WeakMap","processing","runningProcesses","generateQueries","prototype","_this","Object","values","namespaces","forEach","namespace","models","filter","_a","syncable","model","__read","createMutation","_b","updateMutation","_c","deleteMutation","set","isReady","observer","undefined","start","observable","resume","error","addCleaner","__awaiter","removeObserver","pause","stop","close","sent","open","complete","call","isOpen","add","onTerminate","namespaceName","head","operation","data","condition","modelConstructor","this_1","result","opName","modelDefinition","defaultAuthMode","aws_appsync_authenticationType","modelName","modelAuthModes","operationAuthModes_1","toUpperCase","authModeAttempts_1","authModeRetry_1","debug","jitteredRetry","response","length","recoverySuggestion","localModel","message","error_2","name","errorType","process","sync","remoteModel","cause","e_1","apply","error_1","runExclusive","dequeue","record","hasMore","peek","next","_d","mutationEvent","authMode","createQueryVariables","query","variables","graphQLCondition","authToken","_h","tryWith","attempt","opType","opTypeFromTransformerOperation","customUserAgentDetails","category","DataStore","action","GraphQl","graphql","err_1","errors","originalError","code","Error","retryWith","input","attempts","warn","err_2","_e","_f","opName_1","query_1","authToken_1","id","serverData","updatedMutation","relationships","save","errorInfo","mutate","err","_g","safeJitteredBackoff","primaryKey","keys","auth","attributes","find","a","type","ownerFields","properties","rules","map","rule","ownerField","f","queriesTuples","get","JSON","parse","_version","parsedData","__rest","deleteInput","primaryKey_1","__values","primaryKey_1_1","done","pkField","value","mutationInput","DELETE","modelFields","fields","modelFields_1","modelFields_1_1","name_1","association","isReadOnly","includes","connectionType","targetNames","targetNames_1","e_4","targetNames_1_1","targetName","UPDATE","hasOwnProperty","__assign","CREATE","INSERT","GET","MAX_RETRY_DELAY_MS","originalJitteredBackoff","_args","attemptResult"],"sources":["/Users/yannellym/Desktop/iwantapet/node_modules/@aws-amplify/datastore/src/sync/processors/mutation.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { GraphQLResult, GRAPHQL_AUTH_MODE } from '@aws-amplify/api';\nimport { InternalAPI } from '@aws-amplify/api/internals';\nimport {\n\tCategory,\n\tConsoleLogger as Logger,\n\tCustomUserAgentDetails,\n\tDataStoreAction,\n\tjitteredBackoff,\n\tNonRetryableError,\n\tretry,\n\tBackgroundProcessManager,\n} from '@aws-amplify/core';\nimport Observable, { ZenObservable } from 'zen-observable-ts';\nimport { MutationEvent } from '../';\nimport { ModelInstanceCreator } from '../../datastore/datastore';\nimport { ExclusiveStorage as Storage } from '../../storage/storage';\nimport {\n\tAuthModeStrategy,\n\tConflictHandler,\n\tDISCARD,\n\tErrorHandler,\n\tGraphQLCondition,\n\tInternalSchema,\n\tisModelFieldType,\n\tisTargetNameAssociation,\n\tModelInstanceMetadata,\n\tOpType,\n\tPersistentModel,\n\tPersistentModelConstructor,\n\tSchemaModel,\n\tTypeConstructorMap,\n\tProcessName,\n\tAmplifyContext,\n} from '../../types';\nimport { extractTargetNamesFromSrc, USER, ID } from '../../util';\nimport { MutationEventOutbox } from '../outbox';\nimport {\n\tbuildGraphQLOperation,\n\tcreateMutationInstanceFromModelOperation,\n\tgetModelAuthModes,\n\tTransformerMutationType,\n\tgetTokenForCustomAuth,\n} from '../utils';\nimport { getMutationErrorType } from './errorMaps';\n\nconst MAX_ATTEMPTS = 10;\n\nconst logger = new Logger('DataStore');\n\ntype MutationProcessorEvent = {\n\toperation: TransformerMutationType;\n\tmodelDefinition: SchemaModel;\n\tmodel: PersistentModel;\n\thasMore: boolean;\n};\n\nclass MutationProcessor {\n\t/**\n\t * The observer that receives messages when mutations are successfully completed\n\t * against cloud storage.\n\t *\n\t * A value of `undefined` signals that the sync has either been stopped or has not\n\t * yet started. In this case, `isReady()` will be `false` and `resume()` will exit\n\t * early.\n\t */\n\tprivate observer?: ZenObservable.Observer<MutationProcessorEvent>;\n\tprivate readonly typeQuery = new WeakMap<\n\t\tSchemaModel,\n\t\t[TransformerMutationType, string, string][]\n\t>();\n\tprivate processing: boolean = false;\n\n\tprivate runningProcesses = new BackgroundProcessManager();\n\n\tconstructor(\n\t\tprivate readonly schema: InternalSchema,\n\t\tprivate readonly storage: Storage,\n\t\tprivate readonly userClasses: TypeConstructorMap,\n\t\tprivate readonly outbox: MutationEventOutbox,\n\t\tprivate readonly modelInstanceCreator: ModelInstanceCreator,\n\t\tprivate readonly MutationEvent: PersistentModelConstructor<MutationEvent>,\n\t\tprivate readonly amplifyConfig: Record<string, any> = {},\n\t\tprivate readonly authModeStrategy: AuthModeStrategy,\n\t\tprivate readonly errorHandler: ErrorHandler,\n\t\tprivate readonly conflictHandler: ConflictHandler,\n\t\tprivate readonly amplifyContext: AmplifyContext\n\t) {\n\t\tthis.amplifyContext.InternalAPI =\n\t\t\tthis.amplifyContext.InternalAPI || InternalAPI;\n\t\tthis.generateQueries();\n\t}\n\n\tprivate generateQueries() {\n\t\tObject.values(this.schema.namespaces).forEach(namespace => {\n\t\t\tObject.values(namespace.models)\n\t\t\t\t.filter(({ syncable }) => syncable)\n\t\t\t\t.forEach(model => {\n\t\t\t\t\tconst [createMutation] = buildGraphQLOperation(\n\t\t\t\t\t\tnamespace,\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t'CREATE'\n\t\t\t\t\t);\n\t\t\t\t\tconst [updateMutation] = buildGraphQLOperation(\n\t\t\t\t\t\tnamespace,\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t'UPDATE'\n\t\t\t\t\t);\n\t\t\t\t\tconst [deleteMutation] = buildGraphQLOperation(\n\t\t\t\t\t\tnamespace,\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t'DELETE'\n\t\t\t\t\t);\n\n\t\t\t\t\tthis.typeQuery.set(model, [\n\t\t\t\t\t\tcreateMutation,\n\t\t\t\t\t\tupdateMutation,\n\t\t\t\t\t\tdeleteMutation,\n\t\t\t\t\t]);\n\t\t\t\t});\n\t\t});\n\t}\n\n\tprivate isReady() {\n\t\treturn this.observer !== undefined;\n\t}\n\n\tpublic start(): Observable<MutationProcessorEvent> {\n\t\tthis.runningProcesses = new BackgroundProcessManager();\n\n\t\tconst observable = new Observable<MutationProcessorEvent>(observer => {\n\t\t\tthis.observer = observer;\n\n\t\t\ttry {\n\t\t\t\tthis.resume();\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error('mutations processor start error', error);\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\treturn this.runningProcesses.addCleaner(async () => {\n\t\t\t\t// The observer has unsubscribed and/or `stop()` has been called.\n\t\t\t\tthis.removeObserver();\n\t\t\t\tthis.pause();\n\t\t\t});\n\t\t});\n\n\t\treturn observable;\n\t}\n\n\tpublic async stop() {\n\t\tthis.removeObserver();\n\t\tawait this.runningProcesses.close();\n\t\tawait this.runningProcesses.open();\n\t}\n\n\tpublic removeObserver() {\n\t\tthis.observer?.complete?.();\n\t\tthis.observer = undefined;\n\t}\n\n\tpublic async resume(): Promise<void> {\n\t\tawait (this.runningProcesses.isOpen &&\n\t\t\tthis.runningProcesses.add(async onTerminate => {\n\t\t\t\tif (\n\t\t\t\t\tthis.processing ||\n\t\t\t\t\t!this.isReady() ||\n\t\t\t\t\t!this.runningProcesses.isOpen\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.processing = true;\n\t\t\t\tlet head: MutationEvent;\n\t\t\t\tconst namespaceName = USER;\n\n\t\t\t\t// start to drain outbox\n\t\t\t\twhile (\n\t\t\t\t\tthis.processing &&\n\t\t\t\t\tthis.runningProcesses.isOpen &&\n\t\t\t\t\t(head = await this.outbox.peek(this.storage)) !== undefined\n\t\t\t\t) {\n\t\t\t\t\tconst { model, operation, data, condition } = head;\n\t\t\t\t\tconst modelConstructor = this.userClasses[\n\t\t\t\t\t\tmodel\n\t\t\t\t\t] as PersistentModelConstructor<MutationEvent>;\n\t\t\t\t\tlet result: GraphQLResult<Record<string, PersistentModel>> =\n\t\t\t\t\t\tundefined!;\n\t\t\t\t\tlet opName: string = undefined!;\n\t\t\t\t\tlet modelDefinition: SchemaModel = undefined!;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst modelAuthModes = await getModelAuthModes({\n\t\t\t\t\t\t\tauthModeStrategy: this.authModeStrategy,\n\t\t\t\t\t\t\tdefaultAuthMode:\n\t\t\t\t\t\t\t\tthis.amplifyConfig.aws_appsync_authenticationType,\n\t\t\t\t\t\t\tmodelName: model,\n\t\t\t\t\t\t\tschema: this.schema,\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst operationAuthModes = modelAuthModes[operation.toUpperCase()];\n\n\t\t\t\t\t\tlet authModeAttempts = 0;\n\t\t\t\t\t\tconst authModeRetry = async () => {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t\t\t`Attempting mutation with authMode: ${operationAuthModes[authModeAttempts]}`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tconst response = await this.jitteredRetry(\n\t\t\t\t\t\t\t\t\tnamespaceName,\n\t\t\t\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t\t\t\toperation,\n\t\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\t\tcondition,\n\t\t\t\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\t\t\t\tthis.MutationEvent,\n\t\t\t\t\t\t\t\t\thead,\n\t\t\t\t\t\t\t\t\toperationAuthModes[authModeAttempts],\n\t\t\t\t\t\t\t\t\tonTerminate\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t\t\t`Mutation sent successfully with authMode: ${operationAuthModes[authModeAttempts]}`\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\treturn response;\n\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\tauthModeAttempts++;\n\t\t\t\t\t\t\t\tif (authModeAttempts >= operationAuthModes.length) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t\t\t\t`Mutation failed with authMode: ${\n\t\t\t\t\t\t\t\t\t\t\toperationAuthModes[authModeAttempts - 1]\n\t\t\t\t\t\t\t\t\t\t}`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tawait this.errorHandler({\n\t\t\t\t\t\t\t\t\t\t\trecoverySuggestion:\n\t\t\t\t\t\t\t\t\t\t\t\t'Ensure app code is up to date, auth directives exist and are correct on each model, and that server-side data has not been invalidated by a schema change. If the problem persists, search for or create an issue: https://github.com/aws-amplify/amplify-js/issues',\n\t\t\t\t\t\t\t\t\t\t\tlocalModel: null!,\n\t\t\t\t\t\t\t\t\t\t\tmessage: error.message,\n\t\t\t\t\t\t\t\t\t\t\tmodel: modelConstructor.name,\n\t\t\t\t\t\t\t\t\t\t\toperation: opName,\n\t\t\t\t\t\t\t\t\t\t\terrorType: getMutationErrorType(error),\n\t\t\t\t\t\t\t\t\t\t\tprocess: ProcessName.sync,\n\t\t\t\t\t\t\t\t\t\t\tremoteModel: null!,\n\t\t\t\t\t\t\t\t\t\t\tcause: error,\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\t\t\tlogger.error('Mutation error handler failed with:', e);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t\t\t`Mutation failed with authMode: ${\n\t\t\t\t\t\t\t\t\t\toperationAuthModes[authModeAttempts - 1]\n\t\t\t\t\t\t\t\t\t}. Retrying with authMode: ${\n\t\t\t\t\t\t\t\t\t\toperationAuthModes[authModeAttempts]\n\t\t\t\t\t\t\t\t\t}`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\treturn await authModeRetry();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t[result, opName, modelDefinition] = await authModeRetry();\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\terror.message === 'Offline' ||\n\t\t\t\t\t\t\terror.message === 'RetryMutation'\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (result === undefined) {\n\t\t\t\t\t\tlogger.debug('done retrying');\n\t\t\t\t\t\tawait this.storage.runExclusive(async storage => {\n\t\t\t\t\t\t\tawait this.outbox.dequeue(storage);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst record = result.data![opName!];\n\t\t\t\t\tlet hasMore = false;\n\n\t\t\t\t\tawait this.storage.runExclusive(async storage => {\n\t\t\t\t\t\t// using runExclusive to prevent possible race condition\n\t\t\t\t\t\t// when another record gets enqueued between dequeue and peek\n\t\t\t\t\t\tawait this.outbox.dequeue(storage, record, operation);\n\t\t\t\t\t\thasMore = (await this.outbox.peek(storage)) !== undefined;\n\t\t\t\t\t});\n\n\t\t\t\t\tthis.observer?.next?.({\n\t\t\t\t\t\toperation,\n\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\tmodel: record,\n\t\t\t\t\t\thasMore,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// pauses itself\n\t\t\t\tthis.pause();\n\t\t\t}, 'mutation resume loop'));\n\t}\n\n\tprivate async jitteredRetry(\n\t\tnamespaceName: string,\n\t\tmodel: string,\n\t\toperation: TransformerMutationType,\n\t\tdata: string,\n\t\tcondition: string,\n\t\tmodelConstructor: PersistentModelConstructor<PersistentModel>,\n\t\tMutationEvent: PersistentModelConstructor<MutationEvent>,\n\t\tmutationEvent: MutationEvent,\n\t\tauthMode: GRAPHQL_AUTH_MODE,\n\t\tonTerminate: Promise<void>\n\t): Promise<\n\t\t[GraphQLResult<Record<string, PersistentModel>>, string, SchemaModel]\n\t> {\n\t\treturn await retry(\n\t\t\tasync (\n\t\t\t\tmodel: string,\n\t\t\t\toperation: TransformerMutationType,\n\t\t\t\tdata: string,\n\t\t\t\tcondition: string,\n\t\t\t\tmodelConstructor: PersistentModelConstructor<PersistentModel>,\n\t\t\t\tMutationEvent: PersistentModelConstructor<MutationEvent>,\n\t\t\t\tmutationEvent: MutationEvent\n\t\t\t) => {\n\t\t\t\tconst [query, variables, graphQLCondition, opName, modelDefinition] =\n\t\t\t\t\tthis.createQueryVariables(\n\t\t\t\t\t\tnamespaceName,\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\toperation,\n\t\t\t\t\t\tdata,\n\t\t\t\t\t\tcondition\n\t\t\t\t\t);\n\n\t\t\t\tconst authToken = await getTokenForCustomAuth(\n\t\t\t\t\tauthMode,\n\t\t\t\t\tthis.amplifyConfig\n\t\t\t\t);\n\n\t\t\t\tconst tryWith = {\n\t\t\t\t\tquery,\n\t\t\t\t\tvariables,\n\t\t\t\t\tauthMode,\n\t\t\t\t\tauthToken,\n\t\t\t\t};\n\t\t\t\tlet attempt = 0;\n\n\t\t\t\tconst opType = this.opTypeFromTransformerOperation(operation);\n\n\t\t\t\tconst customUserAgentDetails: CustomUserAgentDetails = {\n\t\t\t\t\tcategory: Category.DataStore,\n\t\t\t\t\taction: DataStoreAction.GraphQl,\n\t\t\t\t};\n\n\t\t\t\tdo {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst result = <GraphQLResult<Record<string, PersistentModel>>>(\n\t\t\t\t\t\t\tawait this.amplifyContext.InternalAPI.graphql(\n\t\t\t\t\t\t\t\ttryWith,\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\tcustomUserAgentDetails\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// Use `as any` because TypeScript doesn't seem to like passing tuples\n\t\t\t\t\t\t// through generic params.\n\t\t\t\t\t\treturn [result, opName, modelDefinition] as any;\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tif (err.errors && err.errors.length > 0) {\n\t\t\t\t\t\t\tconst [error] = err.errors;\n\t\t\t\t\t\t\tconst { originalError: { code = null } = {} } = error;\n\n\t\t\t\t\t\t\tif (error.errorType === 'Unauthorized') {\n\t\t\t\t\t\t\t\tthrow new NonRetryableError('Unauthorized');\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\terror.message === 'Network Error' ||\n\t\t\t\t\t\t\t\tcode === 'ECONNABORTED' // refers to axios timeout error caused by device's bad network condition\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tif (!this.processing) {\n\t\t\t\t\t\t\t\t\tthrow new NonRetryableError('Offline');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// TODO: Check errors on different env (react-native or other browsers)\n\t\t\t\t\t\t\t\tthrow new Error('Network Error');\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (error.errorType === 'ConflictUnhandled') {\n\t\t\t\t\t\t\t\t// TODO: add on ConflictConditionalCheck error query last from server\n\t\t\t\t\t\t\t\tattempt++;\n\t\t\t\t\t\t\t\tlet retryWith: PersistentModel | typeof DISCARD;\n\n\t\t\t\t\t\t\t\tif (attempt > MAX_ATTEMPTS) {\n\t\t\t\t\t\t\t\t\tretryWith = DISCARD;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tretryWith = await this.conflictHandler!({\n\t\t\t\t\t\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\t\t\t\t\t\tlocalModel: this.modelInstanceCreator(\n\t\t\t\t\t\t\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\t\t\t\t\t\t\tvariables.input\n\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\tremoteModel: this.modelInstanceCreator(\n\t\t\t\t\t\t\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\t\t\t\t\t\t\terror.data\n\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\toperation: opType,\n\t\t\t\t\t\t\t\t\t\t\tattempts: attempt,\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\t\tlogger.warn('conflict trycatch', err);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (retryWith === DISCARD) {\n\t\t\t\t\t\t\t\t\t// Query latest from server and notify merger\n\n\t\t\t\t\t\t\t\t\tconst [[, opName, query]] = buildGraphQLOperation(\n\t\t\t\t\t\t\t\t\t\tthis.schema.namespaces[namespaceName],\n\t\t\t\t\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\t\t\t\t\t'GET'\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\tconst authToken = await getTokenForCustomAuth(\n\t\t\t\t\t\t\t\t\t\tauthMode,\n\t\t\t\t\t\t\t\t\t\tthis.amplifyConfig\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\tconst serverData = <\n\t\t\t\t\t\t\t\t\t\tGraphQLResult<Record<string, PersistentModel>>\n\t\t\t\t\t\t\t\t\t>await this.amplifyContext.InternalAPI.graphql(\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tquery,\n\t\t\t\t\t\t\t\t\t\t\tvariables: { id: variables.input.id },\n\t\t\t\t\t\t\t\t\t\t\tauthMode,\n\t\t\t\t\t\t\t\t\t\t\tauthToken,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\t\tcustomUserAgentDetails\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t// onTerminate cancel graphql()\n\n\t\t\t\t\t\t\t\t\treturn [serverData, opName, modelDefinition];\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst namespace = this.schema.namespaces[namespaceName];\n\n\t\t\t\t\t\t\t\t// convert retry with to tryWith\n\t\t\t\t\t\t\t\tconst updatedMutation =\n\t\t\t\t\t\t\t\t\tcreateMutationInstanceFromModelOperation(\n\t\t\t\t\t\t\t\t\t\tnamespace.relationships!,\n\t\t\t\t\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\t\t\t\t\topType,\n\t\t\t\t\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\t\t\t\t\tretryWith,\n\t\t\t\t\t\t\t\t\t\tgraphQLCondition,\n\t\t\t\t\t\t\t\t\t\tMutationEvent,\n\t\t\t\t\t\t\t\t\t\tthis.modelInstanceCreator,\n\t\t\t\t\t\t\t\t\t\tmutationEvent.id\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tawait this.storage.save(updatedMutation);\n\n\t\t\t\t\t\t\t\tthrow new NonRetryableError('RetryMutation');\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tthis.errorHandler({\n\t\t\t\t\t\t\t\t\t\trecoverySuggestion:\n\t\t\t\t\t\t\t\t\t\t\t'Ensure app code is up to date, auth directives exist and are correct on each model, and that server-side data has not been invalidated by a schema change. If the problem persists, search for or create an issue: https://github.com/aws-amplify/amplify-js/issues',\n\t\t\t\t\t\t\t\t\t\tlocalModel: variables.input,\n\t\t\t\t\t\t\t\t\t\tmessage: error.message,\n\t\t\t\t\t\t\t\t\t\toperation,\n\t\t\t\t\t\t\t\t\t\terrorType: getMutationErrorType(error),\n\t\t\t\t\t\t\t\t\t\terrorInfo: error.errorInfo,\n\t\t\t\t\t\t\t\t\t\tprocess: ProcessName.mutate,\n\t\t\t\t\t\t\t\t\t\tcause: error,\n\t\t\t\t\t\t\t\t\t\tremoteModel: error.data\n\t\t\t\t\t\t\t\t\t\t\t? this.modelInstanceCreator(modelConstructor, error.data)\n\t\t\t\t\t\t\t\t\t\t\t: null!,\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\tlogger.warn('Mutation error handler failed with:', err);\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t// Return empty tuple, dequeues the mutation\n\t\t\t\t\t\t\t\t\treturn error.data\n\t\t\t\t\t\t\t\t\t\t? [\n\t\t\t\t\t\t\t\t\t\t\t\t{ data: { [opName]: error.data } },\n\t\t\t\t\t\t\t\t\t\t\t\topName,\n\t\t\t\t\t\t\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\t\t\t\t\t  ]\n\t\t\t\t\t\t\t\t\t\t: [];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Catch-all for client-side errors that don't come back in the `GraphQLError` format.\n\t\t\t\t\t\t\t// These errors should not be retried.\n\t\t\t\t\t\t\tthrow new NonRetryableError(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (tryWith);\n\t\t\t},\n\t\t\t[\n\t\t\t\tmodel,\n\t\t\t\toperation,\n\t\t\t\tdata,\n\t\t\t\tcondition,\n\t\t\t\tmodelConstructor,\n\t\t\t\tMutationEvent,\n\t\t\t\tmutationEvent,\n\t\t\t],\n\t\t\tsafeJitteredBackoff,\n\t\t\tonTerminate\n\t\t);\n\t}\n\n\tprivate createQueryVariables(\n\t\tnamespaceName: string,\n\t\tmodel: string,\n\t\toperation: TransformerMutationType,\n\t\tdata: string,\n\t\tcondition: string\n\t): [string, Record<string, any>, GraphQLCondition, string, SchemaModel] {\n\t\tconst modelDefinition = this.schema.namespaces[namespaceName].models[model];\n\t\tconst { primaryKey } = this.schema.namespaces[namespaceName].keys![model];\n\n\t\tconst auth = modelDefinition.attributes?.find(a => a.type === 'auth');\n\t\tconst ownerFields: string[] = auth?.properties?.rules\n\t\t\t.map(rule => rule.ownerField)\n\t\t\t.filter(f => f) || ['owner'];\n\n\t\tconst queriesTuples = this.typeQuery.get(modelDefinition);\n\n\t\tconst [, opName, query] = queriesTuples!.find(\n\t\t\t([transformerMutationType]) => transformerMutationType === operation\n\t\t)!;\n\n\t\tconst { _version, ...parsedData } = <ModelInstanceMetadata>JSON.parse(data);\n\n\t\t// include all the fields that comprise a custom PK if one is specified\n\t\tconst deleteInput = {};\n\t\tif (primaryKey?.length) {\n\t\t\tfor (const pkField of primaryKey) {\n\t\t\t\tdeleteInput[pkField] = parsedData[pkField];\n\t\t\t}\n\t\t} else {\n\t\t\tdeleteInput[ID] = (<any>parsedData).id;\n\t\t}\n\n\t\tlet mutationInput;\n\n\t\tif (operation === TransformerMutationType.DELETE) {\n\t\t\t// For DELETE mutations, only the key(s) are included in the input\n\t\t\tmutationInput = <ModelInstanceMetadata>deleteInput;\n\t\t} else {\n\t\t\t// Otherwise, we construct the mutation input with the following logic\n\t\t\tmutationInput = {};\n\t\t\tconst modelFields = Object.values(modelDefinition.fields);\n\n\t\t\tfor (const { name, type, association, isReadOnly } of modelFields) {\n\t\t\t\t// omit readonly fields. cloud storage doesn't need them and won't take them!\n\t\t\t\tif (isReadOnly) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// omit owner fields if it's `null`. cloud storage doesn't allow it.\n\t\t\t\tif (ownerFields.includes(name) && parsedData[name] === null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// model fields should be stripped out from the input\n\t\t\t\tif (isModelFieldType(type)) {\n\t\t\t\t\t// except for belongs to relations - we need to replace them with the correct foreign key(s)\n\t\t\t\t\tif (\n\t\t\t\t\t\tisTargetNameAssociation(association) &&\n\t\t\t\t\t\tassociation.connectionType === 'BELONGS_TO'\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst targetNames: string[] | undefined =\n\t\t\t\t\t\t\textractTargetNamesFromSrc(association);\n\n\t\t\t\t\t\tif (targetNames) {\n\t\t\t\t\t\t\t// instead of including the connected model itself, we add its key(s) to the mutation input\n\t\t\t\t\t\t\tfor (const targetName of targetNames) {\n\t\t\t\t\t\t\t\tmutationInput[targetName] = parsedData[targetName];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// scalar fields / non-model types\n\n\t\t\t\tif (operation === TransformerMutationType.UPDATE) {\n\t\t\t\t\tif (!parsedData.hasOwnProperty(name)) {\n\t\t\t\t\t\t// for update mutations - strip out a field if it's unchanged\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// all other fields are added to the input object\n\t\t\t\tmutationInput[name] = parsedData[name];\n\t\t\t}\n\t\t}\n\n\t\t// Build mutation variables input object\n\t\tconst input: ModelInstanceMetadata = {\n\t\t\t...mutationInput,\n\t\t\t_version,\n\t\t};\n\n\t\tconst graphQLCondition = <GraphQLCondition>JSON.parse(condition);\n\n\t\tconst variables = {\n\t\t\tinput,\n\t\t\t...(operation === TransformerMutationType.CREATE\n\t\t\t\t? {}\n\t\t\t\t: {\n\t\t\t\t\t\tcondition:\n\t\t\t\t\t\t\tObject.keys(graphQLCondition).length > 0\n\t\t\t\t\t\t\t\t? graphQLCondition\n\t\t\t\t\t\t\t\t: null,\n\t\t\t\t  }),\n\t\t};\n\t\treturn [query, variables, graphQLCondition, opName, modelDefinition];\n\t}\n\n\tprivate opTypeFromTransformerOperation(\n\t\toperation: TransformerMutationType\n\t): OpType {\n\t\tswitch (operation) {\n\t\t\tcase TransformerMutationType.CREATE:\n\t\t\t\treturn OpType.INSERT;\n\t\t\tcase TransformerMutationType.DELETE:\n\t\t\t\treturn OpType.DELETE;\n\t\t\tcase TransformerMutationType.UPDATE:\n\t\t\t\treturn OpType.UPDATE;\n\t\t\tcase TransformerMutationType.GET: // Intentionally blank\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Invalid operation ${operation}`);\n\t\t}\n\n\t\t// because it makes TS happy ...\n\t\treturn undefined!;\n\t}\n\n\tpublic pause() {\n\t\tthis.processing = false;\n\t}\n}\n\nconst MAX_RETRY_DELAY_MS = 5 * 60 * 1000;\nconst originalJitteredBackoff = jitteredBackoff(MAX_RETRY_DELAY_MS);\n\n/**\n * @private\n * Internal use of Amplify only.\n *\n * Wraps the jittered backoff calculation to retry Network Errors indefinitely.\n * Backs off according to original jittered retry logic until the original retry\n * logic hits its max. After this occurs, if the error is a Network Error, we\n * ignore the attempt count and return MAX_RETRY_DELAY_MS to retry forever (until\n * the request succeeds).\n *\n * @param attempt ignored\n * @param _args ignored\n * @param error tested to see if `.message` is 'Network Error'\n * @returns number | false :\n */\nexport const safeJitteredBackoff: typeof originalJitteredBackoff = (\n\tattempt,\n\t_args,\n\terror\n) => {\n\tconst attemptResult = originalJitteredBackoff(attempt);\n\n\t// If this is the last attempt and it is a network error, we retry indefinitively every 5 minutes\n\tif (attemptResult === false && error?.message === 'Network Error') {\n\t\treturn MAX_RETRY_DELAY_MS;\n\t}\n\n\treturn attemptResult;\n};\n\nexport { MutationProcessor };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}